{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"cuems-utils","text":"<p>Reusable classes and methods for CueMS system</p> <p> </p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install cuemsutils\n</code></pre>"},{"location":"#release-notes","title":"Release notes","text":"<p>Please refer to the repository for release notes.</p>"},{"location":"api/","title":"API Documentation","text":"<p>This API is still in development and may change without notice.</p> <p>Set of helper functions for the cuemsutils package.</p>"},{"location":"api/#cuemsutils.create_script.create_script","title":"<code>create_script()</code>","text":"<p>Create a minimal script with available cues.</p> <p>This function creates a minimal script with available cues. It includes an audio cue, a video cue and an action cue. The script is returned as a CuemsScript object.</p> <p>Returns:</p> Name Type Description <code>CuemsScript</code> <p>A minimal script with configured cues.</p> Source code in <code>src/cuemsutils/create_script.py</code> <pre><code>def create_script():\n    \"\"\"Create a minimal script with available cues.\n\n    This function creates a minimal script with available cues.\n    It includes an audio cue, a video cue and an action cue.\n    The script is returned as a CuemsScript object.\n\n    Returns:\n        CuemsScript: A minimal script with configured cues.\n    \"\"\"\n    target_uuid = '1f301cf8-dd03-4b40-ac17-ef0e5e7988be'\n    act = ActionCue({'action_target': target_uuid, 'action_type': 'play', 'ui_properties' : {'warning' : 0}})\n    ac = AudioCue({\n        'master_vol': 66,\n        'Media': Media({\n            'file_name': 'file.ext',\n            'id': '',\n            'duration': '00:00:00.000',\n            'regions': [\n                Region({\n                    'id': 0,\n                    'loop': 1,\n                    'in_time': None,\n                    'out_time': None\n                })\n            ]\n        }),\n        'ui_properties' : {\n            'warning': None\n            }\n    })\n    vc = VideoCue({\n        'Media': Media({\n            'file_name': 'file_video.ext',\n            'id': '',\n            'duration': '00:00:00.000',\n            'regions' : [\n                Region({\n                    'id': 0, 'loop': 1, 'in_time': None, 'out_time': None\n                })\n            ]\n        }),\n        'ui_properties' : {\n            'warning': None\n            }\n    })\n    dc = DmxCue({\n        'fadein_time':0.0,\n        'fadeout_time':0.0,\n        'DmxScene': DmxScene({\n            'id': 0,\n            'DmxUniverse': DmxUniverse({\n                'universe_num': 0,\n                'dmx_channels': [\n                    DmxChannel({\n                        'channel': 0,\n                        'value': 0\n                    })\n                ]\n\n            })    \n\n        }),\n        'time': 0,\n        'ui_properties' : {\n            'warning': None\n            }\n    })\n    ac.outputs = [AudioCueOutput({\n        \"output_name\": \"0367f391-ebf4-48b2-9f26-000000000001_system:playback_1\",\n        \"output_vol\": 80,\n        \"channels\": [\n            {\n                \"channel\": {\n                    \"channel_num\": 0,\n                    \"channel_vol\": 80\n                }\n            }\n        ]\n    })]\n\n    vc.outputs = [VideoCueOutput({\n        \"output_name\": \"0367f391-ebf4-48b2-9f26-000000000001_0\",\n        \"output_geometry\": {\n            \"x_scale\": 1,\n            \"y_scale\": 1,\n            \"corners\": {\n                \"top_left\": {\n                    \"x\": 0,\n                    \"y\": 0\n                },\n                \"top_right\": {\n                    \"x\": 0,\n                    \"y\": 0\n                },\n                \"bottom_left\": {\n                    \"x\": 0,\n                    \"y\": 0\n                },\n                \"bottom_right\": {\n                    \"x\": 0,\n                    \"y\": 0\n                }\n            }\n        }\n    })]\n\n    dc.outputs = [DmxCueOutput({\n        \"output_name\": \"0367f391-ebf4-48b2-9f26-000000000001\"\n    })]\n\n\n    custom_cue_list = CueList({'contents': [ac]})\n    custom_cue_list.append(vc)\n    custom_cue_list.append(dc)\n    custom_cue_list.append(act)\n\n    script = CuemsScript({'CueList': custom_cue_list})\n    script.name = \"Test Script\"\n    script.description = \"This is a test script\"\n\n    # set dates and ids so it can be validated\n    script.created = now\n    script.modified = now\n    script['id'] = new_uuid()\n    script['CueList']['id'] = new_uuid()\n    script.cuelist['contents'][0]['id'] = new_uuid()\n    script.cuelist['contents'][1]['id'] = new_uuid()\n    script.cuelist['contents'][2]['id'] = new_uuid()\n    script.cuelist['contents'][3]['id'] = new_uuid()\n    script['ui_properties'] = {\n        'warning': 0,\n    }\n    Logger.debug(f'Created test script: {script.cuelist}')\n\n    try:\n        validate_template(script)\n    except xmlschema_exceptions.XMLSchemaValidationError as e:\n        Logger.error(\"Script validation failed. Please check the template.\")\n        Logger.error(f\"Validation error: {e}\")\n    finally:\n        # remove dates and ids so we send it empty\n        script.created = None\n        script.modified = None\n        script.id = None\n        script.cuelist.id = None\n        script.cuelist.contents[0]['id'] = None\n        script.cuelist.contents[1]['id'] = None\n        script.cuelist.contents[2]['id'] = None\n        script.cuelist.contents[3]['id'] = None\n\n        return script\n</code></pre>"},{"location":"api/#cuemsutils.helpers.CuemsDict","title":"<code>CuemsDict</code>","text":"<p>               Bases: <code>dict</code></p> <p>Custom dictionary class to handle cuemsutils specific items.</p> Source code in <code>src/cuemsutils/helpers.py</code> <pre><code>class CuemsDict(dict):\n    \"\"\"Custom dictionary class to handle cuemsutils specific items.\"\"\"\n\n    def build(self, parent: Element):\n        build_xml_dict(self, parent)\n\n    def setter(self, settings: dict):\n        \"\"\"Set the object properties from a dictionary.\n\n        Args:\n            settings (dict): Dictionary containing property values to set.\n\n        Raises:\n            AttributeError: If settings is not a dictionary.\n        \"\"\"\n        if not isinstance(settings, dict):\n            raise AttributeError(f\"Invalid type {type(settings)}. Expected dict.\")\n        for k, v in settings.items():\n            try:\n                x = getattr(self, f\"set_{k}\")\n                x(v)\n            except AttributeError:\n                pass\n</code></pre>"},{"location":"api/#cuemsutils.helpers.CuemsDict.setter","title":"<code>setter(settings)</code>","text":"<p>Set the object properties from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>dict</code> <p>Dictionary containing property values to set.</p> required <p>Raises:</p> Type Description <code>AttributeError</code> <p>If settings is not a dictionary.</p> Source code in <code>src/cuemsutils/helpers.py</code> <pre><code>def setter(self, settings: dict):\n    \"\"\"Set the object properties from a dictionary.\n\n    Args:\n        settings (dict): Dictionary containing property values to set.\n\n    Raises:\n        AttributeError: If settings is not a dictionary.\n    \"\"\"\n    if not isinstance(settings, dict):\n        raise AttributeError(f\"Invalid type {type(settings)}. Expected dict.\")\n    for k, v in settings.items():\n        try:\n            x = getattr(self, f\"set_{k}\")\n            x(v)\n        except AttributeError:\n            pass\n</code></pre>"},{"location":"api/#cuemsutils.helpers.build_xml_dict","title":"<code>build_xml_dict(x, parent)</code>","text":"<p>Build an xml element from a dictionary</p> Source code in <code>src/cuemsutils/helpers.py</code> <pre><code>def build_xml_dict(x, parent: Element) -&gt; None:\n    \"\"\"Build an xml element from a dictionary\"\"\"\n    if not isinstance(x, dict):\n        raise AttributeError(f\"Invalid type {type(x)}. Expected dict.\")\n    if not isinstance(parent, Element):\n        raise AttributeError(f\"Invalid type {type(parent)}. Expected ElementTree.\")\n    for k, v in x.items():\n        if isinstance(v, list):\n            for item in v:\n                if hasattr(item, 'build'):\n                    item.build(parent)\n                else:\n                    SubElement(parent, k).text = str(item)\n        elif hasattr(v, 'build'):\n            s = SubElement(parent, k)\n            v.build(s)\n        else:\n            SubElement(parent, k).text = str(v)\n</code></pre>"},{"location":"api/#cuemsutils.helpers.check_path","title":"<code>check_path(x, dir_only=False)</code>","text":"<p>Check if a path is valid. Raise an error if not.</p> Source code in <code>src/cuemsutils/helpers.py</code> <pre><code>def check_path(x: str, dir_only: bool = False) -&gt; bool:\n    \"\"\"Check if a path is valid. Raise an error if not.\"\"\"\n    x = path.realpath(x)\n    if dir_only:\n        dir_ok = _check_dir(path.dirname(x))\n        return dir_ok\n    if not path.exists(x):\n        raise FileNotFoundError(f\"Path {x} does not exist\")\n    if not _readable(x) or not _writable(x):\n        raise PermissionError(f\"Path {x} is not readable or writable\")\n    return True\n</code></pre>"},{"location":"api/#cuemsutils.helpers.ensure_items","title":"<code>ensure_items(x, requiered)</code>","text":"<p>Ensure that all the items are present in a dictionary</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>dict</code> <p>The dictionary to check</p> required <code>requiered</code> <code>dict</code> <p>The items (key-value pairs) to check for</p> required Source code in <code>src/cuemsutils/helpers.py</code> <pre><code>def ensure_items(x: dict, requiered: dict) -&gt; dict:\n    \"\"\"Ensure that all the items are present in a dictionary\n\n    Args:\n        x (dict): The dictionary to check\n        requiered (dict): The items (key-value pairs) to check for\n\n    \"\"\"\n    for k,v in requiered.items():\n        if k not in x.keys():\n            if v == None:\n                x[k] = None\n            elif callable(v):\n                x[k] = v()\n            else:\n                x[k] = v\n\n    ## Order the dictionary\n    x = {k: x[k] for k in sorted(x.keys())}\n\n    return x\n</code></pre>"},{"location":"api/#cuemsutils.helpers.extract_items","title":"<code>extract_items(x, keys)</code>","text":"<p>Extract list of keys and values from a dictionary</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>items</code> <p>The dictionary items to extract from</p> required <code>keys</code> <code>list</code> <p>The keys to extract</p> required Source code in <code>src/cuemsutils/helpers.py</code> <pre><code>def extract_items(x, keys: list[str] | KeysView[str]) -&gt; ItemsView[str, Any]:\n    \"\"\"Extract list of keys and values from a dictionary\n\n    Args:\n        x (items): The dictionary items to extract from\n        keys (list): The keys to extract\n    \"\"\"\n    d = dict(x)\n    return {k: d[k] for k in keys}.items()\n</code></pre>"},{"location":"api/#cuemsutils.helpers.mkdir_recursive","title":"<code>mkdir_recursive(folder)</code>","text":"<p>Creates a directory recursively.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>The folder to be created.</p> required Source code in <code>src/cuemsutils/helpers.py</code> <pre><code>def mkdir_recursive(folder: str) -&gt; None:\n    \"\"\"\n    Creates a directory recursively.\n\n    Args:\n        folder (str): The folder to be created.\n    \"\"\"\n    if path.exists(folder):\n        return\n    if not path.exists(path.dirname(folder)):\n        mkdir_recursive(path.dirname(folder))\n    mkdir(folder)\n</code></pre>"},{"location":"api/#cuemsutils.helpers.new_datetime","title":"<code>new_datetime()</code>","text":"<p>Generate a new datetime string.</p> Source code in <code>src/cuemsutils/helpers.py</code> <pre><code>def new_datetime():\n    \"\"\"Generate a new datetime string.\"\"\"\n    return datetime.now().strftime(DATETIME_FORMAT)\n</code></pre>"},{"location":"api/#cuemsutils.helpers.new_uuid","title":"<code>new_uuid()</code>","text":"<p>Generate a new Uuid class instance.</p> Source code in <code>src/cuemsutils/helpers.py</code> <pre><code>def new_uuid():\n    \"\"\"Generate a new Uuid class instance.\"\"\"\n    return Uuid()\n</code></pre>"},{"location":"api/#cuemsutils.helpers.strtobool","title":"<code>strtobool(val)</code>","text":"<p>Convert a string value representation of truth to true (1) or false (0).</p> <p>True values are y, yes, t, true, on and 1. False values are n, no, f, false, off and 0. Raises ValueError if val is anything else.</p> Source code in <code>src/cuemsutils/helpers.py</code> <pre><code>def strtobool(val: str) -&gt; bool:\n    \"\"\"Convert a string value representation of truth to true (1) or false (0).\n\n        True values are y, yes, t, true, on and 1.\n        False values are n, no, f, false, off and 0.\n        Raises ValueError if val is anything else.\n    \"\"\" \n    if val.lower() in ['y', 'yes', 't', 'true', 'on', '1']:\n        return True\n    elif val.lower() in ['n', 'no', 'f', 'false', 'off', '0']:\n        return False\n    else:\n        raise ValueError(f'Invalid truth value {val}')\n</code></pre>"},{"location":"api/#cuemsutils.helpers.unique_values_to_list","title":"<code>unique_values_to_list(x)</code>","text":"<p>Convert a dictionary to a sorted list of its unique values.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>dict</code> <p>The dictionary to convert</p> required Source code in <code>src/cuemsutils/helpers.py</code> <pre><code>def unique_values_to_list(x: dict) -&gt; list:\n    \"\"\"Convert a dictionary to a sorted list of its unique values.\n\n    Args:\n        x (dict): The dictionary to convert\n    \"\"\"\n    return sorted(list(set(x.values())))\n</code></pre>"},{"location":"api/#cuemsutils.log.CuemsLoggerAdapter","title":"<code>CuemsLoggerAdapter</code>","text":"<p>               Bases: <code>LoggerAdapter</code></p> <p>Custom LoggerAdapter that properly merges extra dictionaries.</p> Source code in <code>src/cuemsutils/log.py</code> <pre><code>class CuemsLoggerAdapter(LoggerAdapter):\n    \"\"\"Custom LoggerAdapter that properly merges extra dictionaries.\"\"\"\n\n    def process(self, msg, kwargs):\n        \"\"\"\n        Process the logging call to merge extra dictionaries.\n        Ensures that both adapter-level and call-level extra dicts are merged.\n        \"\"\"\n        # Start with a copy of the adapter's extra dict (with default caller='')\n        extra = {'caller': ''}\n        extra.update(self.extra)\n\n        # Merge in any extra dict from the logging call\n        if 'extra' in kwargs:\n            extra.update(kwargs['extra'])\n\n        kwargs['extra'] = extra\n        return msg, kwargs\n</code></pre>"},{"location":"api/#cuemsutils.log.CuemsLoggerAdapter.process","title":"<code>process(msg, kwargs)</code>","text":"<p>Process the logging call to merge extra dictionaries. Ensures that both adapter-level and call-level extra dicts are merged.</p> Source code in <code>src/cuemsutils/log.py</code> <pre><code>def process(self, msg, kwargs):\n    \"\"\"\n    Process the logging call to merge extra dictionaries.\n    Ensures that both adapter-level and call-level extra dicts are merged.\n    \"\"\"\n    # Start with a copy of the adapter's extra dict (with default caller='')\n    extra = {'caller': ''}\n    extra.update(self.extra)\n\n    # Merge in any extra dict from the logging call\n    if 'extra' in kwargs:\n        extra.update(kwargs['extra'])\n\n    kwargs['extra'] = extra\n    return msg, kwargs\n</code></pre>"},{"location":"api/#cuemsutils.log.Logger","title":"<code>Logger</code>","text":"<p>A class for logging messages with different log levels.</p> <p>This class provides static methods for logging messages with different log levels. It dynamically detects the calling module to use the appropriate logger.</p> Source code in <code>src/cuemsutils/log.py</code> <pre><code>class Logger:\n    \"\"\"\n    A class for logging messages with different log levels.\n\n    This class provides static methods for logging messages with different log levels.\n    It dynamically detects the calling module to use the appropriate logger.\n    \"\"\"\n\n    @staticmethod\n    def _get_caller_module():\n        \"\"\"\n        Get the module name of the caller by inspecting the call stack.\n        \"\"\"\n        frame = inspect.currentframe()\n        try:\n            # Go up the stack: _get_caller_module -&gt; log/debug/info/etc -&gt; actual caller\n            caller_frame = frame.f_back.f_back.f_back\n            module_name = caller_frame.f_globals.get('__name__', __name__)\n            return module_name\n        finally:\n            del frame\n\n    @staticmethod\n    def log(level, message, **kwargs):\n        module_name = Logger._get_caller_module()\n        logger = main_logger(module_name=module_name)\n        logger.log(level, message, stacklevel = 4, **kwargs)\n\n    @staticmethod\n    def debug(message, **kwargs):\n        Logger.log(DEBUG, message, **kwargs)\n\n    @staticmethod\n    def info(message, **kwargs):\n        Logger.log(INFO, message, **kwargs)\n\n    @staticmethod\n    def error(message, **kwargs):\n        Logger.log(ERROR, message, **kwargs)\n\n    @staticmethod\n    def exception(message, **kwargs):\n        Logger.log(ERROR, message, **kwargs)\n\n    @staticmethod\n    def warning(message, **kwargs):\n        Logger.log(WARNING, message, **kwargs)\n\n    @staticmethod\n    def critical(message, **kwargs):\n        Logger.log(CRITICAL, message, **kwargs)\n</code></pre>"},{"location":"api/#cuemsutils.log.log_level_to_obj","title":"<code>log_level_to_obj(log_level)</code>","text":"<p>Convert a log level string to a logging level object.</p> Source code in <code>src/cuemsutils/log.py</code> <pre><code>def log_level_to_obj(log_level):\n    \"\"\"\n    Convert a log level string to a logging level object.\n    \"\"\"\n    return {\n        'DEBUG': DEBUG,\n        'INFO': INFO,\n        'WARNING': WARNING,\n        'ERROR': ERROR,\n        'CRITICAL': CRITICAL\n    }[log_level]\n</code></pre>"},{"location":"api/#cuemsutils.log.logged","title":"<code>logged(func)</code>","text":"<p>A decorator function to log information about function calls and their results.</p> Source code in <code>src/cuemsutils/log.py</code> <pre><code>def logged(func):\n    \"\"\"\n    A decorator function to log information about function calls and their results.\n    \"\"\"\n    # Get logger for the function's module\n    func_logger = main_logger(module_name=func.__module__)\n\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        \"\"\"\n        The wrapper function that logs function calls and their results.\n        \"\"\"\n        # Only set caller field (the decorated function name)\n        # funcName is automatically set by logging to the actual calling function (wrapper)\n        d = {\"caller\": func.__name__}\n        func_logger.debug(f\"Call recieved\", extra = d)\n        func_logger.debug(f\"Using args: {args} and kwargs: {kwargs}\", extra = d)\n        try:\n            result = func(*args, **kwargs)\n            func_logger.debug(f\"Finished with result: {result}\", extra = d)\n        except Warning as w:\n            func_logger.warning(f\"Warning occurred: {w}\", extra = d)\n            return result\n        except Exception as e:\n            func_logger.error(f\"Error occurred: {e}\", extra = d)\n            raise\n\n        else:\n            return result\n\n    return wrapper\n</code></pre>"},{"location":"api/#cuemsutils.log.main_logger","title":"<code>main_logger(module_name=None, with_syslog=True, with_stdout=True)</code>","text":"<p>Create a root logger with a custom formatter.</p> <p>Parameters:</p> Name Type Description Default <code>module_name</code> <p>Name of the module to create logger for. Defaults to name if None.</p> <code>None</code> <code>with_syslog</code> <p>Whether to add syslog handler.</p> <code>True</code> <code>with_stdout</code> <p>Whether to add stdout handler.</p> <code>True</code> Source code in <code>src/cuemsutils/log.py</code> <pre><code>def main_logger(module_name = None, with_syslog = True, with_stdout = True):\n    \"\"\"\n    Create a root logger with a custom formatter.\n\n    Args:\n        module_name: Name of the module to create logger for. Defaults to __name__ if None.\n        with_syslog: Whether to add syslog handler.\n        with_stdout: Whether to add stdout handler.\n    \"\"\"\n    if module_name is None:\n        module_name = __name__\n\n    # Return cached logger if it exists\n    if module_name in _logger_cache:\n        return _logger_cache[module_name]\n\n    logger = getLogger(module_name)\n    try:\n        log_level = log_level_to_obj(environ['CUEMS_LOG_LEVEL'].upper())\n    except KeyError:\n        log_level = DEBUG\n    logger.setLevel(log_level)\n\n    if with_stdout:\n        sh = StreamHandler(sys.stdout)\n        sh.setFormatter(cuemsFormatter)\n        logger.addHandler(sh)\n\n    if with_syslog:\n        syslog_handler = SysLogHandler(\n            address = '/dev/log', facility = 'local0'\n        )\n        syslog_handler.setFormatter(cuemsFormatter)\n        logger.addHandler(syslog_handler)\n\n    logger_adapter = CuemsLoggerAdapter(logger, {})\n    _logger_cache[module_name] = logger_adapter\n    return logger_adapter\n</code></pre>"},{"location":"api/#cuemsutils.timeoutloop.Timeoutloop","title":"<code>Timeoutloop</code>","text":"<p>universal for time-out loop</p> Source code in <code>src/cuemsutils/timeoutloop.py</code> <pre><code>class Timeoutloop():\n    \"\"\" universal for time-out loop \"\"\"\n    def __init__(self, timeout, interval=None):\n        self.timeout = timeout\n        self.delay = interval\n    def __iter__(self):\n        self.start_time = time()\n        return self\n    def __next__(self):\n        if self.delay is not None:\n            sleep(self.delay)\n        now = time()\n        time_passed = now - self.start_time\n        if time_passed &gt; self.timeout: \n            raise TimeoutError(f\"Timeout after {self.timeout} seconds\")\n        else:\n            return time_passed\n</code></pre>"},{"location":"cues/","title":"Cues","text":""},{"location":"cues/#cuemsutils.cues.ActionCue.ActionCue","title":"<code>ActionCue</code>","text":"<p>               Bases: <code>Cue</code></p> <p>A cue that represents an action to be performed on a target object.</p> <p>This cue is used to trigger actions on other objects in the system, such as playing, pausing, or stopping media cues.</p> Source code in <code>src/cuemsutils/cues/ActionCue.py</code> <pre><code>class ActionCue(Cue):\n    \"\"\"A cue that represents an action to be performed on a target object.\n\n    This cue is used to trigger actions on other objects in the system, such as\n    playing, pausing, or stopping media cues.\n    \"\"\"\n\n    def __init__(self, init_dict: dict = None):\n        \"\"\"Initialize an ActionCue.\n\n        Args:\n            init_dict (dict, optional): Dictionary containing initialization values.\n                If not provided, default values from REQ_ITEMS will be used.\n        \"\"\"\n        if init_dict:\n            init_dict = ensure_items(init_dict, REQ_ITEMS)\n        else:\n            init_dict = REQ_ITEMS\n        super().__init__(init_dict)\n\n        self._action_target_object = None\n\n    def get_action_target(self):\n        \"\"\"Get the target object for the action.\n\n        Returns:\n            The target object identifier.\n        \"\"\"\n        return super().__getitem__('action_target')\n\n    def set_action_target(self, action_target: str) -&gt; None:\n        \"\"\"Set the target object for the action.\n\n        Args:\n            action_target: The target object identifier.\n        \"\"\"\n        super().__setitem__('action_target', action_target)\n\n    action_target = property(get_action_target, set_action_target)\n\n    def get_action_type(self) -&gt; str:\n        \"\"\"Get the type of action to perform.\n\n        Returns:\n            str: The action type (e.g., 'play', 'pause', 'stop').\n        \"\"\"\n        return super().__getitem__('action_type')\n\n    def set_action_type(self, action_type: str) -&gt; None:\n        \"\"\"Set the type of action to perform.\n\n        Args:\n            action_type (str): The action type (e.g., 'play', 'pause', 'stop').\n        \"\"\"\n        super().__setitem__('action_type', action_type)\n\n    action_type = property(get_action_type, set_action_type)\n\n    def items(self):\n        \"\"\"Get all items in the cue as a dictionary.\n\n        Returns:\n            dict_items: A view of the cue's items, with required items sorted first.\n        \"\"\"\n        x = dict(super().items())\n        for k in sorted(REQ_ITEMS.keys()):\n            x[k] = self[k]\n        return x.items()\n</code></pre>"},{"location":"cues/#cuemsutils.cues.ActionCue.ActionCue.__init__","title":"<code>__init__(init_dict=None)</code>","text":"<p>Initialize an ActionCue.</p> <p>Parameters:</p> Name Type Description Default <code>init_dict</code> <code>dict</code> <p>Dictionary containing initialization values. If not provided, default values from REQ_ITEMS will be used.</p> <code>None</code> Source code in <code>src/cuemsutils/cues/ActionCue.py</code> <pre><code>def __init__(self, init_dict: dict = None):\n    \"\"\"Initialize an ActionCue.\n\n    Args:\n        init_dict (dict, optional): Dictionary containing initialization values.\n            If not provided, default values from REQ_ITEMS will be used.\n    \"\"\"\n    if init_dict:\n        init_dict = ensure_items(init_dict, REQ_ITEMS)\n    else:\n        init_dict = REQ_ITEMS\n    super().__init__(init_dict)\n\n    self._action_target_object = None\n</code></pre>"},{"location":"cues/#cuemsutils.cues.ActionCue.ActionCue.get_action_target","title":"<code>get_action_target()</code>","text":"<p>Get the target object for the action.</p> <p>Returns:</p> Type Description <p>The target object identifier.</p> Source code in <code>src/cuemsutils/cues/ActionCue.py</code> <pre><code>def get_action_target(self):\n    \"\"\"Get the target object for the action.\n\n    Returns:\n        The target object identifier.\n    \"\"\"\n    return super().__getitem__('action_target')\n</code></pre>"},{"location":"cues/#cuemsutils.cues.ActionCue.ActionCue.get_action_type","title":"<code>get_action_type()</code>","text":"<p>Get the type of action to perform.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The action type (e.g., 'play', 'pause', 'stop').</p> Source code in <code>src/cuemsutils/cues/ActionCue.py</code> <pre><code>def get_action_type(self) -&gt; str:\n    \"\"\"Get the type of action to perform.\n\n    Returns:\n        str: The action type (e.g., 'play', 'pause', 'stop').\n    \"\"\"\n    return super().__getitem__('action_type')\n</code></pre>"},{"location":"cues/#cuemsutils.cues.ActionCue.ActionCue.items","title":"<code>items()</code>","text":"<p>Get all items in the cue as a dictionary.</p> <p>Returns:</p> Name Type Description <code>dict_items</code> <p>A view of the cue's items, with required items sorted first.</p> Source code in <code>src/cuemsutils/cues/ActionCue.py</code> <pre><code>def items(self):\n    \"\"\"Get all items in the cue as a dictionary.\n\n    Returns:\n        dict_items: A view of the cue's items, with required items sorted first.\n    \"\"\"\n    x = dict(super().items())\n    for k in sorted(REQ_ITEMS.keys()):\n        x[k] = self[k]\n    return x.items()\n</code></pre>"},{"location":"cues/#cuemsutils.cues.ActionCue.ActionCue.set_action_target","title":"<code>set_action_target(action_target)</code>","text":"<p>Set the target object for the action.</p> <p>Parameters:</p> Name Type Description Default <code>action_target</code> <code>str</code> <p>The target object identifier.</p> required Source code in <code>src/cuemsutils/cues/ActionCue.py</code> <pre><code>def set_action_target(self, action_target: str) -&gt; None:\n    \"\"\"Set the target object for the action.\n\n    Args:\n        action_target: The target object identifier.\n    \"\"\"\n    super().__setitem__('action_target', action_target)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.ActionCue.ActionCue.set_action_type","title":"<code>set_action_type(action_type)</code>","text":"<p>Set the type of action to perform.</p> <p>Parameters:</p> Name Type Description Default <code>action_type</code> <code>str</code> <p>The action type (e.g., 'play', 'pause', 'stop').</p> required Source code in <code>src/cuemsutils/cues/ActionCue.py</code> <pre><code>def set_action_type(self, action_type: str) -&gt; None:\n    \"\"\"Set the type of action to perform.\n\n    Args:\n        action_type (str): The action type (e.g., 'play', 'pause', 'stop').\n    \"\"\"\n    super().__setitem__('action_type', action_type)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.AudioCue.AudioCue","title":"<code>AudioCue</code>","text":"<p>               Bases: <code>MediaCue</code></p> <p>A cue for handling audio playback and control.</p> <p>This class extends MediaCue to provide specific functionality for audio playback, including volume control and OSC communication for audio routing.</p> Source code in <code>src/cuemsutils/cues/AudioCue.py</code> <pre><code>class AudioCue(MediaCue):\n    \"\"\"A cue for handling audio playback and control.\n\n    This class extends MediaCue to provide specific functionality for audio playback,\n    including volume control and OSC communication for audio routing.\n    \"\"\"\n\n    def __init__(self, init_dict = None):\n        \"\"\"Initialize an AudioCue.\n\n        Args:\n            init_dict (dict, optional): Dictionary containing initialization values.\n                If provided, will be used to set initial properties.\n        \"\"\"\n        if not init_dict:\n            init_dict = REQ_ITEMS\n        else:\n            init_dict = ensure_items(init_dict, REQ_ITEMS)\n        super().__init__(init_dict)\n\n        self._player = None\n        self._osc_route = None\n\n    def get_master_vol(self):\n        \"\"\"Get the master volume level.\n\n        Returns:\n            float: The master volume level.\n        \"\"\"\n        return super().__getitem__('master_vol')\n\n    def set_master_vol(self, master_vol):\n        \"\"\"Set the master volume level.\n\n        Args:\n            master_vol (float): The new master volume level.\n        \"\"\"\n        super().__setitem__('master_vol', master_vol)\n\n    master_vol = property(get_master_vol, set_master_vol)\n\n    def items(self):\n        \"\"\"Get all items in the cue as a dictionary.\n\n        Returns:\n            dict_items: A view of the cue's items, with required items sorted first.\n        \"\"\"\n        x = dict(super().items())\n        for k in sorted(REQ_ITEMS.keys()):\n            x[k] = self[k]\n        return x.items()\n\n    def player(self, player):\n        \"\"\"Set the audio player instance.\n\n        Args:\n            player: The audio player instance to use.\n        \"\"\"\n        self._player = player\n\n    def osc_route(self, osc_route):\n        \"\"\"Set the OSC route for audio control.\n\n        Args:\n            osc_route (str): The OSC route to use for audio control.\n        \"\"\"\n        self._osc_route = osc_route\n\n    @deprecated(\n        reason=\"Use loop_cue from CueHandler instead\",\n        version=\"0.0.9rc5\"\n    )\n    @logged\n    def audio_media_loop(self, ossia, mtc):\n        \"\"\"Handle the audio media playback loop.\n\n        This method manages the playback loop for audio media, including handling\n        looping behavior and OSC communication for timing control.\n\n        Args:\n            ossia: The OSC communication interface.\n            mtc: The MIDI Time Code interface.\n        \"\"\"\n        try:\n            loop_counter = 0\n            duration = self.media.regions[0].out_time - self.media.regions[0].in_time\n\n            while not self.media.regions[0].loop or loop_counter &lt; self.media.regions[0].loop:\n                while self._player.is_alive() and (mtc.main_tc.milliseconds &lt; self._end_mtc.milliseconds):\n                    sleep(0.005)\n\n                if self._local:\n                    # Recalculate offset and apply\n                    self._end_mtc = self._start_mtc + (duration)\n                    offset_to_go = float(-(self._start_mtc.milliseconds) + self.media.regions[0].in_time.milliseconds)\n                    try:\n                        key = f'{self._osc_route}/offset'\n                        ossia.send_message(key, offset_to_go)\n                    except KeyError:\n                        Logger.debug(\n                            f'Key error 3 in go_callback {key}',\n                            extra = {\"caller\": self.__class__.__name__}\n                        )\n\n                loop_counter += 1\n\n            if self._local:                \n                try:\n                    key = f'{self._osc_route}/mtcfollow'\n                    ossia.send_message(key, 0)\n                except KeyError:\n                    Logger.debug(\n                        f'Key error 4 in go_callback {key}',\n                        extra = {\"caller\": self.__class__.__name__}\n                    )\n\n        except AttributeError:\n            pass\n\n    def stop(self):\n        \"\"\"Stop the audio playback.\n\n        This method stops the audio player and sets the stop request flag.\n        \"\"\"\n        self._stop_requested = True\n        if self._player and self._player.is_alive():\n            self._player.kill()\n\n    def check_mappings(self, settings):\n        \"\"\"Check if the audio output mappings are valid.\n\n        Args:\n            settings: The settings containing project node mappings.\n\n        Returns:\n            bool: True if the mappings are valid, False otherwise.\n        \"\"\"\n        return super().check_mappings()\n\n        if not settings.project_node_mappings:\n            return True\n\n        found = True\n        map_list = ['default']\n\n        Logger.debug(f'AudioCue check_mappings: {settings.project_node_mappings}')\n        if settings.project_node_mappings['audio'][0]['outputs']:\n            for elem in settings.project_node_mappings['audio'][0]['outputs']:\n                Logger.debug(f'AudioCue elem: {elem}')\n                elem = elem['output']\n                for map in elem['mappings']:\n                    Logger.debug(f'AudioCue map: {map}')\n                    map_list.append(map['mapped_to'])\n\n        for output in self.outputs:\n            if output['output_name'][:36] == settings.node_conf['uuid']:\n                    self._local = True\n                    if output['output_name'][37:] not in map_list:\n                        found = False\n                        break\n            else:\n                self._local = False\n                found = True\n\n        return found\n</code></pre>"},{"location":"cues/#cuemsutils.cues.AudioCue.AudioCue.__init__","title":"<code>__init__(init_dict=None)</code>","text":"<p>Initialize an AudioCue.</p> <p>Parameters:</p> Name Type Description Default <code>init_dict</code> <code>dict</code> <p>Dictionary containing initialization values. If provided, will be used to set initial properties.</p> <code>None</code> Source code in <code>src/cuemsutils/cues/AudioCue.py</code> <pre><code>def __init__(self, init_dict = None):\n    \"\"\"Initialize an AudioCue.\n\n    Args:\n        init_dict (dict, optional): Dictionary containing initialization values.\n            If provided, will be used to set initial properties.\n    \"\"\"\n    if not init_dict:\n        init_dict = REQ_ITEMS\n    else:\n        init_dict = ensure_items(init_dict, REQ_ITEMS)\n    super().__init__(init_dict)\n\n    self._player = None\n    self._osc_route = None\n</code></pre>"},{"location":"cues/#cuemsutils.cues.AudioCue.AudioCue.audio_media_loop","title":"<code>audio_media_loop(ossia, mtc)</code>","text":"<p>Handle the audio media playback loop.</p> <p>This method manages the playback loop for audio media, including handling looping behavior and OSC communication for timing control.</p> <p>Parameters:</p> Name Type Description Default <code>ossia</code> <p>The OSC communication interface.</p> required <code>mtc</code> <p>The MIDI Time Code interface.</p> required Source code in <code>src/cuemsutils/cues/AudioCue.py</code> <pre><code>@deprecated(\n    reason=\"Use loop_cue from CueHandler instead\",\n    version=\"0.0.9rc5\"\n)\n@logged\ndef audio_media_loop(self, ossia, mtc):\n    \"\"\"Handle the audio media playback loop.\n\n    This method manages the playback loop for audio media, including handling\n    looping behavior and OSC communication for timing control.\n\n    Args:\n        ossia: The OSC communication interface.\n        mtc: The MIDI Time Code interface.\n    \"\"\"\n    try:\n        loop_counter = 0\n        duration = self.media.regions[0].out_time - self.media.regions[0].in_time\n\n        while not self.media.regions[0].loop or loop_counter &lt; self.media.regions[0].loop:\n            while self._player.is_alive() and (mtc.main_tc.milliseconds &lt; self._end_mtc.milliseconds):\n                sleep(0.005)\n\n            if self._local:\n                # Recalculate offset and apply\n                self._end_mtc = self._start_mtc + (duration)\n                offset_to_go = float(-(self._start_mtc.milliseconds) + self.media.regions[0].in_time.milliseconds)\n                try:\n                    key = f'{self._osc_route}/offset'\n                    ossia.send_message(key, offset_to_go)\n                except KeyError:\n                    Logger.debug(\n                        f'Key error 3 in go_callback {key}',\n                        extra = {\"caller\": self.__class__.__name__}\n                    )\n\n            loop_counter += 1\n\n        if self._local:                \n            try:\n                key = f'{self._osc_route}/mtcfollow'\n                ossia.send_message(key, 0)\n            except KeyError:\n                Logger.debug(\n                    f'Key error 4 in go_callback {key}',\n                    extra = {\"caller\": self.__class__.__name__}\n                )\n\n    except AttributeError:\n        pass\n</code></pre>"},{"location":"cues/#cuemsutils.cues.AudioCue.AudioCue.check_mappings","title":"<code>check_mappings(settings)</code>","text":"<p>Check if the audio output mappings are valid.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <p>The settings containing project node mappings.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if the mappings are valid, False otherwise.</p> Source code in <code>src/cuemsutils/cues/AudioCue.py</code> <pre><code>def check_mappings(self, settings):\n    \"\"\"Check if the audio output mappings are valid.\n\n    Args:\n        settings: The settings containing project node mappings.\n\n    Returns:\n        bool: True if the mappings are valid, False otherwise.\n    \"\"\"\n    return super().check_mappings()\n\n    if not settings.project_node_mappings:\n        return True\n\n    found = True\n    map_list = ['default']\n\n    Logger.debug(f'AudioCue check_mappings: {settings.project_node_mappings}')\n    if settings.project_node_mappings['audio'][0]['outputs']:\n        for elem in settings.project_node_mappings['audio'][0]['outputs']:\n            Logger.debug(f'AudioCue elem: {elem}')\n            elem = elem['output']\n            for map in elem['mappings']:\n                Logger.debug(f'AudioCue map: {map}')\n                map_list.append(map['mapped_to'])\n\n    for output in self.outputs:\n        if output['output_name'][:36] == settings.node_conf['uuid']:\n                self._local = True\n                if output['output_name'][37:] not in map_list:\n                    found = False\n                    break\n        else:\n            self._local = False\n            found = True\n\n    return found\n</code></pre>"},{"location":"cues/#cuemsutils.cues.AudioCue.AudioCue.get_master_vol","title":"<code>get_master_vol()</code>","text":"<p>Get the master volume level.</p> <p>Returns:</p> Name Type Description <code>float</code> <p>The master volume level.</p> Source code in <code>src/cuemsutils/cues/AudioCue.py</code> <pre><code>def get_master_vol(self):\n    \"\"\"Get the master volume level.\n\n    Returns:\n        float: The master volume level.\n    \"\"\"\n    return super().__getitem__('master_vol')\n</code></pre>"},{"location":"cues/#cuemsutils.cues.AudioCue.AudioCue.items","title":"<code>items()</code>","text":"<p>Get all items in the cue as a dictionary.</p> <p>Returns:</p> Name Type Description <code>dict_items</code> <p>A view of the cue's items, with required items sorted first.</p> Source code in <code>src/cuemsutils/cues/AudioCue.py</code> <pre><code>def items(self):\n    \"\"\"Get all items in the cue as a dictionary.\n\n    Returns:\n        dict_items: A view of the cue's items, with required items sorted first.\n    \"\"\"\n    x = dict(super().items())\n    for k in sorted(REQ_ITEMS.keys()):\n        x[k] = self[k]\n    return x.items()\n</code></pre>"},{"location":"cues/#cuemsutils.cues.AudioCue.AudioCue.osc_route","title":"<code>osc_route(osc_route)</code>","text":"<p>Set the OSC route for audio control.</p> <p>Parameters:</p> Name Type Description Default <code>osc_route</code> <code>str</code> <p>The OSC route to use for audio control.</p> required Source code in <code>src/cuemsutils/cues/AudioCue.py</code> <pre><code>def osc_route(self, osc_route):\n    \"\"\"Set the OSC route for audio control.\n\n    Args:\n        osc_route (str): The OSC route to use for audio control.\n    \"\"\"\n    self._osc_route = osc_route\n</code></pre>"},{"location":"cues/#cuemsutils.cues.AudioCue.AudioCue.player","title":"<code>player(player)</code>","text":"<p>Set the audio player instance.</p> <p>Parameters:</p> Name Type Description Default <code>player</code> <p>The audio player instance to use.</p> required Source code in <code>src/cuemsutils/cues/AudioCue.py</code> <pre><code>def player(self, player):\n    \"\"\"Set the audio player instance.\n\n    Args:\n        player: The audio player instance to use.\n    \"\"\"\n    self._player = player\n</code></pre>"},{"location":"cues/#cuemsutils.cues.AudioCue.AudioCue.set_master_vol","title":"<code>set_master_vol(master_vol)</code>","text":"<p>Set the master volume level.</p> <p>Parameters:</p> Name Type Description Default <code>master_vol</code> <code>float</code> <p>The new master volume level.</p> required Source code in <code>src/cuemsutils/cues/AudioCue.py</code> <pre><code>def set_master_vol(self, master_vol):\n    \"\"\"Set the master volume level.\n\n    Args:\n        master_vol (float): The new master volume level.\n    \"\"\"\n    super().__setitem__('master_vol', master_vol)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.AudioCue.AudioCue.stop","title":"<code>stop()</code>","text":"<p>Stop the audio playback.</p> <p>This method stops the audio player and sets the stop request flag.</p> Source code in <code>src/cuemsutils/cues/AudioCue.py</code> <pre><code>def stop(self):\n    \"\"\"Stop the audio playback.\n\n    This method stops the audio player and sets the stop request flag.\n    \"\"\"\n    self._stop_requested = True\n    if self._player and self._player.is_alive():\n        self._player.kill()\n</code></pre>"},{"location":"cues/#cuemsutils.cues.Cue.Cue","title":"<code>Cue</code>","text":"<p>               Bases: <code>CuemsDict</code></p> <p>Base class for all cue types in the system.</p> <p>A cue represents a single action or event that can be triggered in the system. It contains properties like timing, target, and behavior settings.</p> Source code in <code>src/cuemsutils/cues/Cue.py</code> <pre><code>class Cue(CuemsDict):\n    \"\"\"Base class for all cue types in the system.\n\n    A cue represents a single action or event that can be triggered in the system.\n    It contains properties like timing, target, and behavior settings.\n    \"\"\"\n\n    def __init__(self, init_dict = None):\n        \"\"\"Initialize a new Cue.\n\n        Args:\n            init_dict (dict, optional): Dictionary containing initialization values.\n                If provided, will be used to set initial properties.\n        \"\"\"\n        if init_dict:\n            init_dict = ensure_items(init_dict, REQ_ITEMS)\n            self.setter(init_dict)\n\n        self._target_object = None\n        self._conf = None\n        self._armed_list = None\n        self._start_mtc = CTimecode()\n        self._end_mtc = CTimecode()\n        self._end_reached = False\n        self._go_thread = None\n        self._stop_requested = False\n        self._local = False\n\n    def get_id(self):\n        \"\"\"Get the unique identifier of the cue.\n\n        Returns:\n            Uuid: The cue's unique identifier.\n        \"\"\"\n        return super().__getitem__('id')\n\n    def set_id(self, id):\n        \"\"\"Set the unique identifier of the cue.\n\n        Args:\n            id: The new unique identifier.\n        \"\"\"\n        id = Uuid(id)\n        super().__setitem__('id', id)\n\n    id = property(get_id, set_id)\n\n    def get_name(self):\n        \"\"\"Get the name of the cue.\n\n        Returns:\n            str: The cue's name.\n        \"\"\"\n        return super().__getitem__('name')\n\n    def set_name(self, name):\n        \"\"\"Set the name of the cue.\n\n        Args:\n            name (str): The new name for the cue.\n        \"\"\"\n        super().__setitem__('name', name)\n\n    name = property(get_name, set_name)\n\n    def get_description(self):\n        \"\"\"Get the description of the cue.\n\n        Returns:\n            str: The cue's description.\n        \"\"\"\n        return super().__getitem__('description')\n\n    def set_description(self, description):\n        \"\"\"Set the description of the cue.\n\n        Args:\n            description (str): The new description for the cue.\n        \"\"\"\n        super().__setitem__('description', description)\n\n    description = property(get_description, set_description)\n\n    def get_enabled(self):\n        \"\"\"Get whether the cue is enabled.\n\n        Returns:\n            bool: True if the cue is enabled, False otherwise.\n        \"\"\"\n        return super().__getitem__('enabled')\n\n    def set_enabled(self, enabled):\n        \"\"\"Set whether the cue is enabled.\n\n        Args:\n            enabled (bool): True to enable the cue, False to disable it.\n        \"\"\"\n        super().__setitem__('enabled', enabled)\n\n    enabled = property(get_enabled, set_enabled)\n\n    def get_autoload(self):\n        \"\"\"Get whether the cue should be autoloaded.\n\n        Returns:\n            bool: True if the cue should be autoloaded, False otherwise.\n        \"\"\"\n        return super().__getitem__('autoload')\n\n    def set_autoload(self, autoload: bool):\n        \"\"\"Set whether the cue should be autoloaded.\n\n        Args:\n            autoload (bool): True to enable autoloading, False to disable it.\n        \"\"\"\n        super().__setitem__('autoload', autoload)\n\n    autoload = property(get_autoload, set_autoload)\n\n    def get_timecode(self):\n        \"\"\"Get the timecode setting of the cue.\n\n        Returns:\n            bool: The timecode setting.\n        \"\"\"\n        return super().__getitem__('timecode')\n\n    def set_timecode(self, timecode):\n        \"\"\"Set the timecode setting of the cue.\n\n        Args:\n            timecode (bool): The new timecode setting.\n        \"\"\"\n        super().__setitem__('timecode', timecode)\n\n    timecode = property(get_timecode, set_timecode)\n\n    def get_offset(self):\n        \"\"\"Get the timecode offset of the cue.\n\n        Returns:\n            CTimecode: The cue's timecode offset.\n        \"\"\"\n        return super().__getitem__('offset')\n\n    def set_offset(self, offset):\n        \"\"\"Set the timecode offset of the cue.\n\n        Args:\n            offset: The new timecode offset.\n        \"\"\"\n        offset = format_timecode(offset)\n        self.__setitem__('offset', offset)\n\n    offset = property(get_offset, set_offset)\n\n    def get_loop(self):\n        \"\"\"Get the loop count of the cue.\n\n        Returns:\n            int: The number of times the cue should loop.\n        \"\"\"\n        return super().__getitem__('loop')\n\n    def set_loop(self, loop):\n        \"\"\"Set the loop count of the cue.\n\n        Args:\n            loop (int): The number of times the cue should loop.\n        \"\"\"\n        super().__setitem__('loop', loop)\n\n    loop = property(get_loop, set_loop)\n\n    def get_prewait(self):\n        \"\"\"Get the pre-wait time of the cue.\n\n        Returns:\n            CTimecode: The time to wait before executing the cue.\n        \"\"\"\n        return super().__getitem__('prewait')\n\n    def set_prewait(self, prewait):\n        \"\"\"Set the pre-wait time of the cue.\n\n        Args:\n            prewait: The new pre-wait time.\n        \"\"\"\n        prewait = format_timecode(prewait)\n        super().__setitem__('prewait', prewait)\n\n    prewait = property(get_prewait, set_prewait)\n\n    def get_postwait(self):\n        \"\"\"Get the post-wait time of the cue.\n\n        Returns:\n            CTimecode: The time to wait after executing the cue.\n        \"\"\"\n        return super().__getitem__('postwait')\n\n    def set_postwait(self, postwait):\n        \"\"\"Set the post-wait time of the cue.\n\n        Args:\n            postwait: The new post-wait time.\n        \"\"\"\n        postwait = format_timecode(postwait)\n        super().__setitem__('postwait', postwait)\n\n    postwait = property(get_postwait, set_postwait)\n\n    def get_post_go(self):\n        \"\"\"Get the post-go behavior of the cue.\n\n        Returns:\n            str: The post-go behavior (e.g., 'pause').\n        \"\"\"\n        return super().__getitem__('post_go')\n\n    def set_post_go(self, post_go):\n        \"\"\"Set the post-go behavior of the cue.\n\n        Args:\n            post_go (str): The new post-go behavior.\n        \"\"\"\n        super().__setitem__('post_go', post_go)\n\n    post_go = property(get_post_go, set_post_go)\n\n    def get_target(self):\n        \"\"\"Get the target of the cue.\n\n        Returns:\n            Uuid: The target's unique identifier.\n        \"\"\"\n        return super().__getitem__('target')\n\n    def set_target(self, target):\n        \"\"\"Set the target of the cue.\n\n        Args:\n            target: The new target identifier.\n        \"\"\"\n        if target is not None:\n            target = Uuid(target)\n        super().__setitem__('target', target)\n\n    target = property(get_target, set_target)\n\n    def get_ui_properties(self):\n        \"\"\"Get the UI properties of the cue.\n\n        Returns:\n            dict: The cue's UI properties.\n        \"\"\"\n        return super().__getitem__('ui_properties')\n\n    def set_ui_properties(self, ui_properties):\n        \"\"\"Set the UI properties of the cue.\n\n        Args:\n            ui_properties (dict): The new UI properties.\n        \"\"\"\n        ui_properties = as_cuemsdict(ui_properties)\n        super().__setitem__('ui_properties', ui_properties)\n\n    ui_properties = property(get_ui_properties, set_ui_properties)\n\n    def __eq__(self, other):\n        \"\"\"Compare two cues by their id.\n\n        Args:\n            other: The other cue to compare with.\n\n        Returns:\n            bool: True if the cues have the same id, False otherwise.\n        \"\"\"\n        if isinstance(other, Cue):\n            return self.id == other.id\n        return False\n\n    def __hash__(self):\n        \"\"\"Hash the cue by its id.\n\n        Returns:\n            int: The hash value of the cue's id.\n        \"\"\"\n        return hash(self.id)\n\n    def __json__(self):\n        \"\"\"Convert the cue to a JSON-compatible dictionary.\n\n        Returns:\n            dict: A dictionary representation of the cue.\n        \"\"\"\n        return {type(self).__name__: dict(self.items())}\n\n    def items(self):\n        \"\"\"Get all items in the cue as a dictionary.\n\n        Returns:\n            dict_items: A view of the cue's items.\n        \"\"\"\n        return extract_items(super().items(), REQ_ITEMS.keys())\n\n    def target_object(self, target_object):\n        \"\"\"Set the target object for the cue.\n\n        Args:\n            target_object: The target object to set.\n        \"\"\"\n        self._target_object = target_object\n\n    def type(self):\n        \"\"\"Get the type of the cue.\n\n        Returns:\n            type: The class type of the cue.\n        \"\"\"\n        return type(self)\n\n    def get_next_cue(self):\n        \"\"\"Get the next cue in the sequence.\n\n        Returns:\n            Cue or None: The next cue to execute, or None if there is no next cue.\n        \"\"\"\n        if not self.target:\n            return None\n        if self.post_go == 'pause':\n            return self._target_object\n        return self._target_object.get_next_cue() # type: ignore[union-attr]\n\n    @deprecated(reason=\"This method is deprecated in favor of new mapping logic. Use localize_cue instead.\", version=\"0.1.0rc4\")\n    def check_mappings(self, settings):\n        \"\"\"Check if the given settings are valid for this cue.\n\n        Args:\n            settings: The settings to check.\n\n        Returns:\n            bool: True if the settings are valid, False otherwise.\n        \"\"\"\n        return True\n\n    def localize_cue(self, node_id: str | None = None) -&gt; None:\n        \"\"\"Fallback method to set the _local attribute to True.\n\n        This method is a fallback for cues that do not implement their own localization logic.\n\n        Args:\n            node_id: The ID of the node to localize the cue to.\n        \"\"\"\n        self._local = True\n\n    def stop(self):\n        \"\"\"Stop the execution of the cue.\"\"\"\n        pass\n</code></pre>"},{"location":"cues/#cuemsutils.cues.Cue.Cue.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Compare two cues by their id.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <p>The other cue to compare with.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if the cues have the same id, False otherwise.</p> Source code in <code>src/cuemsutils/cues/Cue.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"Compare two cues by their id.\n\n    Args:\n        other: The other cue to compare with.\n\n    Returns:\n        bool: True if the cues have the same id, False otherwise.\n    \"\"\"\n    if isinstance(other, Cue):\n        return self.id == other.id\n    return False\n</code></pre>"},{"location":"cues/#cuemsutils.cues.Cue.Cue.__hash__","title":"<code>__hash__()</code>","text":"<p>Hash the cue by its id.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>The hash value of the cue's id.</p> Source code in <code>src/cuemsutils/cues/Cue.py</code> <pre><code>def __hash__(self):\n    \"\"\"Hash the cue by its id.\n\n    Returns:\n        int: The hash value of the cue's id.\n    \"\"\"\n    return hash(self.id)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.Cue.Cue.__init__","title":"<code>__init__(init_dict=None)</code>","text":"<p>Initialize a new Cue.</p> <p>Parameters:</p> Name Type Description Default <code>init_dict</code> <code>dict</code> <p>Dictionary containing initialization values. If provided, will be used to set initial properties.</p> <code>None</code> Source code in <code>src/cuemsutils/cues/Cue.py</code> <pre><code>def __init__(self, init_dict = None):\n    \"\"\"Initialize a new Cue.\n\n    Args:\n        init_dict (dict, optional): Dictionary containing initialization values.\n            If provided, will be used to set initial properties.\n    \"\"\"\n    if init_dict:\n        init_dict = ensure_items(init_dict, REQ_ITEMS)\n        self.setter(init_dict)\n\n    self._target_object = None\n    self._conf = None\n    self._armed_list = None\n    self._start_mtc = CTimecode()\n    self._end_mtc = CTimecode()\n    self._end_reached = False\n    self._go_thread = None\n    self._stop_requested = False\n    self._local = False\n</code></pre>"},{"location":"cues/#cuemsutils.cues.Cue.Cue.__json__","title":"<code>__json__()</code>","text":"<p>Convert the cue to a JSON-compatible dictionary.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary representation of the cue.</p> Source code in <code>src/cuemsutils/cues/Cue.py</code> <pre><code>def __json__(self):\n    \"\"\"Convert the cue to a JSON-compatible dictionary.\n\n    Returns:\n        dict: A dictionary representation of the cue.\n    \"\"\"\n    return {type(self).__name__: dict(self.items())}\n</code></pre>"},{"location":"cues/#cuemsutils.cues.Cue.Cue.check_mappings","title":"<code>check_mappings(settings)</code>","text":"<p>Check if the given settings are valid for this cue.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <p>The settings to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if the settings are valid, False otherwise.</p> Source code in <code>src/cuemsutils/cues/Cue.py</code> <pre><code>@deprecated(reason=\"This method is deprecated in favor of new mapping logic. Use localize_cue instead.\", version=\"0.1.0rc4\")\ndef check_mappings(self, settings):\n    \"\"\"Check if the given settings are valid for this cue.\n\n    Args:\n        settings: The settings to check.\n\n    Returns:\n        bool: True if the settings are valid, False otherwise.\n    \"\"\"\n    return True\n</code></pre>"},{"location":"cues/#cuemsutils.cues.Cue.Cue.get_autoload","title":"<code>get_autoload()</code>","text":"<p>Get whether the cue should be autoloaded.</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>True if the cue should be autoloaded, False otherwise.</p> Source code in <code>src/cuemsutils/cues/Cue.py</code> <pre><code>def get_autoload(self):\n    \"\"\"Get whether the cue should be autoloaded.\n\n    Returns:\n        bool: True if the cue should be autoloaded, False otherwise.\n    \"\"\"\n    return super().__getitem__('autoload')\n</code></pre>"},{"location":"cues/#cuemsutils.cues.Cue.Cue.get_description","title":"<code>get_description()</code>","text":"<p>Get the description of the cue.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>The cue's description.</p> Source code in <code>src/cuemsutils/cues/Cue.py</code> <pre><code>def get_description(self):\n    \"\"\"Get the description of the cue.\n\n    Returns:\n        str: The cue's description.\n    \"\"\"\n    return super().__getitem__('description')\n</code></pre>"},{"location":"cues/#cuemsutils.cues.Cue.Cue.get_enabled","title":"<code>get_enabled()</code>","text":"<p>Get whether the cue is enabled.</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>True if the cue is enabled, False otherwise.</p> Source code in <code>src/cuemsutils/cues/Cue.py</code> <pre><code>def get_enabled(self):\n    \"\"\"Get whether the cue is enabled.\n\n    Returns:\n        bool: True if the cue is enabled, False otherwise.\n    \"\"\"\n    return super().__getitem__('enabled')\n</code></pre>"},{"location":"cues/#cuemsutils.cues.Cue.Cue.get_id","title":"<code>get_id()</code>","text":"<p>Get the unique identifier of the cue.</p> <p>Returns:</p> Name Type Description <code>Uuid</code> <p>The cue's unique identifier.</p> Source code in <code>src/cuemsutils/cues/Cue.py</code> <pre><code>def get_id(self):\n    \"\"\"Get the unique identifier of the cue.\n\n    Returns:\n        Uuid: The cue's unique identifier.\n    \"\"\"\n    return super().__getitem__('id')\n</code></pre>"},{"location":"cues/#cuemsutils.cues.Cue.Cue.get_loop","title":"<code>get_loop()</code>","text":"<p>Get the loop count of the cue.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>The number of times the cue should loop.</p> Source code in <code>src/cuemsutils/cues/Cue.py</code> <pre><code>def get_loop(self):\n    \"\"\"Get the loop count of the cue.\n\n    Returns:\n        int: The number of times the cue should loop.\n    \"\"\"\n    return super().__getitem__('loop')\n</code></pre>"},{"location":"cues/#cuemsutils.cues.Cue.Cue.get_name","title":"<code>get_name()</code>","text":"<p>Get the name of the cue.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>The cue's name.</p> Source code in <code>src/cuemsutils/cues/Cue.py</code> <pre><code>def get_name(self):\n    \"\"\"Get the name of the cue.\n\n    Returns:\n        str: The cue's name.\n    \"\"\"\n    return super().__getitem__('name')\n</code></pre>"},{"location":"cues/#cuemsutils.cues.Cue.Cue.get_next_cue","title":"<code>get_next_cue()</code>","text":"<p>Get the next cue in the sequence.</p> <p>Returns:</p> Type Description <p>Cue or None: The next cue to execute, or None if there is no next cue.</p> Source code in <code>src/cuemsutils/cues/Cue.py</code> <pre><code>def get_next_cue(self):\n    \"\"\"Get the next cue in the sequence.\n\n    Returns:\n        Cue or None: The next cue to execute, or None if there is no next cue.\n    \"\"\"\n    if not self.target:\n        return None\n    if self.post_go == 'pause':\n        return self._target_object\n    return self._target_object.get_next_cue() # type: ignore[union-attr]\n</code></pre>"},{"location":"cues/#cuemsutils.cues.Cue.Cue.get_offset","title":"<code>get_offset()</code>","text":"<p>Get the timecode offset of the cue.</p> <p>Returns:</p> Name Type Description <code>CTimecode</code> <p>The cue's timecode offset.</p> Source code in <code>src/cuemsutils/cues/Cue.py</code> <pre><code>def get_offset(self):\n    \"\"\"Get the timecode offset of the cue.\n\n    Returns:\n        CTimecode: The cue's timecode offset.\n    \"\"\"\n    return super().__getitem__('offset')\n</code></pre>"},{"location":"cues/#cuemsutils.cues.Cue.Cue.get_post_go","title":"<code>get_post_go()</code>","text":"<p>Get the post-go behavior of the cue.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>The post-go behavior (e.g., 'pause').</p> Source code in <code>src/cuemsutils/cues/Cue.py</code> <pre><code>def get_post_go(self):\n    \"\"\"Get the post-go behavior of the cue.\n\n    Returns:\n        str: The post-go behavior (e.g., 'pause').\n    \"\"\"\n    return super().__getitem__('post_go')\n</code></pre>"},{"location":"cues/#cuemsutils.cues.Cue.Cue.get_postwait","title":"<code>get_postwait()</code>","text":"<p>Get the post-wait time of the cue.</p> <p>Returns:</p> Name Type Description <code>CTimecode</code> <p>The time to wait after executing the cue.</p> Source code in <code>src/cuemsutils/cues/Cue.py</code> <pre><code>def get_postwait(self):\n    \"\"\"Get the post-wait time of the cue.\n\n    Returns:\n        CTimecode: The time to wait after executing the cue.\n    \"\"\"\n    return super().__getitem__('postwait')\n</code></pre>"},{"location":"cues/#cuemsutils.cues.Cue.Cue.get_prewait","title":"<code>get_prewait()</code>","text":"<p>Get the pre-wait time of the cue.</p> <p>Returns:</p> Name Type Description <code>CTimecode</code> <p>The time to wait before executing the cue.</p> Source code in <code>src/cuemsutils/cues/Cue.py</code> <pre><code>def get_prewait(self):\n    \"\"\"Get the pre-wait time of the cue.\n\n    Returns:\n        CTimecode: The time to wait before executing the cue.\n    \"\"\"\n    return super().__getitem__('prewait')\n</code></pre>"},{"location":"cues/#cuemsutils.cues.Cue.Cue.get_target","title":"<code>get_target()</code>","text":"<p>Get the target of the cue.</p> <p>Returns:</p> Name Type Description <code>Uuid</code> <p>The target's unique identifier.</p> Source code in <code>src/cuemsutils/cues/Cue.py</code> <pre><code>def get_target(self):\n    \"\"\"Get the target of the cue.\n\n    Returns:\n        Uuid: The target's unique identifier.\n    \"\"\"\n    return super().__getitem__('target')\n</code></pre>"},{"location":"cues/#cuemsutils.cues.Cue.Cue.get_timecode","title":"<code>get_timecode()</code>","text":"<p>Get the timecode setting of the cue.</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>The timecode setting.</p> Source code in <code>src/cuemsutils/cues/Cue.py</code> <pre><code>def get_timecode(self):\n    \"\"\"Get the timecode setting of the cue.\n\n    Returns:\n        bool: The timecode setting.\n    \"\"\"\n    return super().__getitem__('timecode')\n</code></pre>"},{"location":"cues/#cuemsutils.cues.Cue.Cue.get_ui_properties","title":"<code>get_ui_properties()</code>","text":"<p>Get the UI properties of the cue.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>The cue's UI properties.</p> Source code in <code>src/cuemsutils/cues/Cue.py</code> <pre><code>def get_ui_properties(self):\n    \"\"\"Get the UI properties of the cue.\n\n    Returns:\n        dict: The cue's UI properties.\n    \"\"\"\n    return super().__getitem__('ui_properties')\n</code></pre>"},{"location":"cues/#cuemsutils.cues.Cue.Cue.items","title":"<code>items()</code>","text":"<p>Get all items in the cue as a dictionary.</p> <p>Returns:</p> Name Type Description <code>dict_items</code> <p>A view of the cue's items.</p> Source code in <code>src/cuemsutils/cues/Cue.py</code> <pre><code>def items(self):\n    \"\"\"Get all items in the cue as a dictionary.\n\n    Returns:\n        dict_items: A view of the cue's items.\n    \"\"\"\n    return extract_items(super().items(), REQ_ITEMS.keys())\n</code></pre>"},{"location":"cues/#cuemsutils.cues.Cue.Cue.localize_cue","title":"<code>localize_cue(node_id=None)</code>","text":"<p>Fallback method to set the _local attribute to True.</p> <p>This method is a fallback for cues that do not implement their own localization logic.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>str | None</code> <p>The ID of the node to localize the cue to.</p> <code>None</code> Source code in <code>src/cuemsutils/cues/Cue.py</code> <pre><code>def localize_cue(self, node_id: str | None = None) -&gt; None:\n    \"\"\"Fallback method to set the _local attribute to True.\n\n    This method is a fallback for cues that do not implement their own localization logic.\n\n    Args:\n        node_id: The ID of the node to localize the cue to.\n    \"\"\"\n    self._local = True\n</code></pre>"},{"location":"cues/#cuemsutils.cues.Cue.Cue.set_autoload","title":"<code>set_autoload(autoload)</code>","text":"<p>Set whether the cue should be autoloaded.</p> <p>Parameters:</p> Name Type Description Default <code>autoload</code> <code>bool</code> <p>True to enable autoloading, False to disable it.</p> required Source code in <code>src/cuemsutils/cues/Cue.py</code> <pre><code>def set_autoload(self, autoload: bool):\n    \"\"\"Set whether the cue should be autoloaded.\n\n    Args:\n        autoload (bool): True to enable autoloading, False to disable it.\n    \"\"\"\n    super().__setitem__('autoload', autoload)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.Cue.Cue.set_description","title":"<code>set_description(description)</code>","text":"<p>Set the description of the cue.</p> <p>Parameters:</p> Name Type Description Default <code>description</code> <code>str</code> <p>The new description for the cue.</p> required Source code in <code>src/cuemsutils/cues/Cue.py</code> <pre><code>def set_description(self, description):\n    \"\"\"Set the description of the cue.\n\n    Args:\n        description (str): The new description for the cue.\n    \"\"\"\n    super().__setitem__('description', description)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.Cue.Cue.set_enabled","title":"<code>set_enabled(enabled)</code>","text":"<p>Set whether the cue is enabled.</p> <p>Parameters:</p> Name Type Description Default <code>enabled</code> <code>bool</code> <p>True to enable the cue, False to disable it.</p> required Source code in <code>src/cuemsutils/cues/Cue.py</code> <pre><code>def set_enabled(self, enabled):\n    \"\"\"Set whether the cue is enabled.\n\n    Args:\n        enabled (bool): True to enable the cue, False to disable it.\n    \"\"\"\n    super().__setitem__('enabled', enabled)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.Cue.Cue.set_id","title":"<code>set_id(id)</code>","text":"<p>Set the unique identifier of the cue.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <p>The new unique identifier.</p> required Source code in <code>src/cuemsutils/cues/Cue.py</code> <pre><code>def set_id(self, id):\n    \"\"\"Set the unique identifier of the cue.\n\n    Args:\n        id: The new unique identifier.\n    \"\"\"\n    id = Uuid(id)\n    super().__setitem__('id', id)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.Cue.Cue.set_loop","title":"<code>set_loop(loop)</code>","text":"<p>Set the loop count of the cue.</p> <p>Parameters:</p> Name Type Description Default <code>loop</code> <code>int</code> <p>The number of times the cue should loop.</p> required Source code in <code>src/cuemsutils/cues/Cue.py</code> <pre><code>def set_loop(self, loop):\n    \"\"\"Set the loop count of the cue.\n\n    Args:\n        loop (int): The number of times the cue should loop.\n    \"\"\"\n    super().__setitem__('loop', loop)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.Cue.Cue.set_name","title":"<code>set_name(name)</code>","text":"<p>Set the name of the cue.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The new name for the cue.</p> required Source code in <code>src/cuemsutils/cues/Cue.py</code> <pre><code>def set_name(self, name):\n    \"\"\"Set the name of the cue.\n\n    Args:\n        name (str): The new name for the cue.\n    \"\"\"\n    super().__setitem__('name', name)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.Cue.Cue.set_offset","title":"<code>set_offset(offset)</code>","text":"<p>Set the timecode offset of the cue.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <p>The new timecode offset.</p> required Source code in <code>src/cuemsutils/cues/Cue.py</code> <pre><code>def set_offset(self, offset):\n    \"\"\"Set the timecode offset of the cue.\n\n    Args:\n        offset: The new timecode offset.\n    \"\"\"\n    offset = format_timecode(offset)\n    self.__setitem__('offset', offset)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.Cue.Cue.set_post_go","title":"<code>set_post_go(post_go)</code>","text":"<p>Set the post-go behavior of the cue.</p> <p>Parameters:</p> Name Type Description Default <code>post_go</code> <code>str</code> <p>The new post-go behavior.</p> required Source code in <code>src/cuemsutils/cues/Cue.py</code> <pre><code>def set_post_go(self, post_go):\n    \"\"\"Set the post-go behavior of the cue.\n\n    Args:\n        post_go (str): The new post-go behavior.\n    \"\"\"\n    super().__setitem__('post_go', post_go)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.Cue.Cue.set_postwait","title":"<code>set_postwait(postwait)</code>","text":"<p>Set the post-wait time of the cue.</p> <p>Parameters:</p> Name Type Description Default <code>postwait</code> <p>The new post-wait time.</p> required Source code in <code>src/cuemsutils/cues/Cue.py</code> <pre><code>def set_postwait(self, postwait):\n    \"\"\"Set the post-wait time of the cue.\n\n    Args:\n        postwait: The new post-wait time.\n    \"\"\"\n    postwait = format_timecode(postwait)\n    super().__setitem__('postwait', postwait)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.Cue.Cue.set_prewait","title":"<code>set_prewait(prewait)</code>","text":"<p>Set the pre-wait time of the cue.</p> <p>Parameters:</p> Name Type Description Default <code>prewait</code> <p>The new pre-wait time.</p> required Source code in <code>src/cuemsutils/cues/Cue.py</code> <pre><code>def set_prewait(self, prewait):\n    \"\"\"Set the pre-wait time of the cue.\n\n    Args:\n        prewait: The new pre-wait time.\n    \"\"\"\n    prewait = format_timecode(prewait)\n    super().__setitem__('prewait', prewait)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.Cue.Cue.set_target","title":"<code>set_target(target)</code>","text":"<p>Set the target of the cue.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <p>The new target identifier.</p> required Source code in <code>src/cuemsutils/cues/Cue.py</code> <pre><code>def set_target(self, target):\n    \"\"\"Set the target of the cue.\n\n    Args:\n        target: The new target identifier.\n    \"\"\"\n    if target is not None:\n        target = Uuid(target)\n    super().__setitem__('target', target)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.Cue.Cue.set_timecode","title":"<code>set_timecode(timecode)</code>","text":"<p>Set the timecode setting of the cue.</p> <p>Parameters:</p> Name Type Description Default <code>timecode</code> <code>bool</code> <p>The new timecode setting.</p> required Source code in <code>src/cuemsutils/cues/Cue.py</code> <pre><code>def set_timecode(self, timecode):\n    \"\"\"Set the timecode setting of the cue.\n\n    Args:\n        timecode (bool): The new timecode setting.\n    \"\"\"\n    super().__setitem__('timecode', timecode)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.Cue.Cue.set_ui_properties","title":"<code>set_ui_properties(ui_properties)</code>","text":"<p>Set the UI properties of the cue.</p> <p>Parameters:</p> Name Type Description Default <code>ui_properties</code> <code>dict</code> <p>The new UI properties.</p> required Source code in <code>src/cuemsutils/cues/Cue.py</code> <pre><code>def set_ui_properties(self, ui_properties):\n    \"\"\"Set the UI properties of the cue.\n\n    Args:\n        ui_properties (dict): The new UI properties.\n    \"\"\"\n    ui_properties = as_cuemsdict(ui_properties)\n    super().__setitem__('ui_properties', ui_properties)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.Cue.Cue.stop","title":"<code>stop()</code>","text":"<p>Stop the execution of the cue.</p> Source code in <code>src/cuemsutils/cues/Cue.py</code> <pre><code>def stop(self):\n    \"\"\"Stop the execution of the cue.\"\"\"\n    pass\n</code></pre>"},{"location":"cues/#cuemsutils.cues.Cue.Cue.target_object","title":"<code>target_object(target_object)</code>","text":"<p>Set the target object for the cue.</p> <p>Parameters:</p> Name Type Description Default <code>target_object</code> <p>The target object to set.</p> required Source code in <code>src/cuemsutils/cues/Cue.py</code> <pre><code>def target_object(self, target_object):\n    \"\"\"Set the target object for the cue.\n\n    Args:\n        target_object: The target object to set.\n    \"\"\"\n    self._target_object = target_object\n</code></pre>"},{"location":"cues/#cuemsutils.cues.Cue.Cue.type","title":"<code>type()</code>","text":"<p>Get the type of the cue.</p> <p>Returns:</p> Name Type Description <code>type</code> <p>The class type of the cue.</p> Source code in <code>src/cuemsutils/cues/Cue.py</code> <pre><code>def type(self):\n    \"\"\"Get the type of the cue.\n\n    Returns:\n        type: The class type of the cue.\n    \"\"\"\n    return type(self)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.Cue.UI_properties","title":"<code>UI_properties</code>","text":"<p>               Bases: <code>CuemsDict</code></p> <p>Class for managing UI-specific properties of cues.</p> Source code in <code>src/cuemsutils/cues/Cue.py</code> <pre><code>class UI_properties(CuemsDict):\n    \"\"\"Class for managing UI-specific properties of cues.\"\"\"\n\n    def __init__(self, init_dict = None):\n        \"\"\"Initialize UI properties.\n\n        Args:\n            init_dict (dict, optional): Dictionary containing initial UI properties.\n        \"\"\"\n        if init_dict:\n            super().__init__(init_dict)\n\n    def get_timeline_position(self):\n        \"\"\"Get the timeline position of the cue.\n\n        Returns:\n            The timeline position value.\n        \"\"\"\n        return super().__getitem__('timeline_position')\n</code></pre>"},{"location":"cues/#cuemsutils.cues.Cue.UI_properties.__init__","title":"<code>__init__(init_dict=None)</code>","text":"<p>Initialize UI properties.</p> <p>Parameters:</p> Name Type Description Default <code>init_dict</code> <code>dict</code> <p>Dictionary containing initial UI properties.</p> <code>None</code> Source code in <code>src/cuemsutils/cues/Cue.py</code> <pre><code>def __init__(self, init_dict = None):\n    \"\"\"Initialize UI properties.\n\n    Args:\n        init_dict (dict, optional): Dictionary containing initial UI properties.\n    \"\"\"\n    if init_dict:\n        super().__init__(init_dict)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.Cue.UI_properties.get_timeline_position","title":"<code>get_timeline_position()</code>","text":"<p>Get the timeline position of the cue.</p> <p>Returns:</p> Type Description <p>The timeline position value.</p> Source code in <code>src/cuemsutils/cues/Cue.py</code> <pre><code>def get_timeline_position(self):\n    \"\"\"Get the timeline position of the cue.\n\n    Returns:\n        The timeline position value.\n    \"\"\"\n    return super().__getitem__('timeline_position')\n</code></pre>"},{"location":"cues/#cuemsutils.cues.CueList.CueList","title":"<code>CueList</code>","text":"<p>               Bases: <code>Cue</code></p> <p>A cue that contains a list of other cues.</p> <p>This class extends Cue to provide functionality for managing collections of cues, including nested cue lists and media tracking.</p> Source code in <code>src/cuemsutils/cues/CueList.py</code> <pre><code>class CueList(Cue):\n    \"\"\"A cue that contains a list of other cues.\n\n    This class extends Cue to provide functionality for managing collections of cues,\n    including nested cue lists and media tracking.\n    \"\"\"\n\n    def __init__(self, init_dict = None):\n        \"\"\"Initialize a CueList.\n\n        Args:\n            init_dict (dict, optional): Dictionary containing initialization values.\n                If not provided, default values from REQ_ITEMS will be used.\n        \"\"\"\n        if not init_dict:\n            init_dict = REQ_ITEMS\n        else:\n            init_dict = ensure_items(init_dict, REQ_ITEMS)\n        super().__init__(init_dict)\n\n    def get_contents(self) -&gt; list[Cue]:\n        \"\"\"Get the list of cues in this cue list.\n\n        Returns:\n            list: The list of Cue objects.\n        \"\"\"\n        return super().__getitem__('contents')\n\n    def set_contents(self, contents: list[Cue]):\n        \"\"\"Set the list of cues in this cue list.\n\n        Args:\n            contents (list): The new list of Cue objects.\n        \"\"\"\n        super().__setitem__('contents', contents)\n\n    contents: list[Cue] = property(get_contents, set_contents)\n\n    def append(self, item: Cue):\n        \"\"\"Add a cue to the end of the list.\n\n        Args:\n            item (Cue): The cue to add.\n\n        Raises:\n            TypeError: If the item is not a Cue object.\n        \"\"\"\n        if not isinstance(item, Cue):\n            raise TypeError(f'Item {item} is not a Cue object')\n        self.contents.append(item)\n\n    def check_mappings(self, settings):\n        \"\"\"Check if the cue list mappings are valid.\n\n        Currently, all CueList objects are considered local.\n\n        Args:\n            settings: The settings containing project node mappings.\n\n        Returns:\n            bool: Always returns True for CueList objects.\n        \"\"\"\n        # DEV: By now let's presume all CueList objects are _local\n        return super().check_mappings()\n\n    def find(self, uuid: Uuid):\n        \"\"\"Find a cue by its UUID in this cue list or its nested lists.\n\n        Args:\n            uuid (Uuid): The UUID to search for.\n\n        Returns:\n            Cue or None: The found cue, or None if not found.\n        \"\"\"\n        if self.id == uuid:\n            return self\n        elif not self.has_contents():\n            return None\n        else:\n            for item in self.contents:\n                if item.id == uuid:\n                    return item\n                elif isinstance(item, CueList):\n                    recursive = item.find(uuid)\n                    if recursive != None:\n                        return recursive\n\n        return None\n\n    def get_media(self):\n        \"\"\"Get a dictionary of all media files present inside contents.\n\n        Returns:\n            dict: A dictionary mapping cue UUIDs to their media information.\n                Each entry contains the media file name and cue type.\n        \"\"\"\n        media_dict = dict()\n\n        if not self.has_contents():\n            return media_dict\n\n        for cue in self.contents:\n            if isinstance(cue, CueList):\n                media_dict.update(cue.get_media())\n            elif isinstance(cue, MediaCue) and hasattr(cue.media, 'file_name'):\n                media_dict[str(cue.id)] = {str(cue.media.id) : cue.media.file_name }\n\n        return media_dict\n\n    def get_next_cue(self):\n        \"\"\"Get the next cue to be executed after this cue list.\n\n        Returns:\n            Cue or None: The next cue to execute, or None if there is no next cue.\n        \"\"\"\n        cue_to_return = None\n        if self.has_contents():\n            # DEV: Always return the first cue in the list is correct?\n            if self.contents[0].post_go == 'pause':\n                cue_to_return = self.contents[0]._target_object\n            else:\n                cue_to_return = self.contents[0].get_next_cue()\n\n            if cue_to_return:\n                return cue_to_return       \n\n        return super().get_next_cue()\n\n    def items(self):\n        \"\"\"Get all items in the cue list as a dictionary.\n\n        Returns:\n            dict_items: A view of the cue list's items.\n        \"\"\"\n        x = dict(super().items())\n        x['contents'] = self.contents\n        return x.items()\n\n    def times(self):\n        \"\"\"Get a list of all cue offsets in this cue list.\n\n        Returns:\n            list: A list of timecode offsets for each cue in the list.\n        \"\"\"\n        timelist = list()\n        for item in self['contents']:\n            timelist.append(item.offset)\n        return timelist\n\n    def has_contents(self):\n        \"\"\"Check if the cue list has contents.\n\n        Returns:\n            bool: True if the cue list has contents, False otherwise.\n        \"\"\"\n        return isinstance(self.contents, list) and len(self.contents) &gt; 0\n</code></pre>"},{"location":"cues/#cuemsutils.cues.CueList.CueList.__init__","title":"<code>__init__(init_dict=None)</code>","text":"<p>Initialize a CueList.</p> <p>Parameters:</p> Name Type Description Default <code>init_dict</code> <code>dict</code> <p>Dictionary containing initialization values. If not provided, default values from REQ_ITEMS will be used.</p> <code>None</code> Source code in <code>src/cuemsutils/cues/CueList.py</code> <pre><code>def __init__(self, init_dict = None):\n    \"\"\"Initialize a CueList.\n\n    Args:\n        init_dict (dict, optional): Dictionary containing initialization values.\n            If not provided, default values from REQ_ITEMS will be used.\n    \"\"\"\n    if not init_dict:\n        init_dict = REQ_ITEMS\n    else:\n        init_dict = ensure_items(init_dict, REQ_ITEMS)\n    super().__init__(init_dict)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.CueList.CueList.append","title":"<code>append(item)</code>","text":"<p>Add a cue to the end of the list.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Cue</code> <p>The cue to add.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If the item is not a Cue object.</p> Source code in <code>src/cuemsutils/cues/CueList.py</code> <pre><code>def append(self, item: Cue):\n    \"\"\"Add a cue to the end of the list.\n\n    Args:\n        item (Cue): The cue to add.\n\n    Raises:\n        TypeError: If the item is not a Cue object.\n    \"\"\"\n    if not isinstance(item, Cue):\n        raise TypeError(f'Item {item} is not a Cue object')\n    self.contents.append(item)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.CueList.CueList.check_mappings","title":"<code>check_mappings(settings)</code>","text":"<p>Check if the cue list mappings are valid.</p> <p>Currently, all CueList objects are considered local.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <p>The settings containing project node mappings.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>Always returns True for CueList objects.</p> Source code in <code>src/cuemsutils/cues/CueList.py</code> <pre><code>def check_mappings(self, settings):\n    \"\"\"Check if the cue list mappings are valid.\n\n    Currently, all CueList objects are considered local.\n\n    Args:\n        settings: The settings containing project node mappings.\n\n    Returns:\n        bool: Always returns True for CueList objects.\n    \"\"\"\n    # DEV: By now let's presume all CueList objects are _local\n    return super().check_mappings()\n</code></pre>"},{"location":"cues/#cuemsutils.cues.CueList.CueList.find","title":"<code>find(uuid)</code>","text":"<p>Find a cue by its UUID in this cue list or its nested lists.</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>Uuid</code> <p>The UUID to search for.</p> required <p>Returns:</p> Type Description <p>Cue or None: The found cue, or None if not found.</p> Source code in <code>src/cuemsutils/cues/CueList.py</code> <pre><code>def find(self, uuid: Uuid):\n    \"\"\"Find a cue by its UUID in this cue list or its nested lists.\n\n    Args:\n        uuid (Uuid): The UUID to search for.\n\n    Returns:\n        Cue or None: The found cue, or None if not found.\n    \"\"\"\n    if self.id == uuid:\n        return self\n    elif not self.has_contents():\n        return None\n    else:\n        for item in self.contents:\n            if item.id == uuid:\n                return item\n            elif isinstance(item, CueList):\n                recursive = item.find(uuid)\n                if recursive != None:\n                    return recursive\n\n    return None\n</code></pre>"},{"location":"cues/#cuemsutils.cues.CueList.CueList.get_contents","title":"<code>get_contents()</code>","text":"<p>Get the list of cues in this cue list.</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list[Cue]</code> <p>The list of Cue objects.</p> Source code in <code>src/cuemsutils/cues/CueList.py</code> <pre><code>def get_contents(self) -&gt; list[Cue]:\n    \"\"\"Get the list of cues in this cue list.\n\n    Returns:\n        list: The list of Cue objects.\n    \"\"\"\n    return super().__getitem__('contents')\n</code></pre>"},{"location":"cues/#cuemsutils.cues.CueList.CueList.get_media","title":"<code>get_media()</code>","text":"<p>Get a dictionary of all media files present inside contents.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary mapping cue UUIDs to their media information. Each entry contains the media file name and cue type.</p> Source code in <code>src/cuemsutils/cues/CueList.py</code> <pre><code>def get_media(self):\n    \"\"\"Get a dictionary of all media files present inside contents.\n\n    Returns:\n        dict: A dictionary mapping cue UUIDs to their media information.\n            Each entry contains the media file name and cue type.\n    \"\"\"\n    media_dict = dict()\n\n    if not self.has_contents():\n        return media_dict\n\n    for cue in self.contents:\n        if isinstance(cue, CueList):\n            media_dict.update(cue.get_media())\n        elif isinstance(cue, MediaCue) and hasattr(cue.media, 'file_name'):\n            media_dict[str(cue.id)] = {str(cue.media.id) : cue.media.file_name }\n\n    return media_dict\n</code></pre>"},{"location":"cues/#cuemsutils.cues.CueList.CueList.get_next_cue","title":"<code>get_next_cue()</code>","text":"<p>Get the next cue to be executed after this cue list.</p> <p>Returns:</p> Type Description <p>Cue or None: The next cue to execute, or None if there is no next cue.</p> Source code in <code>src/cuemsutils/cues/CueList.py</code> <pre><code>def get_next_cue(self):\n    \"\"\"Get the next cue to be executed after this cue list.\n\n    Returns:\n        Cue or None: The next cue to execute, or None if there is no next cue.\n    \"\"\"\n    cue_to_return = None\n    if self.has_contents():\n        # DEV: Always return the first cue in the list is correct?\n        if self.contents[0].post_go == 'pause':\n            cue_to_return = self.contents[0]._target_object\n        else:\n            cue_to_return = self.contents[0].get_next_cue()\n\n        if cue_to_return:\n            return cue_to_return       \n\n    return super().get_next_cue()\n</code></pre>"},{"location":"cues/#cuemsutils.cues.CueList.CueList.has_contents","title":"<code>has_contents()</code>","text":"<p>Check if the cue list has contents.</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>True if the cue list has contents, False otherwise.</p> Source code in <code>src/cuemsutils/cues/CueList.py</code> <pre><code>def has_contents(self):\n    \"\"\"Check if the cue list has contents.\n\n    Returns:\n        bool: True if the cue list has contents, False otherwise.\n    \"\"\"\n    return isinstance(self.contents, list) and len(self.contents) &gt; 0\n</code></pre>"},{"location":"cues/#cuemsutils.cues.CueList.CueList.items","title":"<code>items()</code>","text":"<p>Get all items in the cue list as a dictionary.</p> <p>Returns:</p> Name Type Description <code>dict_items</code> <p>A view of the cue list's items.</p> Source code in <code>src/cuemsutils/cues/CueList.py</code> <pre><code>def items(self):\n    \"\"\"Get all items in the cue list as a dictionary.\n\n    Returns:\n        dict_items: A view of the cue list's items.\n    \"\"\"\n    x = dict(super().items())\n    x['contents'] = self.contents\n    return x.items()\n</code></pre>"},{"location":"cues/#cuemsutils.cues.CueList.CueList.set_contents","title":"<code>set_contents(contents)</code>","text":"<p>Set the list of cues in this cue list.</p> <p>Parameters:</p> Name Type Description Default <code>contents</code> <code>list</code> <p>The new list of Cue objects.</p> required Source code in <code>src/cuemsutils/cues/CueList.py</code> <pre><code>def set_contents(self, contents: list[Cue]):\n    \"\"\"Set the list of cues in this cue list.\n\n    Args:\n        contents (list): The new list of Cue objects.\n    \"\"\"\n    super().__setitem__('contents', contents)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.CueList.CueList.times","title":"<code>times()</code>","text":"<p>Get a list of all cue offsets in this cue list.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>A list of timecode offsets for each cue in the list.</p> Source code in <code>src/cuemsutils/cues/CueList.py</code> <pre><code>def times(self):\n    \"\"\"Get a list of all cue offsets in this cue list.\n\n    Returns:\n        list: A list of timecode offsets for each cue in the list.\n    \"\"\"\n    timelist = list()\n    for item in self['contents']:\n        timelist.append(item.offset)\n    return timelist\n</code></pre>"},{"location":"cues/#cuemsutils.cues.CuemsScript.CuemsScript","title":"<code>CuemsScript</code>","text":"<p>               Bases: <code>dict</code></p> <p>A class representing a complete CueMS script.</p> <p>This class manages a collection of cues organized in a cue list, along with metadata about the script such as creation time and UI properties.</p> Source code in <code>src/cuemsutils/cues/CuemsScript.py</code> <pre><code>class CuemsScript(dict):\n    \"\"\"A class representing a complete CueMS script.\n\n    This class manages a collection of cues organized in a cue list, along with\n    metadata about the script such as creation time and UI properties.\n    \"\"\"\n\n    def __init__(self, init_dict = None):\n        \"\"\"Initialize a CuemsScript.\n\n        Args:\n            init_dict (dict, optional): Dictionary containing initialization values.\n                If provided, will be used to set initial properties.\n        \"\"\"\n        if init_dict:\n            init_dict = ensure_items(init_dict, REQ_ITEMS)\n            self.setter(init_dict)\n\n    def get_id(self):\n        \"\"\"Get the unique identifier of the script.\n\n        Returns:\n            Uuid: The script's unique identifier.\n        \"\"\"\n        return super().__getitem__('id')\n\n    def set_id(self, id):\n        \"\"\"Set the unique identifier of the script.\n\n        Args:\n            id: The new unique identifier.\n        \"\"\"\n        id = Uuid(id)\n        super().__setitem__('id', id)\n\n    id: Uuid = property(get_id, set_id)\n\n    def get_name(self):\n        \"\"\"Get the name of the script.\n\n        Returns:\n            str: The script's name.\n        \"\"\"\n        return super().__getitem__('name')\n\n    def set_name(self, name):\n        \"\"\"Set the name of the script.\n\n        Args:\n            name (str): The new name for the script.\n        \"\"\"\n        super().__setitem__('name', name)\n\n    name: str = property(get_name, set_name)\n\n    def get_description(self):\n        \"\"\"Get the description of the script.\n\n        Returns:\n            str: The script's description.\n        \"\"\"\n        return super().__getitem__('description')\n\n    def set_description(self, description):\n        \"\"\"Set the description of the script.\n\n        Args:\n            description (str): The new description for the script.\n        \"\"\"\n        super().__setitem__('description', description)\n\n    description: str = property(get_description, set_description)\n\n    def get_created(self):\n        \"\"\"Get the creation timestamp of the script.\n\n        Returns:\n            datetime: When the script was created.\n        \"\"\"\n        return super().__getitem__('created')\n\n    def set_created(self, created):\n        \"\"\"Set the creation timestamp of the script.\n\n        Args:\n            created (datetime): The new creation timestamp.\n        \"\"\"\n        super().__setitem__('created', created)\n\n    created = property(get_created, set_created)\n\n    def get_modified(self):\n        \"\"\"Get the last modification timestamp of the script.\n\n        Returns:\n            datetime: When the script was last modified.\n        \"\"\"\n        return super().__getitem__('modified')\n\n    def set_modified(self, modified):\n        \"\"\"Set the last modification timestamp of the script.\n\n        Args:\n            modified (datetime): The new modification timestamp.\n        \"\"\"\n        super().__setitem__('modified', modified)\n\n    modified = property(get_modified, set_modified)\n\n    def get_CueList(self) -&gt; CueList:\n        \"\"\"Get the main cue list of the script.\n\n        Returns:\n            CueList: The script's main cue list.\n        \"\"\"\n        return super().__getitem__('CueList')\n\n    def set_CueList(self, cuelist: CueList | dict):\n        \"\"\"Set the main cue list of the script.\n\n        Args:\n            cuelist (CueList or dict): The new cue list or a dictionary to create one.\n\n        Raises:\n            ValueError: If the cuelist is not a valid CueList object or dictionary.\n        \"\"\"\n        if not isinstance(cuelist, CueList):\n            try:\n                cuelist = CueList(cuelist)\n            except:\n                raise ValueError(\n                    f'CueList {cuelist} is not a CueList object or a valid dict'\n                )\n        super().__setitem__('CueList', cuelist)\n\n    cuelist: CueList = property(get_CueList, set_CueList)\n\n    def get_ui_properties(self) -&gt; CuemsDict:\n        \"\"\"Get the UI properties of the script.\n\n        Returns:\n            dict: The script's UI properties.\n        \"\"\"\n        return super().__getitem__('ui_properties')\n\n    def set_ui_properties(self, ui_properties: dict | CuemsDict):\n        \"\"\"Set the UI properties of the script.\n\n        Args:\n            ui_properties (dict): The new UI properties.\n        \"\"\"\n        Logger.debug(f\"Setting ui_properties to {ui_properties}\")\n        ui_properties = as_cuemsdict(ui_properties)\n        super().__setitem__('ui_properties', ui_properties)\n\n    ui_properties: CuemsDict = property(get_ui_properties, set_ui_properties)\n\n    def find(self, uuid):\n        \"\"\"Find a cue by its UUID in the script.\n\n        Args:\n            uuid: The UUID to search for.\n\n        Returns:\n            Cue or None: The found cue, or None if not found.\n        \"\"\"\n        return self.cuelist.find(uuid)\n\n    @logged\n    def get_media(self) -&gt; dict:\n        \"\"\"Get all media files referenced in a CueList.\n\n        Args:\n            cuelist (CueList, optional): The cue list to search in.\n                If not provided, uses the script's main cue list.\n\n        Returns:\n            dict: A dictionary mapping Cue UUIDs to their media information.\n        \"\"\"\n        return self.cuelist.get_media()\n\n    @logged\n    def get_media_filenames(self) -&gt; list:\n        \"\"\"Get all media filenames referenced in a CueList.\n\n        Returns:\n            list: A list of media filenames.\n        \"\"\"\n        media_dict = {k: list(v.values())[0] for k, v in self.get_media().items()}\n        return unique_values_to_list(media_dict)\n\n    @logged\n    def get_own_media(self, config: dict, cuelist: CueList | None = None) -&gt; dict:\n        \"\"\"Get media files that are local to the current node.\n\n        Args:\n            cuelist (CueList, optional): The cue list to search in.\n                If not provided, uses the script's main cue list.\n            config: The configuration containing node information.\n\n        Returns:\n            dict: A dictionary mapping media file names to their associated cues\n                that are local to the current node.\n        \"\"\"\n        media_dict = dict()\n\n        # If no cuelist is specified we are looking inside our own\n        # script object, so our cuelist is our self cuelist\n        if not cuelist:\n            cuelist = self.cuelist\n\n        if not cuelist.has_contents():\n            return media_dict\n\n        pos = 0\n        for cue in cuelist.contents:  # type: ignore[union-attr]\n            Logger.debug(f'CuemsScript get_own_media: {pos} {cue}')\n            if type(cue) == CueList:\n                media_dict.update(\n                    self.get_own_media(config=config, cuelist=cue)\n                )\n            elif isinstance(cue, MediaCue) and hasattr(cue.media, 'file_name'):\n                Logger.debug(f'get_own_media media cue at {pos}')\n                cue.localize_cue(config.node_conf['uuid'])\n                if cue._local:\n                    media_dict[str(cue.id)] = cue.media.file_name\n            pos += 1\n        return media_dict\n\n    @logged\n    def get_own_media_filenames(self, config: dict, cuelist: CueList | None = None) -&gt; list:\n        \"\"\"Get all media filenames that are local to the current node.\n\n        Returns:\n            list: A list of media filenames.\n        \"\"\"\n        return unique_values_to_list(\n            self.get_own_media(config=config, cuelist=cuelist)\n        )\n\n    def to_json(self):\n        \"\"\"Convert the script to a JSON string.\n\n        Returns:\n            str: A JSON string representation of the script.\n        \"\"\"\n        return json.dumps({'CuemsScript': self})\n\n    def setter(self, settings: dict):\n        \"\"\"Set the object properties from a dictionary.\n\n        Args:\n            settings (dict): Dictionary containing property values to set.\n\n        Raises:\n            AttributeError: If settings is not a dictionary.\n        \"\"\"\n        if not isinstance(settings, dict):\n            raise AttributeError(f\"Invalid type {type(settings)}. Expected dict.\")\n        for k, v in settings.items():\n            try:\n                x = getattr(self, f\"set_{k}\")\n                x(v)\n            except AttributeError:\n                pass\n\n    def __json__(self):\n        \"\"\"Convert the script to a JSON-compatible dictionary.\n\n        Returns:\n            dict: A dictionary representation of the script.\n        \"\"\"\n        x = dict(super().items())\n        for k, v in x.items():\n            if hasattr(v, '__json__'):\n                x[k] = v.__json__()\n            else:\n                x[k] = v\n            if k.lower() != k:\n                x[k] = x[k][k]\n        return x\n\n    def items(self):\n        \"\"\"Get all items in the script as a dictionary.\n\n        Returns:\n            dict_items: A view of the script's items.\n        \"\"\"\n        x = dict(super().items())\n        return x.items()\n</code></pre>"},{"location":"cues/#cuemsutils.cues.CuemsScript.CuemsScript.__init__","title":"<code>__init__(init_dict=None)</code>","text":"<p>Initialize a CuemsScript.</p> <p>Parameters:</p> Name Type Description Default <code>init_dict</code> <code>dict</code> <p>Dictionary containing initialization values. If provided, will be used to set initial properties.</p> <code>None</code> Source code in <code>src/cuemsutils/cues/CuemsScript.py</code> <pre><code>def __init__(self, init_dict = None):\n    \"\"\"Initialize a CuemsScript.\n\n    Args:\n        init_dict (dict, optional): Dictionary containing initialization values.\n            If provided, will be used to set initial properties.\n    \"\"\"\n    if init_dict:\n        init_dict = ensure_items(init_dict, REQ_ITEMS)\n        self.setter(init_dict)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.CuemsScript.CuemsScript.__json__","title":"<code>__json__()</code>","text":"<p>Convert the script to a JSON-compatible dictionary.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary representation of the script.</p> Source code in <code>src/cuemsutils/cues/CuemsScript.py</code> <pre><code>def __json__(self):\n    \"\"\"Convert the script to a JSON-compatible dictionary.\n\n    Returns:\n        dict: A dictionary representation of the script.\n    \"\"\"\n    x = dict(super().items())\n    for k, v in x.items():\n        if hasattr(v, '__json__'):\n            x[k] = v.__json__()\n        else:\n            x[k] = v\n        if k.lower() != k:\n            x[k] = x[k][k]\n    return x\n</code></pre>"},{"location":"cues/#cuemsutils.cues.CuemsScript.CuemsScript.find","title":"<code>find(uuid)</code>","text":"<p>Find a cue by its UUID in the script.</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <p>The UUID to search for.</p> required <p>Returns:</p> Type Description <p>Cue or None: The found cue, or None if not found.</p> Source code in <code>src/cuemsutils/cues/CuemsScript.py</code> <pre><code>def find(self, uuid):\n    \"\"\"Find a cue by its UUID in the script.\n\n    Args:\n        uuid: The UUID to search for.\n\n    Returns:\n        Cue or None: The found cue, or None if not found.\n    \"\"\"\n    return self.cuelist.find(uuid)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.CuemsScript.CuemsScript.get_CueList","title":"<code>get_CueList()</code>","text":"<p>Get the main cue list of the script.</p> <p>Returns:</p> Name Type Description <code>CueList</code> <code>CueList</code> <p>The script's main cue list.</p> Source code in <code>src/cuemsutils/cues/CuemsScript.py</code> <pre><code>def get_CueList(self) -&gt; CueList:\n    \"\"\"Get the main cue list of the script.\n\n    Returns:\n        CueList: The script's main cue list.\n    \"\"\"\n    return super().__getitem__('CueList')\n</code></pre>"},{"location":"cues/#cuemsutils.cues.CuemsScript.CuemsScript.get_created","title":"<code>get_created()</code>","text":"<p>Get the creation timestamp of the script.</p> <p>Returns:</p> Name Type Description <code>datetime</code> <p>When the script was created.</p> Source code in <code>src/cuemsutils/cues/CuemsScript.py</code> <pre><code>def get_created(self):\n    \"\"\"Get the creation timestamp of the script.\n\n    Returns:\n        datetime: When the script was created.\n    \"\"\"\n    return super().__getitem__('created')\n</code></pre>"},{"location":"cues/#cuemsutils.cues.CuemsScript.CuemsScript.get_description","title":"<code>get_description()</code>","text":"<p>Get the description of the script.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>The script's description.</p> Source code in <code>src/cuemsutils/cues/CuemsScript.py</code> <pre><code>def get_description(self):\n    \"\"\"Get the description of the script.\n\n    Returns:\n        str: The script's description.\n    \"\"\"\n    return super().__getitem__('description')\n</code></pre>"},{"location":"cues/#cuemsutils.cues.CuemsScript.CuemsScript.get_id","title":"<code>get_id()</code>","text":"<p>Get the unique identifier of the script.</p> <p>Returns:</p> Name Type Description <code>Uuid</code> <p>The script's unique identifier.</p> Source code in <code>src/cuemsutils/cues/CuemsScript.py</code> <pre><code>def get_id(self):\n    \"\"\"Get the unique identifier of the script.\n\n    Returns:\n        Uuid: The script's unique identifier.\n    \"\"\"\n    return super().__getitem__('id')\n</code></pre>"},{"location":"cues/#cuemsutils.cues.CuemsScript.CuemsScript.get_media","title":"<code>get_media()</code>","text":"<p>Get all media files referenced in a CueList.</p> <p>Parameters:</p> Name Type Description Default <code>cuelist</code> <code>CueList</code> <p>The cue list to search in. If not provided, uses the script's main cue list.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary mapping Cue UUIDs to their media information.</p> Source code in <code>src/cuemsutils/cues/CuemsScript.py</code> <pre><code>@logged\ndef get_media(self) -&gt; dict:\n    \"\"\"Get all media files referenced in a CueList.\n\n    Args:\n        cuelist (CueList, optional): The cue list to search in.\n            If not provided, uses the script's main cue list.\n\n    Returns:\n        dict: A dictionary mapping Cue UUIDs to their media information.\n    \"\"\"\n    return self.cuelist.get_media()\n</code></pre>"},{"location":"cues/#cuemsutils.cues.CuemsScript.CuemsScript.get_media_filenames","title":"<code>get_media_filenames()</code>","text":"<p>Get all media filenames referenced in a CueList.</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of media filenames.</p> Source code in <code>src/cuemsutils/cues/CuemsScript.py</code> <pre><code>@logged\ndef get_media_filenames(self) -&gt; list:\n    \"\"\"Get all media filenames referenced in a CueList.\n\n    Returns:\n        list: A list of media filenames.\n    \"\"\"\n    media_dict = {k: list(v.values())[0] for k, v in self.get_media().items()}\n    return unique_values_to_list(media_dict)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.CuemsScript.CuemsScript.get_modified","title":"<code>get_modified()</code>","text":"<p>Get the last modification timestamp of the script.</p> <p>Returns:</p> Name Type Description <code>datetime</code> <p>When the script was last modified.</p> Source code in <code>src/cuemsutils/cues/CuemsScript.py</code> <pre><code>def get_modified(self):\n    \"\"\"Get the last modification timestamp of the script.\n\n    Returns:\n        datetime: When the script was last modified.\n    \"\"\"\n    return super().__getitem__('modified')\n</code></pre>"},{"location":"cues/#cuemsutils.cues.CuemsScript.CuemsScript.get_name","title":"<code>get_name()</code>","text":"<p>Get the name of the script.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>The script's name.</p> Source code in <code>src/cuemsutils/cues/CuemsScript.py</code> <pre><code>def get_name(self):\n    \"\"\"Get the name of the script.\n\n    Returns:\n        str: The script's name.\n    \"\"\"\n    return super().__getitem__('name')\n</code></pre>"},{"location":"cues/#cuemsutils.cues.CuemsScript.CuemsScript.get_own_media","title":"<code>get_own_media(config, cuelist=None)</code>","text":"<p>Get media files that are local to the current node.</p> <p>Parameters:</p> Name Type Description Default <code>cuelist</code> <code>CueList</code> <p>The cue list to search in. If not provided, uses the script's main cue list.</p> <code>None</code> <code>config</code> <code>dict</code> <p>The configuration containing node information.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary mapping media file names to their associated cues that are local to the current node.</p> Source code in <code>src/cuemsutils/cues/CuemsScript.py</code> <pre><code>@logged\ndef get_own_media(self, config: dict, cuelist: CueList | None = None) -&gt; dict:\n    \"\"\"Get media files that are local to the current node.\n\n    Args:\n        cuelist (CueList, optional): The cue list to search in.\n            If not provided, uses the script's main cue list.\n        config: The configuration containing node information.\n\n    Returns:\n        dict: A dictionary mapping media file names to their associated cues\n            that are local to the current node.\n    \"\"\"\n    media_dict = dict()\n\n    # If no cuelist is specified we are looking inside our own\n    # script object, so our cuelist is our self cuelist\n    if not cuelist:\n        cuelist = self.cuelist\n\n    if not cuelist.has_contents():\n        return media_dict\n\n    pos = 0\n    for cue in cuelist.contents:  # type: ignore[union-attr]\n        Logger.debug(f'CuemsScript get_own_media: {pos} {cue}')\n        if type(cue) == CueList:\n            media_dict.update(\n                self.get_own_media(config=config, cuelist=cue)\n            )\n        elif isinstance(cue, MediaCue) and hasattr(cue.media, 'file_name'):\n            Logger.debug(f'get_own_media media cue at {pos}')\n            cue.localize_cue(config.node_conf['uuid'])\n            if cue._local:\n                media_dict[str(cue.id)] = cue.media.file_name\n        pos += 1\n    return media_dict\n</code></pre>"},{"location":"cues/#cuemsutils.cues.CuemsScript.CuemsScript.get_own_media_filenames","title":"<code>get_own_media_filenames(config, cuelist=None)</code>","text":"<p>Get all media filenames that are local to the current node.</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of media filenames.</p> Source code in <code>src/cuemsutils/cues/CuemsScript.py</code> <pre><code>@logged\ndef get_own_media_filenames(self, config: dict, cuelist: CueList | None = None) -&gt; list:\n    \"\"\"Get all media filenames that are local to the current node.\n\n    Returns:\n        list: A list of media filenames.\n    \"\"\"\n    return unique_values_to_list(\n        self.get_own_media(config=config, cuelist=cuelist)\n    )\n</code></pre>"},{"location":"cues/#cuemsutils.cues.CuemsScript.CuemsScript.get_ui_properties","title":"<code>get_ui_properties()</code>","text":"<p>Get the UI properties of the script.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>CuemsDict</code> <p>The script's UI properties.</p> Source code in <code>src/cuemsutils/cues/CuemsScript.py</code> <pre><code>def get_ui_properties(self) -&gt; CuemsDict:\n    \"\"\"Get the UI properties of the script.\n\n    Returns:\n        dict: The script's UI properties.\n    \"\"\"\n    return super().__getitem__('ui_properties')\n</code></pre>"},{"location":"cues/#cuemsutils.cues.CuemsScript.CuemsScript.items","title":"<code>items()</code>","text":"<p>Get all items in the script as a dictionary.</p> <p>Returns:</p> Name Type Description <code>dict_items</code> <p>A view of the script's items.</p> Source code in <code>src/cuemsutils/cues/CuemsScript.py</code> <pre><code>def items(self):\n    \"\"\"Get all items in the script as a dictionary.\n\n    Returns:\n        dict_items: A view of the script's items.\n    \"\"\"\n    x = dict(super().items())\n    return x.items()\n</code></pre>"},{"location":"cues/#cuemsutils.cues.CuemsScript.CuemsScript.set_CueList","title":"<code>set_CueList(cuelist)</code>","text":"<p>Set the main cue list of the script.</p> <p>Parameters:</p> Name Type Description Default <code>cuelist</code> <code>CueList or dict</code> <p>The new cue list or a dictionary to create one.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cuelist is not a valid CueList object or dictionary.</p> Source code in <code>src/cuemsutils/cues/CuemsScript.py</code> <pre><code>def set_CueList(self, cuelist: CueList | dict):\n    \"\"\"Set the main cue list of the script.\n\n    Args:\n        cuelist (CueList or dict): The new cue list or a dictionary to create one.\n\n    Raises:\n        ValueError: If the cuelist is not a valid CueList object or dictionary.\n    \"\"\"\n    if not isinstance(cuelist, CueList):\n        try:\n            cuelist = CueList(cuelist)\n        except:\n            raise ValueError(\n                f'CueList {cuelist} is not a CueList object or a valid dict'\n            )\n    super().__setitem__('CueList', cuelist)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.CuemsScript.CuemsScript.set_created","title":"<code>set_created(created)</code>","text":"<p>Set the creation timestamp of the script.</p> <p>Parameters:</p> Name Type Description Default <code>created</code> <code>datetime</code> <p>The new creation timestamp.</p> required Source code in <code>src/cuemsutils/cues/CuemsScript.py</code> <pre><code>def set_created(self, created):\n    \"\"\"Set the creation timestamp of the script.\n\n    Args:\n        created (datetime): The new creation timestamp.\n    \"\"\"\n    super().__setitem__('created', created)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.CuemsScript.CuemsScript.set_description","title":"<code>set_description(description)</code>","text":"<p>Set the description of the script.</p> <p>Parameters:</p> Name Type Description Default <code>description</code> <code>str</code> <p>The new description for the script.</p> required Source code in <code>src/cuemsutils/cues/CuemsScript.py</code> <pre><code>def set_description(self, description):\n    \"\"\"Set the description of the script.\n\n    Args:\n        description (str): The new description for the script.\n    \"\"\"\n    super().__setitem__('description', description)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.CuemsScript.CuemsScript.set_id","title":"<code>set_id(id)</code>","text":"<p>Set the unique identifier of the script.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <p>The new unique identifier.</p> required Source code in <code>src/cuemsutils/cues/CuemsScript.py</code> <pre><code>def set_id(self, id):\n    \"\"\"Set the unique identifier of the script.\n\n    Args:\n        id: The new unique identifier.\n    \"\"\"\n    id = Uuid(id)\n    super().__setitem__('id', id)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.CuemsScript.CuemsScript.set_modified","title":"<code>set_modified(modified)</code>","text":"<p>Set the last modification timestamp of the script.</p> <p>Parameters:</p> Name Type Description Default <code>modified</code> <code>datetime</code> <p>The new modification timestamp.</p> required Source code in <code>src/cuemsutils/cues/CuemsScript.py</code> <pre><code>def set_modified(self, modified):\n    \"\"\"Set the last modification timestamp of the script.\n\n    Args:\n        modified (datetime): The new modification timestamp.\n    \"\"\"\n    super().__setitem__('modified', modified)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.CuemsScript.CuemsScript.set_name","title":"<code>set_name(name)</code>","text":"<p>Set the name of the script.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The new name for the script.</p> required Source code in <code>src/cuemsutils/cues/CuemsScript.py</code> <pre><code>def set_name(self, name):\n    \"\"\"Set the name of the script.\n\n    Args:\n        name (str): The new name for the script.\n    \"\"\"\n    super().__setitem__('name', name)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.CuemsScript.CuemsScript.set_ui_properties","title":"<code>set_ui_properties(ui_properties)</code>","text":"<p>Set the UI properties of the script.</p> <p>Parameters:</p> Name Type Description Default <code>ui_properties</code> <code>dict</code> <p>The new UI properties.</p> required Source code in <code>src/cuemsutils/cues/CuemsScript.py</code> <pre><code>def set_ui_properties(self, ui_properties: dict | CuemsDict):\n    \"\"\"Set the UI properties of the script.\n\n    Args:\n        ui_properties (dict): The new UI properties.\n    \"\"\"\n    Logger.debug(f\"Setting ui_properties to {ui_properties}\")\n    ui_properties = as_cuemsdict(ui_properties)\n    super().__setitem__('ui_properties', ui_properties)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.CuemsScript.CuemsScript.setter","title":"<code>setter(settings)</code>","text":"<p>Set the object properties from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>dict</code> <p>Dictionary containing property values to set.</p> required <p>Raises:</p> Type Description <code>AttributeError</code> <p>If settings is not a dictionary.</p> Source code in <code>src/cuemsutils/cues/CuemsScript.py</code> <pre><code>def setter(self, settings: dict):\n    \"\"\"Set the object properties from a dictionary.\n\n    Args:\n        settings (dict): Dictionary containing property values to set.\n\n    Raises:\n        AttributeError: If settings is not a dictionary.\n    \"\"\"\n    if not isinstance(settings, dict):\n        raise AttributeError(f\"Invalid type {type(settings)}. Expected dict.\")\n    for k, v in settings.items():\n        try:\n            x = getattr(self, f\"set_{k}\")\n            x(v)\n        except AttributeError:\n            pass\n</code></pre>"},{"location":"cues/#cuemsutils.cues.CuemsScript.CuemsScript.to_json","title":"<code>to_json()</code>","text":"<p>Convert the script to a JSON string.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>A JSON string representation of the script.</p> Source code in <code>src/cuemsutils/cues/CuemsScript.py</code> <pre><code>def to_json(self):\n    \"\"\"Convert the script to a JSON string.\n\n    Returns:\n        str: A JSON string representation of the script.\n    \"\"\"\n    return json.dumps({'CuemsScript': self})\n</code></pre>"},{"location":"cues/#cuemsutils.cues.CueOutput.AudioCueOutput","title":"<code>AudioCueOutput</code>","text":"<p>               Bases: <code>CueOutput</code></p> <p>Output configuration for audio cues.</p> <p>This class extends CueOutput to provide specific functionality for audio output routing and configuration.</p> Source code in <code>src/cuemsutils/cues/CueOutput.py</code> <pre><code>class AudioCueOutput(CueOutput):\n    \"\"\"Output configuration for audio cues.\n\n    This class extends CueOutput to provide specific functionality for audio output\n    routing and configuration.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"cues/#cuemsutils.cues.CueOutput.CueOutput","title":"<code>CueOutput</code>","text":"<p>               Bases: <code>CuemsDict</code></p> <p>Base class for cue output configurations.</p> <p>This class provides the basic structure for configuring how cues are output to different types of devices or systems.</p> Source code in <code>src/cuemsutils/cues/CueOutput.py</code> <pre><code>class CueOutput(CuemsDict):\n    \"\"\"Base class for cue output configurations.\n\n    This class provides the basic structure for configuring how cues are output\n    to different types of devices or systems.\n    \"\"\"\n\n    def __init__(self, init_dict = None):\n        \"\"\"Initialize a CueOutput.\n\n        Args:\n            init_dict (dict, optional): Dictionary containing initialization values.\n                If provided, will be used to set initial properties.\n        \"\"\"\n        if init_dict:\n            super().__init__(init_dict)\n\n    def __json__(self):\n        \"\"\"Convert the output configuration to a JSON-compatible dictionary.\n\n        Returns:\n            dict: A dictionary representation of the output configuration.\n        \"\"\"\n        return {type(self).__name__: dict(self.items())}\n</code></pre>"},{"location":"cues/#cuemsutils.cues.CueOutput.CueOutput.__init__","title":"<code>__init__(init_dict=None)</code>","text":"<p>Initialize a CueOutput.</p> <p>Parameters:</p> Name Type Description Default <code>init_dict</code> <code>dict</code> <p>Dictionary containing initialization values. If provided, will be used to set initial properties.</p> <code>None</code> Source code in <code>src/cuemsutils/cues/CueOutput.py</code> <pre><code>def __init__(self, init_dict = None):\n    \"\"\"Initialize a CueOutput.\n\n    Args:\n        init_dict (dict, optional): Dictionary containing initialization values.\n            If provided, will be used to set initial properties.\n    \"\"\"\n    if init_dict:\n        super().__init__(init_dict)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.CueOutput.CueOutput.__json__","title":"<code>__json__()</code>","text":"<p>Convert the output configuration to a JSON-compatible dictionary.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary representation of the output configuration.</p> Source code in <code>src/cuemsutils/cues/CueOutput.py</code> <pre><code>def __json__(self):\n    \"\"\"Convert the output configuration to a JSON-compatible dictionary.\n\n    Returns:\n        dict: A dictionary representation of the output configuration.\n    \"\"\"\n    return {type(self).__name__: dict(self.items())}\n</code></pre>"},{"location":"cues/#cuemsutils.cues.CueOutput.DmxCueOutput","title":"<code>DmxCueOutput</code>","text":"<p>               Bases: <code>CueOutput</code></p> <p>Output configuration for DMX cues.</p> <p>This class extends CueOutput to provide specific functionality for DMX output routing and configuration.</p> Source code in <code>src/cuemsutils/cues/CueOutput.py</code> <pre><code>class DmxCueOutput(CueOutput):\n    \"\"\"Output configuration for DMX cues.\n\n    This class extends CueOutput to provide specific functionality for DMX output\n    routing and configuration.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"cues/#cuemsutils.cues.CueOutput.VideoCueOutput","title":"<code>VideoCueOutput</code>","text":"<p>               Bases: <code>CueOutput</code></p> <p>Output configuration for video cues.</p> <p>This class extends CueOutput to provide specific functionality for video output routing and configuration.</p> Source code in <code>src/cuemsutils/cues/CueOutput.py</code> <pre><code>class VideoCueOutput(CueOutput):\n    \"\"\"Output configuration for video cues.\n\n    This class extends CueOutput to provide specific functionality for video output\n    routing and configuration.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"cues/#cuemsutils.cues.DmxCue.DmxChannel","title":"<code>DmxChannel</code>","text":"<p>               Bases: <code>CuemsDict</code></p> <p>A class representing a single DMX channel.</p> Source code in <code>src/cuemsutils/cues/DmxCue.py</code> <pre><code>class DmxChannel(CuemsDict):\n    \"\"\"A class representing a single DMX channel.\"\"\"\n\n    def __init__(self, init_dict = None):\n        \"\"\"Initialize a DMX channel.\n\n        Args:\n            value (int, optional): The initial channel value.\n            init_dict (dict, optional): Dictionary containing initialization values.\n        \"\"\"\n        if not init_dict:\n            init_dict = DMXCHANNEL_REQ_ITEMS\n        else:\n            init_dict = ensure_items(init_dict, DMXCHANNEL_REQ_ITEMS)\n        if init_dict:\n            self.setter(init_dict)\n\n\n\n    def get_channel(self):\n        \"\"\"Get the channel number.\n\n        Returns:\n            int: The channel number.\n        \"\"\"\n        return super().__getitem__('channel')\n\n    def set_channel(self, channel):\n        \"\"\"Set the channel number.\n\n        Args:\n            num (int): The new channel number.\n        \"\"\"\n        super().__setitem__('channel', channel)\n    channel = property(get_channel, set_channel)\n\n    def get_value(self):\n        \"\"\"Get the channel value.\n\n        Returns:\n            int: The channel value.\n        \"\"\"\n        return super().__getitem__('value')\n\n    def set_value(self, value):\n        \"\"\"Set the channel value.\n\n        Args:\n            value (int): The new channel value.\n        \"\"\"\n        super().__setitem__('value', value)\n    value = property(get_value, set_value)\n\n    def __json__(self):\n        \"\"\"Convert the region to a JSON-compatible dictionary.\n\n        Returns:\n            dict: A dictionary representation of the region.\n        \"\"\"\n        return {type(self).__name__: dict(self.items())}\n</code></pre>"},{"location":"cues/#cuemsutils.cues.DmxCue.DmxChannel.__init__","title":"<code>__init__(init_dict=None)</code>","text":"<p>Initialize a DMX channel.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>The initial channel value.</p> required <code>init_dict</code> <code>dict</code> <p>Dictionary containing initialization values.</p> <code>None</code> Source code in <code>src/cuemsutils/cues/DmxCue.py</code> <pre><code>def __init__(self, init_dict = None):\n    \"\"\"Initialize a DMX channel.\n\n    Args:\n        value (int, optional): The initial channel value.\n        init_dict (dict, optional): Dictionary containing initialization values.\n    \"\"\"\n    if not init_dict:\n        init_dict = DMXCHANNEL_REQ_ITEMS\n    else:\n        init_dict = ensure_items(init_dict, DMXCHANNEL_REQ_ITEMS)\n    if init_dict:\n        self.setter(init_dict)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.DmxCue.DmxChannel.__json__","title":"<code>__json__()</code>","text":"<p>Convert the region to a JSON-compatible dictionary.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary representation of the region.</p> Source code in <code>src/cuemsutils/cues/DmxCue.py</code> <pre><code>def __json__(self):\n    \"\"\"Convert the region to a JSON-compatible dictionary.\n\n    Returns:\n        dict: A dictionary representation of the region.\n    \"\"\"\n    return {type(self).__name__: dict(self.items())}\n</code></pre>"},{"location":"cues/#cuemsutils.cues.DmxCue.DmxChannel.get_channel","title":"<code>get_channel()</code>","text":"<p>Get the channel number.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>The channel number.</p> Source code in <code>src/cuemsutils/cues/DmxCue.py</code> <pre><code>def get_channel(self):\n    \"\"\"Get the channel number.\n\n    Returns:\n        int: The channel number.\n    \"\"\"\n    return super().__getitem__('channel')\n</code></pre>"},{"location":"cues/#cuemsutils.cues.DmxCue.DmxChannel.get_value","title":"<code>get_value()</code>","text":"<p>Get the channel value.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>The channel value.</p> Source code in <code>src/cuemsutils/cues/DmxCue.py</code> <pre><code>def get_value(self):\n    \"\"\"Get the channel value.\n\n    Returns:\n        int: The channel value.\n    \"\"\"\n    return super().__getitem__('value')\n</code></pre>"},{"location":"cues/#cuemsutils.cues.DmxCue.DmxChannel.set_channel","title":"<code>set_channel(channel)</code>","text":"<p>Set the channel number.</p> <p>Parameters:</p> Name Type Description Default <code>num</code> <code>int</code> <p>The new channel number.</p> required Source code in <code>src/cuemsutils/cues/DmxCue.py</code> <pre><code>def set_channel(self, channel):\n    \"\"\"Set the channel number.\n\n    Args:\n        num (int): The new channel number.\n    \"\"\"\n    super().__setitem__('channel', channel)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.DmxCue.DmxChannel.set_value","title":"<code>set_value(value)</code>","text":"<p>Set the channel value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>The new channel value.</p> required Source code in <code>src/cuemsutils/cues/DmxCue.py</code> <pre><code>def set_value(self, value):\n    \"\"\"Set the channel value.\n\n    Args:\n        value (int): The new channel value.\n    \"\"\"\n    super().__setitem__('value', value)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.DmxCue.DmxCue","title":"<code>DmxCue</code>","text":"<p>               Bases: <code>Cue</code></p> <p>A cue for handling DMX lighting control.</p> <p>This class extends Cue to provide specific functionality for DMX lighting control, including scene management, fade timing, and OSC communication for DMX routing.</p> Source code in <code>src/cuemsutils/cues/DmxCue.py</code> <pre><code>class DmxCue(Cue):\n    \"\"\"A cue for handling DMX lighting control.\n\n    This class extends Cue to provide specific functionality for DMX lighting control,\n    including scene management, fade timing, and OSC communication for DMX routing.\n    \"\"\"\n\n    def __init__(self, init_dict = None):\n        \"\"\"Initialize a DmxCue.\n\n        Args:\n            init_dict (dict, optional): Dictionary containing initialization values.\n                If provided, will be used to set initial properties.\n        \"\"\"\n        if not init_dict:\n            init_dict = REQ_ITEMS\n        else:\n            init_dict = ensure_items(init_dict, REQ_ITEMS)\n        super().__init__(init_dict)\n\n        self._player = None\n        self._osc_route = None\n        self._offset_route = '/offset'\n\n    def get_fadein_time(self):\n        \"\"\"Get the fade-in time for the DMX cue.\n\n        Returns:\n            The fade-in time value.\n        \"\"\"\n        return super().__getitem__('fadein_time')\n\n    def set_fadein_time(self, fadein_time):\n        \"\"\"Set the fade-in time for the DMX cue.\n\n        Args:\n            fadein_time: The new fade-in time value.\n        \"\"\"\n        super().__setitem__('fadein_time', fadein_time)\n\n    fadein_time = property(get_fadein_time, set_fadein_time)\n\n    def get_fadeout_time(self):\n        \"\"\"Get the fade-out time for the DMX cue.\n\n        Returns:\n            The fade-out time value.\n        \"\"\"\n        return super().__getitem__('fadeout_time')\n\n\n    def set_fadeout_time(self, fadeout_time):\n        \"\"\"Set the fade-out time for the DMX cue.\n\n        Args:\n            fadeout_time: The new fade-out time value.\n        \"\"\"\n        super().__setitem__('fadeout_time', fadeout_time)\n\n    fadeout_time = property(get_fadeout_time, set_fadeout_time)\n\n    def get_outputs(self):\n        \"\"\"Get the output routing configuration.\n\n        Returns:\n            list: The list of output configurations.\n        \"\"\"\n        return super().__getitem__('outputs')\n\n    def set_outputs(self, outputs):\n        \"\"\"Set the output routing configuration.\n\n        Args:\n            outputs (list): The list of output configurations. Each item can be\n                a DmxCueOutput object or a dict that will be converted to DmxCueOutput.\n        \"\"\"\n        if outputs is None:\n            super().__setitem__('outputs', None)\n            return\n\n        if not isinstance(outputs, list):\n            outputs = [outputs]\n\n        converted_outputs = []\n        for output in outputs:\n            if output is None:\n                continue\n            if not isinstance(output, DmxCueOutput):\n                if isinstance(output, dict):\n                    if 'DmxCueOutput' in output:\n                        inner = output['DmxCueOutput']\n                        # XML converter may produce a list of dicts for the inner value\n                        if isinstance(inner, list):\n                            for item in inner:\n                                if isinstance(item, dict):\n                                    converted_outputs.append(DmxCueOutput(item))\n                        elif isinstance(inner, dict):\n                            converted_outputs.append(DmxCueOutput(inner))\n                    else:\n                        converted_outputs.append(DmxCueOutput(output))\n                else:\n                    converted_outputs.append(output)\n            else:\n                converted_outputs.append(output)\n\n        super().__setitem__('outputs', converted_outputs)\n\n    outputs = property(get_outputs, set_outputs)\n\n    def get_DmxScene(self):\n        \"\"\"Get the DMX scene for this cue.\n\n        Returns:\n            DmxScene: The current DMX scene.\n        \"\"\"\n        return super().__getitem__('DmxScene')\n\n\n    def set_DmxScene(self, dmxscene):\n        \"\"\"Set the DMX scene for this cue.\n\n        Args:\n            dmxscene (DmxScene or dict): The new DMX scene or a dictionary to create one.\n\n        Raises:\n            NotImplementedError: If the scene type is not supported.\n        \"\"\"\n        if not isinstance(dmxscene, DmxScene):\n            dmxscene = DmxScene(dmxscene)\n        super().__setitem__('DmxScene', dmxscene)\n\n    DmxScene = property(get_DmxScene, set_DmxScene)\n\n    def osc_route(self, osc_route):\n        \"\"\"Set the OSC route for DMX control.\n\n        Args:\n            osc_route (str): The OSC route to use for DMX control.\n        \"\"\"\n        self._osc_route = osc_route\n\n    def offset_route(self, offset_route):\n        \"\"\"Set the offset route for DMX timing.\n\n        Args:\n            offset_route (str): The new offset route.\n        \"\"\"\n        self._offset_route = offset_route\n\n    def player(self, player):\n        \"\"\"Set the DMX player instance.\n\n        Args:\n            player: The DMX player instance to use.\n        \"\"\"\n        self._player = player\n\n    def review_offset(self, timecode):\n        \"\"\"Calculate the offset for DMX timing review.\n\n        Args:\n            timecode: The timecode to calculate the offset from.\n\n        Returns:\n            float: The calculated offset in milliseconds.\n        \"\"\"\n        return -(float(timecode.milliseconds))\n\n    def check_mappings(self, settings):\n        \"\"\"Check if the DMX output mappings are valid.\n\n        For DMX cues, the output_name format is \"{node_uuid}\" (just the node UUID).\n        A DMX cue can have multiple outputs (one per target node). This method\n        iterates through all outputs and sets _local=True if ANY output_name\n        matches the current node UUID. Other outputs are ignored.\n\n        Args:\n            settings: The settings containing project node mappings.\n\n        Returns:\n            bool: True if the mappings are valid, False otherwise.\n        \"\"\"\n        # Call parent check_mappings first\n        if not super().check_mappings(settings):\n            return False\n\n        if not settings.project_node_mappings:\n            return True\n\n        # Initialize _local to False (will be set to True if any output matches)\n        self._local = False\n\n        # Get current node UUID\n        current_node_uuid = settings.node_conf.get('uuid')\n        if not current_node_uuid:\n            Logger.warning(f'DmxCue {self.id}: No node UUID found in settings')\n            return True\n\n        # Check each output\n        if self.outputs:\n            for output in self.outputs:\n                # For DMX cues, output_name is just the node UUID (not {node_uuid}_{output_name})\n                output_name = output.get('output_name', '')\n\n                # Compare entire output_name with current node UUID\n                if output_name == current_node_uuid:\n                    self._local = True\n                    Logger.debug(\n                        f'DmxCue {self.id} output_name {output_name} matches current node, setting _local=True'\n                    )\n                    break  # Found a match, no need to check other outputs\n\n        return True\n\n    def items(self):\n        \"\"\"Get all items in the cue as a dictionary.\n\n        Returns:\n            dict_items: A view of the cue's items, with required items included.\n        \"\"\"\n        x = dict(super().items())\n        for k in REQ_ITEMS.keys():\n            x[k] = self[k]\n        return x.items()\n</code></pre>"},{"location":"cues/#cuemsutils.cues.DmxCue.DmxCue.__init__","title":"<code>__init__(init_dict=None)</code>","text":"<p>Initialize a DmxCue.</p> <p>Parameters:</p> Name Type Description Default <code>init_dict</code> <code>dict</code> <p>Dictionary containing initialization values. If provided, will be used to set initial properties.</p> <code>None</code> Source code in <code>src/cuemsutils/cues/DmxCue.py</code> <pre><code>def __init__(self, init_dict = None):\n    \"\"\"Initialize a DmxCue.\n\n    Args:\n        init_dict (dict, optional): Dictionary containing initialization values.\n            If provided, will be used to set initial properties.\n    \"\"\"\n    if not init_dict:\n        init_dict = REQ_ITEMS\n    else:\n        init_dict = ensure_items(init_dict, REQ_ITEMS)\n    super().__init__(init_dict)\n\n    self._player = None\n    self._osc_route = None\n    self._offset_route = '/offset'\n</code></pre>"},{"location":"cues/#cuemsutils.cues.DmxCue.DmxCue.check_mappings","title":"<code>check_mappings(settings)</code>","text":"<p>Check if the DMX output mappings are valid.</p> <p>For DMX cues, the output_name format is \"{node_uuid}\" (just the node UUID). A DMX cue can have multiple outputs (one per target node). This method iterates through all outputs and sets _local=True if ANY output_name matches the current node UUID. Other outputs are ignored.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <p>The settings containing project node mappings.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if the mappings are valid, False otherwise.</p> Source code in <code>src/cuemsutils/cues/DmxCue.py</code> <pre><code>def check_mappings(self, settings):\n    \"\"\"Check if the DMX output mappings are valid.\n\n    For DMX cues, the output_name format is \"{node_uuid}\" (just the node UUID).\n    A DMX cue can have multiple outputs (one per target node). This method\n    iterates through all outputs and sets _local=True if ANY output_name\n    matches the current node UUID. Other outputs are ignored.\n\n    Args:\n        settings: The settings containing project node mappings.\n\n    Returns:\n        bool: True if the mappings are valid, False otherwise.\n    \"\"\"\n    # Call parent check_mappings first\n    if not super().check_mappings(settings):\n        return False\n\n    if not settings.project_node_mappings:\n        return True\n\n    # Initialize _local to False (will be set to True if any output matches)\n    self._local = False\n\n    # Get current node UUID\n    current_node_uuid = settings.node_conf.get('uuid')\n    if not current_node_uuid:\n        Logger.warning(f'DmxCue {self.id}: No node UUID found in settings')\n        return True\n\n    # Check each output\n    if self.outputs:\n        for output in self.outputs:\n            # For DMX cues, output_name is just the node UUID (not {node_uuid}_{output_name})\n            output_name = output.get('output_name', '')\n\n            # Compare entire output_name with current node UUID\n            if output_name == current_node_uuid:\n                self._local = True\n                Logger.debug(\n                    f'DmxCue {self.id} output_name {output_name} matches current node, setting _local=True'\n                )\n                break  # Found a match, no need to check other outputs\n\n    return True\n</code></pre>"},{"location":"cues/#cuemsutils.cues.DmxCue.DmxCue.get_DmxScene","title":"<code>get_DmxScene()</code>","text":"<p>Get the DMX scene for this cue.</p> <p>Returns:</p> Name Type Description <code>DmxScene</code> <p>The current DMX scene.</p> Source code in <code>src/cuemsutils/cues/DmxCue.py</code> <pre><code>def get_DmxScene(self):\n    \"\"\"Get the DMX scene for this cue.\n\n    Returns:\n        DmxScene: The current DMX scene.\n    \"\"\"\n    return super().__getitem__('DmxScene')\n</code></pre>"},{"location":"cues/#cuemsutils.cues.DmxCue.DmxCue.get_fadein_time","title":"<code>get_fadein_time()</code>","text":"<p>Get the fade-in time for the DMX cue.</p> <p>Returns:</p> Type Description <p>The fade-in time value.</p> Source code in <code>src/cuemsutils/cues/DmxCue.py</code> <pre><code>def get_fadein_time(self):\n    \"\"\"Get the fade-in time for the DMX cue.\n\n    Returns:\n        The fade-in time value.\n    \"\"\"\n    return super().__getitem__('fadein_time')\n</code></pre>"},{"location":"cues/#cuemsutils.cues.DmxCue.DmxCue.get_fadeout_time","title":"<code>get_fadeout_time()</code>","text":"<p>Get the fade-out time for the DMX cue.</p> <p>Returns:</p> Type Description <p>The fade-out time value.</p> Source code in <code>src/cuemsutils/cues/DmxCue.py</code> <pre><code>def get_fadeout_time(self):\n    \"\"\"Get the fade-out time for the DMX cue.\n\n    Returns:\n        The fade-out time value.\n    \"\"\"\n    return super().__getitem__('fadeout_time')\n</code></pre>"},{"location":"cues/#cuemsutils.cues.DmxCue.DmxCue.get_outputs","title":"<code>get_outputs()</code>","text":"<p>Get the output routing configuration.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>The list of output configurations.</p> Source code in <code>src/cuemsutils/cues/DmxCue.py</code> <pre><code>def get_outputs(self):\n    \"\"\"Get the output routing configuration.\n\n    Returns:\n        list: The list of output configurations.\n    \"\"\"\n    return super().__getitem__('outputs')\n</code></pre>"},{"location":"cues/#cuemsutils.cues.DmxCue.DmxCue.items","title":"<code>items()</code>","text":"<p>Get all items in the cue as a dictionary.</p> <p>Returns:</p> Name Type Description <code>dict_items</code> <p>A view of the cue's items, with required items included.</p> Source code in <code>src/cuemsutils/cues/DmxCue.py</code> <pre><code>def items(self):\n    \"\"\"Get all items in the cue as a dictionary.\n\n    Returns:\n        dict_items: A view of the cue's items, with required items included.\n    \"\"\"\n    x = dict(super().items())\n    for k in REQ_ITEMS.keys():\n        x[k] = self[k]\n    return x.items()\n</code></pre>"},{"location":"cues/#cuemsutils.cues.DmxCue.DmxCue.offset_route","title":"<code>offset_route(offset_route)</code>","text":"<p>Set the offset route for DMX timing.</p> <p>Parameters:</p> Name Type Description Default <code>offset_route</code> <code>str</code> <p>The new offset route.</p> required Source code in <code>src/cuemsutils/cues/DmxCue.py</code> <pre><code>def offset_route(self, offset_route):\n    \"\"\"Set the offset route for DMX timing.\n\n    Args:\n        offset_route (str): The new offset route.\n    \"\"\"\n    self._offset_route = offset_route\n</code></pre>"},{"location":"cues/#cuemsutils.cues.DmxCue.DmxCue.osc_route","title":"<code>osc_route(osc_route)</code>","text":"<p>Set the OSC route for DMX control.</p> <p>Parameters:</p> Name Type Description Default <code>osc_route</code> <code>str</code> <p>The OSC route to use for DMX control.</p> required Source code in <code>src/cuemsutils/cues/DmxCue.py</code> <pre><code>def osc_route(self, osc_route):\n    \"\"\"Set the OSC route for DMX control.\n\n    Args:\n        osc_route (str): The OSC route to use for DMX control.\n    \"\"\"\n    self._osc_route = osc_route\n</code></pre>"},{"location":"cues/#cuemsutils.cues.DmxCue.DmxCue.player","title":"<code>player(player)</code>","text":"<p>Set the DMX player instance.</p> <p>Parameters:</p> Name Type Description Default <code>player</code> <p>The DMX player instance to use.</p> required Source code in <code>src/cuemsutils/cues/DmxCue.py</code> <pre><code>def player(self, player):\n    \"\"\"Set the DMX player instance.\n\n    Args:\n        player: The DMX player instance to use.\n    \"\"\"\n    self._player = player\n</code></pre>"},{"location":"cues/#cuemsutils.cues.DmxCue.DmxCue.review_offset","title":"<code>review_offset(timecode)</code>","text":"<p>Calculate the offset for DMX timing review.</p> <p>Parameters:</p> Name Type Description Default <code>timecode</code> <p>The timecode to calculate the offset from.</p> required <p>Returns:</p> Name Type Description <code>float</code> <p>The calculated offset in milliseconds.</p> Source code in <code>src/cuemsutils/cues/DmxCue.py</code> <pre><code>def review_offset(self, timecode):\n    \"\"\"Calculate the offset for DMX timing review.\n\n    Args:\n        timecode: The timecode to calculate the offset from.\n\n    Returns:\n        float: The calculated offset in milliseconds.\n    \"\"\"\n    return -(float(timecode.milliseconds))\n</code></pre>"},{"location":"cues/#cuemsutils.cues.DmxCue.DmxCue.set_DmxScene","title":"<code>set_DmxScene(dmxscene)</code>","text":"<p>Set the DMX scene for this cue.</p> <p>Parameters:</p> Name Type Description Default <code>dmxscene</code> <code>DmxScene or dict</code> <p>The new DMX scene or a dictionary to create one.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the scene type is not supported.</p> Source code in <code>src/cuemsutils/cues/DmxCue.py</code> <pre><code>def set_DmxScene(self, dmxscene):\n    \"\"\"Set the DMX scene for this cue.\n\n    Args:\n        dmxscene (DmxScene or dict): The new DMX scene or a dictionary to create one.\n\n    Raises:\n        NotImplementedError: If the scene type is not supported.\n    \"\"\"\n    if not isinstance(dmxscene, DmxScene):\n        dmxscene = DmxScene(dmxscene)\n    super().__setitem__('DmxScene', dmxscene)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.DmxCue.DmxCue.set_fadein_time","title":"<code>set_fadein_time(fadein_time)</code>","text":"<p>Set the fade-in time for the DMX cue.</p> <p>Parameters:</p> Name Type Description Default <code>fadein_time</code> <p>The new fade-in time value.</p> required Source code in <code>src/cuemsutils/cues/DmxCue.py</code> <pre><code>def set_fadein_time(self, fadein_time):\n    \"\"\"Set the fade-in time for the DMX cue.\n\n    Args:\n        fadein_time: The new fade-in time value.\n    \"\"\"\n    super().__setitem__('fadein_time', fadein_time)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.DmxCue.DmxCue.set_fadeout_time","title":"<code>set_fadeout_time(fadeout_time)</code>","text":"<p>Set the fade-out time for the DMX cue.</p> <p>Parameters:</p> Name Type Description Default <code>fadeout_time</code> <p>The new fade-out time value.</p> required Source code in <code>src/cuemsutils/cues/DmxCue.py</code> <pre><code>def set_fadeout_time(self, fadeout_time):\n    \"\"\"Set the fade-out time for the DMX cue.\n\n    Args:\n        fadeout_time: The new fade-out time value.\n    \"\"\"\n    super().__setitem__('fadeout_time', fadeout_time)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.DmxCue.DmxCue.set_outputs","title":"<code>set_outputs(outputs)</code>","text":"<p>Set the output routing configuration.</p> <p>Parameters:</p> Name Type Description Default <code>outputs</code> <code>list</code> <p>The list of output configurations. Each item can be a DmxCueOutput object or a dict that will be converted to DmxCueOutput.</p> required Source code in <code>src/cuemsutils/cues/DmxCue.py</code> <pre><code>def set_outputs(self, outputs):\n    \"\"\"Set the output routing configuration.\n\n    Args:\n        outputs (list): The list of output configurations. Each item can be\n            a DmxCueOutput object or a dict that will be converted to DmxCueOutput.\n    \"\"\"\n    if outputs is None:\n        super().__setitem__('outputs', None)\n        return\n\n    if not isinstance(outputs, list):\n        outputs = [outputs]\n\n    converted_outputs = []\n    for output in outputs:\n        if output is None:\n            continue\n        if not isinstance(output, DmxCueOutput):\n            if isinstance(output, dict):\n                if 'DmxCueOutput' in output:\n                    inner = output['DmxCueOutput']\n                    # XML converter may produce a list of dicts for the inner value\n                    if isinstance(inner, list):\n                        for item in inner:\n                            if isinstance(item, dict):\n                                converted_outputs.append(DmxCueOutput(item))\n                    elif isinstance(inner, dict):\n                        converted_outputs.append(DmxCueOutput(inner))\n                else:\n                    converted_outputs.append(DmxCueOutput(output))\n            else:\n                converted_outputs.append(output)\n        else:\n            converted_outputs.append(output)\n\n    super().__setitem__('outputs', converted_outputs)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.DmxCue.DmxScene","title":"<code>DmxScene</code>","text":"<p>               Bases: <code>CuemsDict</code></p> <p>A class representing a DMX scene containing multiple universes.</p> Source code in <code>src/cuemsutils/cues/DmxCue.py</code> <pre><code>class DmxScene(CuemsDict):\n    \"\"\"A class representing a DMX scene containing multiple universes.\"\"\"\n\n    def __init__(self, init_dict=None):\n        \"\"\"Initialize a DMX scene.\n\n        Args:\n            init_dict (dict, optional): Dictionary containing initialization values.\n                If provided, will be used to create DMX universes.\n        \"\"\"\n        if not init_dict:\n            init_dict = SCENE_REQ_ITEMS\n        else:\n            init_dict = ensure_items(init_dict, SCENE_REQ_ITEMS)\n        if init_dict:\n            self.setter(init_dict)\n\n    def get_id(self):\n        \"\"\"Get the scene ID.\n\n        Returns:\n            int: The scene ID.\n        \"\"\"\n        return super().__getitem__('id')\n\n    def set_id(self, scene_id):\n        \"\"\"Set the scene ID.\n\n        Args:\n            scene_id (int): The new scene ID.\n        \"\"\"\n        super().__setitem__('id', scene_id)\n    id = property(get_id, set_id)\n    def get_DmxUniverse(self):\n        \"\"\"Get a specific DMX universe.\n\n        Args:\n            num (int, optional): The universe number to get.\n                If None, returns None.\n\n        Returns:\n            DmxUniverse or None: The requested universe or None if not found.\n        \"\"\"\n        return super().__getitem__('DmxUniverse')\n\n\n\n    def set_DmxUniverse(self, universe):\n        \"\"\"Set a DMX universe at a specific number.\n\n        Args:\n            universe: The universe to set.\n            num (int, optional): The universe number. Defaults to 0.\n        \"\"\"\n        if not isinstance(universe, DmxUniverse):\n            universe = DmxUniverse(universe)\n        super().__setitem__('DmxUniverse', universe)\n\n    DmxUniverse = property(get_DmxUniverse, set_DmxUniverse)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.DmxCue.DmxScene.__init__","title":"<code>__init__(init_dict=None)</code>","text":"<p>Initialize a DMX scene.</p> <p>Parameters:</p> Name Type Description Default <code>init_dict</code> <code>dict</code> <p>Dictionary containing initialization values. If provided, will be used to create DMX universes.</p> <code>None</code> Source code in <code>src/cuemsutils/cues/DmxCue.py</code> <pre><code>def __init__(self, init_dict=None):\n    \"\"\"Initialize a DMX scene.\n\n    Args:\n        init_dict (dict, optional): Dictionary containing initialization values.\n            If provided, will be used to create DMX universes.\n    \"\"\"\n    if not init_dict:\n        init_dict = SCENE_REQ_ITEMS\n    else:\n        init_dict = ensure_items(init_dict, SCENE_REQ_ITEMS)\n    if init_dict:\n        self.setter(init_dict)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.DmxCue.DmxScene.get_DmxUniverse","title":"<code>get_DmxUniverse()</code>","text":"<p>Get a specific DMX universe.</p> <p>Parameters:</p> Name Type Description Default <code>num</code> <code>int</code> <p>The universe number to get. If None, returns None.</p> required <p>Returns:</p> Type Description <p>DmxUniverse or None: The requested universe or None if not found.</p> Source code in <code>src/cuemsutils/cues/DmxCue.py</code> <pre><code>def get_DmxUniverse(self):\n    \"\"\"Get a specific DMX universe.\n\n    Args:\n        num (int, optional): The universe number to get.\n            If None, returns None.\n\n    Returns:\n        DmxUniverse or None: The requested universe or None if not found.\n    \"\"\"\n    return super().__getitem__('DmxUniverse')\n</code></pre>"},{"location":"cues/#cuemsutils.cues.DmxCue.DmxScene.get_id","title":"<code>get_id()</code>","text":"<p>Get the scene ID.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>The scene ID.</p> Source code in <code>src/cuemsutils/cues/DmxCue.py</code> <pre><code>def get_id(self):\n    \"\"\"Get the scene ID.\n\n    Returns:\n        int: The scene ID.\n    \"\"\"\n    return super().__getitem__('id')\n</code></pre>"},{"location":"cues/#cuemsutils.cues.DmxCue.DmxScene.set_DmxUniverse","title":"<code>set_DmxUniverse(universe)</code>","text":"<p>Set a DMX universe at a specific number.</p> <p>Parameters:</p> Name Type Description Default <code>universe</code> <p>The universe to set.</p> required <code>num</code> <code>int</code> <p>The universe number. Defaults to 0.</p> required Source code in <code>src/cuemsutils/cues/DmxCue.py</code> <pre><code>def set_DmxUniverse(self, universe):\n    \"\"\"Set a DMX universe at a specific number.\n\n    Args:\n        universe: The universe to set.\n        num (int, optional): The universe number. Defaults to 0.\n    \"\"\"\n    if not isinstance(universe, DmxUniverse):\n        universe = DmxUniverse(universe)\n    super().__setitem__('DmxUniverse', universe)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.DmxCue.DmxScene.set_id","title":"<code>set_id(scene_id)</code>","text":"<p>Set the scene ID.</p> <p>Parameters:</p> Name Type Description Default <code>scene_id</code> <code>int</code> <p>The new scene ID.</p> required Source code in <code>src/cuemsutils/cues/DmxCue.py</code> <pre><code>def set_id(self, scene_id):\n    \"\"\"Set the scene ID.\n\n    Args:\n        scene_id (int): The new scene ID.\n    \"\"\"\n    super().__setitem__('id', scene_id)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.DmxCue.DmxUniverse","title":"<code>DmxUniverse</code>","text":"<p>               Bases: <code>CuemsDict</code></p> <p>A class representing a DMX universe containing multiple channels.</p> Source code in <code>src/cuemsutils/cues/DmxCue.py</code> <pre><code>class DmxUniverse(CuemsDict):\n    \"\"\"A class representing a DMX universe containing multiple channels.\"\"\"\n\n    def __init__(self, init_dict=None):\n        \"\"\"Initialize a DMX universe.\n\n        Args:\n            init_dict (dict, optional): Dictionary containing initialization values.\n                If provided, will be used to create DMX channels.\n        \"\"\"\n        if not init_dict:\n            init_dict = UNIVERSE_REQ_ITEMS\n        else:\n            init_dict = ensure_items(init_dict, UNIVERSE_REQ_ITEMS)\n        if init_dict:\n            self.setter(init_dict)\n\n    def get_universe_num(self):\n        \"\"\"Get the universe number.\n\n        Returns:\n            int: The universe number.\n        \"\"\"\n        return super().__getitem__('universe_num')\n\n    def set_universe_num(self, universe_num):\n        \"\"\"Set the universe number.\n\n        Args:\n            universe_num (int): The new universe number.\n        \"\"\"\n        super().__setitem__('universe_num', universe_num)\n    universe_num = property(get_universe_num, set_universe_num)\n\n    def get_dmx_channels(self):\n        \"\"\"Get the dmx channel for the scene.\n\n        Returns:\n            list: The list of dmx channels.\n        \"\"\"\n        return super().__getitem__('dmx_channels')\n\n    def set_dmx_channels(self, channels):\n        \"\"\"Set the output routing configuration.\n\n        Args:\n            channels (list): The list of output configurations.\n        \"\"\"\n        Logger.info(\"DmxUniverse set_channels called with channels: {}\".format(channels))\n        if not isinstance(channels, list):\n            channels = [channels]\n        channel_list = []\n        Logger.debug(f'Channels to process: {channels} Type: {type(channels)}')\n        try:\n            for r in channels:\n                    if r is not None:\n                        Logger.debug(f'Processing channel: {r}')\n                        if not isinstance(r, DmxChannel):\n                            Logger.debug(f\"Converting to DmxChannel: {r['DmxChannel']}\")\n                            new_dmxchannel = DmxChannel(r['DmxChannel'])\n                            channel_list.append(new_dmxchannel)\n                            super().__setitem__('dmx_channels', channel_list)\n                        else:\n                            super().__setitem__('dmx_channels', channels)\n        except Exception as e:\n            Logger.error(f\"Error converting channels to DmxChannel: {e}\")\n            super().__setitem__('dmx_channels', channels)\n\n\n    dmx_channels = property(get_dmx_channels, set_dmx_channels)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.DmxCue.DmxUniverse.__init__","title":"<code>__init__(init_dict=None)</code>","text":"<p>Initialize a DMX universe.</p> <p>Parameters:</p> Name Type Description Default <code>init_dict</code> <code>dict</code> <p>Dictionary containing initialization values. If provided, will be used to create DMX channels.</p> <code>None</code> Source code in <code>src/cuemsutils/cues/DmxCue.py</code> <pre><code>def __init__(self, init_dict=None):\n    \"\"\"Initialize a DMX universe.\n\n    Args:\n        init_dict (dict, optional): Dictionary containing initialization values.\n            If provided, will be used to create DMX channels.\n    \"\"\"\n    if not init_dict:\n        init_dict = UNIVERSE_REQ_ITEMS\n    else:\n        init_dict = ensure_items(init_dict, UNIVERSE_REQ_ITEMS)\n    if init_dict:\n        self.setter(init_dict)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.DmxCue.DmxUniverse.get_dmx_channels","title":"<code>get_dmx_channels()</code>","text":"<p>Get the dmx channel for the scene.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>The list of dmx channels.</p> Source code in <code>src/cuemsutils/cues/DmxCue.py</code> <pre><code>def get_dmx_channels(self):\n    \"\"\"Get the dmx channel for the scene.\n\n    Returns:\n        list: The list of dmx channels.\n    \"\"\"\n    return super().__getitem__('dmx_channels')\n</code></pre>"},{"location":"cues/#cuemsutils.cues.DmxCue.DmxUniverse.get_universe_num","title":"<code>get_universe_num()</code>","text":"<p>Get the universe number.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>The universe number.</p> Source code in <code>src/cuemsutils/cues/DmxCue.py</code> <pre><code>def get_universe_num(self):\n    \"\"\"Get the universe number.\n\n    Returns:\n        int: The universe number.\n    \"\"\"\n    return super().__getitem__('universe_num')\n</code></pre>"},{"location":"cues/#cuemsutils.cues.DmxCue.DmxUniverse.set_dmx_channels","title":"<code>set_dmx_channels(channels)</code>","text":"<p>Set the output routing configuration.</p> <p>Parameters:</p> Name Type Description Default <code>channels</code> <code>list</code> <p>The list of output configurations.</p> required Source code in <code>src/cuemsutils/cues/DmxCue.py</code> <pre><code>def set_dmx_channels(self, channels):\n    \"\"\"Set the output routing configuration.\n\n    Args:\n        channels (list): The list of output configurations.\n    \"\"\"\n    Logger.info(\"DmxUniverse set_channels called with channels: {}\".format(channels))\n    if not isinstance(channels, list):\n        channels = [channels]\n    channel_list = []\n    Logger.debug(f'Channels to process: {channels} Type: {type(channels)}')\n    try:\n        for r in channels:\n                if r is not None:\n                    Logger.debug(f'Processing channel: {r}')\n                    if not isinstance(r, DmxChannel):\n                        Logger.debug(f\"Converting to DmxChannel: {r['DmxChannel']}\")\n                        new_dmxchannel = DmxChannel(r['DmxChannel'])\n                        channel_list.append(new_dmxchannel)\n                        super().__setitem__('dmx_channels', channel_list)\n                    else:\n                        super().__setitem__('dmx_channels', channels)\n    except Exception as e:\n        Logger.error(f\"Error converting channels to DmxChannel: {e}\")\n        super().__setitem__('dmx_channels', channels)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.DmxCue.DmxUniverse.set_universe_num","title":"<code>set_universe_num(universe_num)</code>","text":"<p>Set the universe number.</p> <p>Parameters:</p> Name Type Description Default <code>universe_num</code> <code>int</code> <p>The new universe number.</p> required Source code in <code>src/cuemsutils/cues/DmxCue.py</code> <pre><code>def set_universe_num(self, universe_num):\n    \"\"\"Set the universe number.\n\n    Args:\n        universe_num (int): The new universe number.\n    \"\"\"\n    super().__setitem__('universe_num', universe_num)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.MediaCue.Media","title":"<code>Media</code>","text":"<p>               Bases: <code>CuemsDict</code></p> <p>A class representing a media file with associated regions.</p> Source code in <code>src/cuemsutils/cues/MediaCue.py</code> <pre><code>class Media(CuemsDict):\n    \"\"\"A class representing a media file with associated regions.\"\"\"\n\n    def __init__(self, init_dict = None):\n        \"\"\"Initialize a Media object.\n\n        Args:\n            init_dict (dict, optional): Dictionary containing initialization values.\n                If provided, will be used to set initial properties.\n        \"\"\"\n        if init_dict:\n            self.setter(init_dict)\n\n    def get_file_name(self):\n        \"\"\"Get the media file name.\n\n        Returns:\n            str: The name of the media file.\n        \"\"\"\n        return super().__getitem__('file_name')\n\n    def set_file_name(self, file_name):\n        \"\"\"Set the media file name.\n\n        Args:\n            file_name (str): The new media file name.\n        \"\"\"\n        super().__setitem__('file_name', file_name)\n\n    file_name = property(get_file_name, set_file_name)\n\n    def get_id(self):\n        \"\"\"Get the UUID of the media file.\n\n        Returns:\n            str: The UUID of the media file.\n        \"\"\"\n        return super().__getitem__('id')\n\n    def set_id(self, id):\n        \"\"\"Set the UUID of the media file.\n\n        Args:\n            id (str): The new UUID of the media file.\n        \"\"\"\n        id = Uuid(id)\n        super().__setitem__('id', id)\n\n    id = property(get_id, set_id)\n\n    def get_duration(self):\n        \"\"\"Get the duration of the media file.\n\n        Returns:\n            str: The duration of the media file.\n        \"\"\"\n        return super().__getitem__('duration')\n\n    def set_duration(self, duration):\n        \"\"\"Set the duration of the media file.\n\n        Args:\n            duration (str): The new duration of the media file.\n        \"\"\"\n        super().__setitem__('duration', duration)\n\n    duration = property(get_duration, set_duration)\n\n    def get_regions(self):\n        \"\"\"Get the list of regions in the media file.\n\n        Returns:\n            list: The list of Region objects.\n        \"\"\"\n        return super().__getitem__('regions')\n\n    def set_regions(self, regions):\n        \"\"\"Set the list of regions in the media file.\n\n        Args:\n            regions (list or Region): A list of regions or a single region.\n                If not already Region objects, they will be converted.\n        \"\"\"\n        if not isinstance(regions, list):\n            regions = [regions]\n        for r in regions:\n            if not isinstance(r, Region):\n                r = Region(r)\n        super().__setitem__('regions', regions)\n\n    regions: list[Region] = property(get_regions, set_regions)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.MediaCue.Media.__init__","title":"<code>__init__(init_dict=None)</code>","text":"<p>Initialize a Media object.</p> <p>Parameters:</p> Name Type Description Default <code>init_dict</code> <code>dict</code> <p>Dictionary containing initialization values. If provided, will be used to set initial properties.</p> <code>None</code> Source code in <code>src/cuemsutils/cues/MediaCue.py</code> <pre><code>def __init__(self, init_dict = None):\n    \"\"\"Initialize a Media object.\n\n    Args:\n        init_dict (dict, optional): Dictionary containing initialization values.\n            If provided, will be used to set initial properties.\n    \"\"\"\n    if init_dict:\n        self.setter(init_dict)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.MediaCue.Media.get_duration","title":"<code>get_duration()</code>","text":"<p>Get the duration of the media file.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>The duration of the media file.</p> Source code in <code>src/cuemsutils/cues/MediaCue.py</code> <pre><code>def get_duration(self):\n    \"\"\"Get the duration of the media file.\n\n    Returns:\n        str: The duration of the media file.\n    \"\"\"\n    return super().__getitem__('duration')\n</code></pre>"},{"location":"cues/#cuemsutils.cues.MediaCue.Media.get_file_name","title":"<code>get_file_name()</code>","text":"<p>Get the media file name.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>The name of the media file.</p> Source code in <code>src/cuemsutils/cues/MediaCue.py</code> <pre><code>def get_file_name(self):\n    \"\"\"Get the media file name.\n\n    Returns:\n        str: The name of the media file.\n    \"\"\"\n    return super().__getitem__('file_name')\n</code></pre>"},{"location":"cues/#cuemsutils.cues.MediaCue.Media.get_id","title":"<code>get_id()</code>","text":"<p>Get the UUID of the media file.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>The UUID of the media file.</p> Source code in <code>src/cuemsutils/cues/MediaCue.py</code> <pre><code>def get_id(self):\n    \"\"\"Get the UUID of the media file.\n\n    Returns:\n        str: The UUID of the media file.\n    \"\"\"\n    return super().__getitem__('id')\n</code></pre>"},{"location":"cues/#cuemsutils.cues.MediaCue.Media.get_regions","title":"<code>get_regions()</code>","text":"<p>Get the list of regions in the media file.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>The list of Region objects.</p> Source code in <code>src/cuemsutils/cues/MediaCue.py</code> <pre><code>def get_regions(self):\n    \"\"\"Get the list of regions in the media file.\n\n    Returns:\n        list: The list of Region objects.\n    \"\"\"\n    return super().__getitem__('regions')\n</code></pre>"},{"location":"cues/#cuemsutils.cues.MediaCue.Media.set_duration","title":"<code>set_duration(duration)</code>","text":"<p>Set the duration of the media file.</p> <p>Parameters:</p> Name Type Description Default <code>duration</code> <code>str</code> <p>The new duration of the media file.</p> required Source code in <code>src/cuemsutils/cues/MediaCue.py</code> <pre><code>def set_duration(self, duration):\n    \"\"\"Set the duration of the media file.\n\n    Args:\n        duration (str): The new duration of the media file.\n    \"\"\"\n    super().__setitem__('duration', duration)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.MediaCue.Media.set_file_name","title":"<code>set_file_name(file_name)</code>","text":"<p>Set the media file name.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>The new media file name.</p> required Source code in <code>src/cuemsutils/cues/MediaCue.py</code> <pre><code>def set_file_name(self, file_name):\n    \"\"\"Set the media file name.\n\n    Args:\n        file_name (str): The new media file name.\n    \"\"\"\n    super().__setitem__('file_name', file_name)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.MediaCue.Media.set_id","title":"<code>set_id(id)</code>","text":"<p>Set the UUID of the media file.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The new UUID of the media file.</p> required Source code in <code>src/cuemsutils/cues/MediaCue.py</code> <pre><code>def set_id(self, id):\n    \"\"\"Set the UUID of the media file.\n\n    Args:\n        id (str): The new UUID of the media file.\n    \"\"\"\n    id = Uuid(id)\n    super().__setitem__('id', id)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.MediaCue.Media.set_regions","title":"<code>set_regions(regions)</code>","text":"<p>Set the list of regions in the media file.</p> <p>Parameters:</p> Name Type Description Default <code>regions</code> <code>list or Region</code> <p>A list of regions or a single region. If not already Region objects, they will be converted.</p> required Source code in <code>src/cuemsutils/cues/MediaCue.py</code> <pre><code>def set_regions(self, regions):\n    \"\"\"Set the list of regions in the media file.\n\n    Args:\n        regions (list or Region): A list of regions or a single region.\n            If not already Region objects, they will be converted.\n    \"\"\"\n    if not isinstance(regions, list):\n        regions = [regions]\n    for r in regions:\n        if not isinstance(r, Region):\n            r = Region(r)\n    super().__setitem__('regions', regions)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.MediaCue.MediaCue","title":"<code>MediaCue</code>","text":"<p>               Bases: <code>Cue</code></p> <p>Base class for media-related cues (audio and video).</p> <p>This class extends Cue to provide common functionality for media playback, including media file handling and output routing.</p> Source code in <code>src/cuemsutils/cues/MediaCue.py</code> <pre><code>class MediaCue(Cue):\n    \"\"\"Base class for media-related cues (audio and video).\n\n    This class extends Cue to provide common functionality for media playback,\n    including media file handling and output routing.\n    \"\"\"\n\n    def __init__(self, init_dict = None):\n        \"\"\"Initialize a MediaCue.\n\n        Args:\n            init_dict (dict, optional): Dictionary containing initialization values.\n                If not provided, default values from REQ_ITEMS will be used.\n        \"\"\"\n        if not init_dict:\n            init_dict = REQ_ITEMS\n        else:\n            init_dict = ensure_items(init_dict, REQ_ITEMS)\n        super().__init__(init_dict)\n\n    def get_Media(self):\n        \"\"\"Get the media object associated with this cue.\n\n        Returns:\n            Media: The media object containing file and region information.\n        \"\"\"\n        return super().__getitem__('Media')\n\n    def set_Media(self, value):\n        \"\"\"Set the media object for this cue.\n\n        Args:\n            value (Media or dict): The media object or dictionary to create one.\n        \"\"\"\n        if not isinstance(value, Media):\n            value = Media(value)\n        super().__setitem__('Media', value)\n\n    media: Media = property(get_Media, set_Media)\n\n    def get_outputs(self):\n        \"\"\"Get the output routing configuration.\n\n        Returns:\n            list: The list of output configurations.\n        \"\"\"\n        return super().__getitem__('outputs')\n\n    def set_outputs(self, outputs):\n        \"\"\"Set the output routing configuration.\n\n        Args:\n            outputs (list): The list of output configurations.\n        \"\"\"\n        super().__setitem__('outputs', outputs)\n\n    outputs = property(get_outputs, set_outputs)\n\n    def get_all_output_names(self) -&gt; list[Tuple[str, str]]:\n        \"\"\"Get all output names splitted into node and output ids for the media cue.\n        Returns:\n            list: The list of output names.\n        \"\"\"\n        # DEV: To allow proper mapping, we need to split the output name into node and output ids.\n        # Additional logic in case mapping is developed and generalized output names (without node id) are used.\n        # e.g: [(None,'generalized_output_id'), ('node_uuid','output_id'), ...]\n        return [(output['output_name'][:36], output['output_name'][37:]) for output in self.outputs]\n\n    def localize_cue(self, node_id: str) -&gt; None:\n        \"\"\"Localize the cue outputs to the given node UUID.\n\n        Sets the _local attribute to True if any of the cue outputs are local to the given node UUID, False otherwise.\n\n        Args:\n            node_id: The ID of the node to localize the cue to.\n        \"\"\"\n        self._local = any(x[0] == node_id for x in self.get_all_output_names())\n\n\n    def items(self):\n        \"\"\"Get all items in the cue as a dictionary.\n\n        Returns:\n            dict_items: A view of the cue's items, with required items included.\n        \"\"\"\n        x = dict(super().items())\n        for k in REQ_ITEMS.keys():\n            x[k] = self[k]\n        return x.items()\n</code></pre>"},{"location":"cues/#cuemsutils.cues.MediaCue.MediaCue.__init__","title":"<code>__init__(init_dict=None)</code>","text":"<p>Initialize a MediaCue.</p> <p>Parameters:</p> Name Type Description Default <code>init_dict</code> <code>dict</code> <p>Dictionary containing initialization values. If not provided, default values from REQ_ITEMS will be used.</p> <code>None</code> Source code in <code>src/cuemsutils/cues/MediaCue.py</code> <pre><code>def __init__(self, init_dict = None):\n    \"\"\"Initialize a MediaCue.\n\n    Args:\n        init_dict (dict, optional): Dictionary containing initialization values.\n            If not provided, default values from REQ_ITEMS will be used.\n    \"\"\"\n    if not init_dict:\n        init_dict = REQ_ITEMS\n    else:\n        init_dict = ensure_items(init_dict, REQ_ITEMS)\n    super().__init__(init_dict)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.MediaCue.MediaCue.get_Media","title":"<code>get_Media()</code>","text":"<p>Get the media object associated with this cue.</p> <p>Returns:</p> Name Type Description <code>Media</code> <p>The media object containing file and region information.</p> Source code in <code>src/cuemsutils/cues/MediaCue.py</code> <pre><code>def get_Media(self):\n    \"\"\"Get the media object associated with this cue.\n\n    Returns:\n        Media: The media object containing file and region information.\n    \"\"\"\n    return super().__getitem__('Media')\n</code></pre>"},{"location":"cues/#cuemsutils.cues.MediaCue.MediaCue.get_all_output_names","title":"<code>get_all_output_names()</code>","text":"<p>Get all output names splitted into node and output ids for the media cue. Returns:     list: The list of output names.</p> Source code in <code>src/cuemsutils/cues/MediaCue.py</code> <pre><code>def get_all_output_names(self) -&gt; list[Tuple[str, str]]:\n    \"\"\"Get all output names splitted into node and output ids for the media cue.\n    Returns:\n        list: The list of output names.\n    \"\"\"\n    # DEV: To allow proper mapping, we need to split the output name into node and output ids.\n    # Additional logic in case mapping is developed and generalized output names (without node id) are used.\n    # e.g: [(None,'generalized_output_id'), ('node_uuid','output_id'), ...]\n    return [(output['output_name'][:36], output['output_name'][37:]) for output in self.outputs]\n</code></pre>"},{"location":"cues/#cuemsutils.cues.MediaCue.MediaCue.get_outputs","title":"<code>get_outputs()</code>","text":"<p>Get the output routing configuration.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>The list of output configurations.</p> Source code in <code>src/cuemsutils/cues/MediaCue.py</code> <pre><code>def get_outputs(self):\n    \"\"\"Get the output routing configuration.\n\n    Returns:\n        list: The list of output configurations.\n    \"\"\"\n    return super().__getitem__('outputs')\n</code></pre>"},{"location":"cues/#cuemsutils.cues.MediaCue.MediaCue.items","title":"<code>items()</code>","text":"<p>Get all items in the cue as a dictionary.</p> <p>Returns:</p> Name Type Description <code>dict_items</code> <p>A view of the cue's items, with required items included.</p> Source code in <code>src/cuemsutils/cues/MediaCue.py</code> <pre><code>def items(self):\n    \"\"\"Get all items in the cue as a dictionary.\n\n    Returns:\n        dict_items: A view of the cue's items, with required items included.\n    \"\"\"\n    x = dict(super().items())\n    for k in REQ_ITEMS.keys():\n        x[k] = self[k]\n    return x.items()\n</code></pre>"},{"location":"cues/#cuemsutils.cues.MediaCue.MediaCue.localize_cue","title":"<code>localize_cue(node_id)</code>","text":"<p>Localize the cue outputs to the given node UUID.</p> <p>Sets the _local attribute to True if any of the cue outputs are local to the given node UUID, False otherwise.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>str</code> <p>The ID of the node to localize the cue to.</p> required Source code in <code>src/cuemsutils/cues/MediaCue.py</code> <pre><code>def localize_cue(self, node_id: str) -&gt; None:\n    \"\"\"Localize the cue outputs to the given node UUID.\n\n    Sets the _local attribute to True if any of the cue outputs are local to the given node UUID, False otherwise.\n\n    Args:\n        node_id: The ID of the node to localize the cue to.\n    \"\"\"\n    self._local = any(x[0] == node_id for x in self.get_all_output_names())\n</code></pre>"},{"location":"cues/#cuemsutils.cues.MediaCue.MediaCue.set_Media","title":"<code>set_Media(value)</code>","text":"<p>Set the media object for this cue.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Media or dict</code> <p>The media object or dictionary to create one.</p> required Source code in <code>src/cuemsutils/cues/MediaCue.py</code> <pre><code>def set_Media(self, value):\n    \"\"\"Set the media object for this cue.\n\n    Args:\n        value (Media or dict): The media object or dictionary to create one.\n    \"\"\"\n    if not isinstance(value, Media):\n        value = Media(value)\n    super().__setitem__('Media', value)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.MediaCue.MediaCue.set_outputs","title":"<code>set_outputs(outputs)</code>","text":"<p>Set the output routing configuration.</p> <p>Parameters:</p> Name Type Description Default <code>outputs</code> <code>list</code> <p>The list of output configurations.</p> required Source code in <code>src/cuemsutils/cues/MediaCue.py</code> <pre><code>def set_outputs(self, outputs):\n    \"\"\"Set the output routing configuration.\n\n    Args:\n        outputs (list): The list of output configurations.\n    \"\"\"\n    super().__setitem__('outputs', outputs)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.MediaCue.Region","title":"<code>Region</code>","text":"<p>               Bases: <code>CuemsDict</code></p> <p>A class representing a region within a media file.</p> Source code in <code>src/cuemsutils/cues/MediaCue.py</code> <pre><code>class Region(CuemsDict):\n    \"\"\"A class representing a region within a media file.\"\"\"\n\n    def __init__(self, init_dict = None):\n        \"\"\"Initialize a Region.\n\n        Args:\n            init_dict (dict, optional): Dictionary containing initialization values.\n                If not provided, default values will be used.\n        \"\"\"\n        empty_keys= {\"id\": \"0\"}\n        if (init_dict):\n            self.setter(init_dict)\n        else:\n            self.setter(empty_keys)\n\n    def get_id(self):\n        \"\"\"Get the region ID.\n\n        Returns:\n            str: The region's identifier.\n        \"\"\"\n        return super().__getitem__('id')\n\n    def set_id(self, id):\n        \"\"\"Set the region ID.\n\n        Args:\n            id: The new region identifier.\n        \"\"\"\n        super().__setitem__('id', id)\n\n    id = property(get_id, set_id)\n\n    def get_loop(self):\n        \"\"\"Get the loop count for this region.\n\n        Returns:\n            int: The number of times the region should loop.\n        \"\"\"\n        return super().__getitem__('loop')\n\n    def set_loop(self, loop):\n        \"\"\"Set the loop count for this region.\n\n        Args:\n            loop (int): The number of times the region should loop.\n        \"\"\"\n        super().__setitem__('loop', loop)\n\n    loop = property(get_loop, set_loop)\n\n    def get_in_time(self):\n        \"\"\"Get the in point of the region.\n\n        Returns:\n            CTimecode: The timecode where the region starts.\n        \"\"\"\n        return super().__getitem__('in_time')\n\n    def set_in_time(self, in_time):\n        \"\"\"Set the in point of the region.\n\n        Args:\n            in_time: The new in point timecode.\n        \"\"\"\n        in_time = format_timecode(in_time)\n        super().__setitem__('in_time', in_time)\n\n    in_time = property(get_in_time, set_in_time)\n\n    def get_out_time(self):\n        \"\"\"Get the out point of the region.\n\n        Returns:\n            CTimecode: The timecode where the region ends.\n        \"\"\"\n        return super().__getitem__('out_time')\n\n    def set_out_time(self, out_time):\n        \"\"\"Set the out point of the region.\n\n        Args:\n            out_time: The new out point timecode.\n        \"\"\"\n        out_time = format_timecode(out_time)\n        super().__setitem__('out_time', out_time)\n\n    out_time = property(get_out_time, set_out_time)\n\n    def __json__(self):\n        \"\"\"Convert the region to a JSON-compatible dictionary.\n\n        Returns:\n            dict: A dictionary representation of the region.\n        \"\"\"\n        return {type(self).__name__: dict(self.items())}\n</code></pre>"},{"location":"cues/#cuemsutils.cues.MediaCue.Region.__init__","title":"<code>__init__(init_dict=None)</code>","text":"<p>Initialize a Region.</p> <p>Parameters:</p> Name Type Description Default <code>init_dict</code> <code>dict</code> <p>Dictionary containing initialization values. If not provided, default values will be used.</p> <code>None</code> Source code in <code>src/cuemsutils/cues/MediaCue.py</code> <pre><code>def __init__(self, init_dict = None):\n    \"\"\"Initialize a Region.\n\n    Args:\n        init_dict (dict, optional): Dictionary containing initialization values.\n            If not provided, default values will be used.\n    \"\"\"\n    empty_keys= {\"id\": \"0\"}\n    if (init_dict):\n        self.setter(init_dict)\n    else:\n        self.setter(empty_keys)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.MediaCue.Region.__json__","title":"<code>__json__()</code>","text":"<p>Convert the region to a JSON-compatible dictionary.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary representation of the region.</p> Source code in <code>src/cuemsutils/cues/MediaCue.py</code> <pre><code>def __json__(self):\n    \"\"\"Convert the region to a JSON-compatible dictionary.\n\n    Returns:\n        dict: A dictionary representation of the region.\n    \"\"\"\n    return {type(self).__name__: dict(self.items())}\n</code></pre>"},{"location":"cues/#cuemsutils.cues.MediaCue.Region.get_id","title":"<code>get_id()</code>","text":"<p>Get the region ID.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>The region's identifier.</p> Source code in <code>src/cuemsutils/cues/MediaCue.py</code> <pre><code>def get_id(self):\n    \"\"\"Get the region ID.\n\n    Returns:\n        str: The region's identifier.\n    \"\"\"\n    return super().__getitem__('id')\n</code></pre>"},{"location":"cues/#cuemsutils.cues.MediaCue.Region.get_in_time","title":"<code>get_in_time()</code>","text":"<p>Get the in point of the region.</p> <p>Returns:</p> Name Type Description <code>CTimecode</code> <p>The timecode where the region starts.</p> Source code in <code>src/cuemsutils/cues/MediaCue.py</code> <pre><code>def get_in_time(self):\n    \"\"\"Get the in point of the region.\n\n    Returns:\n        CTimecode: The timecode where the region starts.\n    \"\"\"\n    return super().__getitem__('in_time')\n</code></pre>"},{"location":"cues/#cuemsutils.cues.MediaCue.Region.get_loop","title":"<code>get_loop()</code>","text":"<p>Get the loop count for this region.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>The number of times the region should loop.</p> Source code in <code>src/cuemsutils/cues/MediaCue.py</code> <pre><code>def get_loop(self):\n    \"\"\"Get the loop count for this region.\n\n    Returns:\n        int: The number of times the region should loop.\n    \"\"\"\n    return super().__getitem__('loop')\n</code></pre>"},{"location":"cues/#cuemsutils.cues.MediaCue.Region.get_out_time","title":"<code>get_out_time()</code>","text":"<p>Get the out point of the region.</p> <p>Returns:</p> Name Type Description <code>CTimecode</code> <p>The timecode where the region ends.</p> Source code in <code>src/cuemsutils/cues/MediaCue.py</code> <pre><code>def get_out_time(self):\n    \"\"\"Get the out point of the region.\n\n    Returns:\n        CTimecode: The timecode where the region ends.\n    \"\"\"\n    return super().__getitem__('out_time')\n</code></pre>"},{"location":"cues/#cuemsutils.cues.MediaCue.Region.set_id","title":"<code>set_id(id)</code>","text":"<p>Set the region ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <p>The new region identifier.</p> required Source code in <code>src/cuemsutils/cues/MediaCue.py</code> <pre><code>def set_id(self, id):\n    \"\"\"Set the region ID.\n\n    Args:\n        id: The new region identifier.\n    \"\"\"\n    super().__setitem__('id', id)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.MediaCue.Region.set_in_time","title":"<code>set_in_time(in_time)</code>","text":"<p>Set the in point of the region.</p> <p>Parameters:</p> Name Type Description Default <code>in_time</code> <p>The new in point timecode.</p> required Source code in <code>src/cuemsutils/cues/MediaCue.py</code> <pre><code>def set_in_time(self, in_time):\n    \"\"\"Set the in point of the region.\n\n    Args:\n        in_time: The new in point timecode.\n    \"\"\"\n    in_time = format_timecode(in_time)\n    super().__setitem__('in_time', in_time)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.MediaCue.Region.set_loop","title":"<code>set_loop(loop)</code>","text":"<p>Set the loop count for this region.</p> <p>Parameters:</p> Name Type Description Default <code>loop</code> <code>int</code> <p>The number of times the region should loop.</p> required Source code in <code>src/cuemsutils/cues/MediaCue.py</code> <pre><code>def set_loop(self, loop):\n    \"\"\"Set the loop count for this region.\n\n    Args:\n        loop (int): The number of times the region should loop.\n    \"\"\"\n    super().__setitem__('loop', loop)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.MediaCue.Region.set_out_time","title":"<code>set_out_time(out_time)</code>","text":"<p>Set the out point of the region.</p> <p>Parameters:</p> Name Type Description Default <code>out_time</code> <p>The new out point timecode.</p> required Source code in <code>src/cuemsutils/cues/MediaCue.py</code> <pre><code>def set_out_time(self, out_time):\n    \"\"\"Set the out point of the region.\n\n    Args:\n        out_time: The new out point timecode.\n    \"\"\"\n    out_time = format_timecode(out_time)\n    super().__setitem__('out_time', out_time)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.VideoCue.VideoCue","title":"<code>VideoCue</code>","text":"<p>               Bases: <code>MediaCue</code></p> <p>A cue for handling video playback and control.</p> <p>This class extends MediaCue to provide specific functionality for video playback, including frame rate handling and OSC communication for video routing.</p> Source code in <code>src/cuemsutils/cues/VideoCue.py</code> <pre><code>class VideoCue(MediaCue):\n    \"\"\"A cue for handling video playback and control.\n\n    This class extends MediaCue to provide specific functionality for video playback,\n    including frame rate handling and OSC communication for video routing.\n    \"\"\"\n\n    def __init__(self, init_dict = None):\n        \"\"\"Initialize a VideoCue.\n\n        Args:\n            init_dict (dict, optional): Dictionary containing initialization values.\n                If provided, will be used to set initial properties.\n        \"\"\"\n        if not init_dict:\n            super().__init__()\n        else:\n            super().__init__(init_dict)\n\n        self._player = None\n        self._osc_route = None\n        self._go_thread = None\n\n        # TODO: Adjust framerates for universal use, by now 25 fps for video\n        self._start_mtc = CTimecode(framerate=25)\n        self._end_mtc = CTimecode(framerate=25)\n\n    def player(self, player):\n        \"\"\"Set the video player instance.\n\n        Args:\n            player: The video player instance to use.\n        \"\"\"\n        self._player = player\n\n    def osc_route(self, osc_route):\n        \"\"\"Set the OSC route for video control.\n\n        Args:\n            osc_route (str): The OSC route to use for video control.\n        \"\"\"\n        self._osc_route = osc_route\n\n    def items(self):\n        \"\"\"Get all items in the cue as a dictionary.\n\n        Returns:\n            dict_items: A view of the cue's items.\n        \"\"\"\n        x = dict(super().items())\n        return x.items()\n\n    @logged\n    @deprecated(\n        reason=\"Use loop_cue from CueHandler instead\",\n        version=\"0.0.9rc5\"\n    )\n    def video_media_loop(self, ossia, mtc):\n        \"\"\"Handle the video media playback loop.\n\n        This method manages the playback loop for video media, including handling\n        looping behavior, frame rate conversion, and OSC communication for timing control.\n\n        Args:\n            ossia: The OSC communication interface.\n            mtc: The MIDI Time Code interface.\n        \"\"\"\n        try:\n            loop_counter = 0\n            duration = self.media.regions[0].out_time - self.media.regions[0].in_time\n            duration = duration.return_in_other_framerate(mtc.main_tc.framerate)\n            in_time_adjusted = self.media.regions[0].in_time.return_in_other_framerate(mtc.main_tc.framerate)\n\n            while not self.media.regions[0].loop or loop_counter &lt; self.media.regions[0].loop:\n                while mtc.main_tc.milliseconds &lt; self._end_mtc.milliseconds:\n                    sleep(0.005)\n\n                if self._local:\n                    try:\n                        key = f'{self._osc_route}/jadeo/offset'\n                        self._start_mtc = mtc.main_tc\n                        self._end_mtc = self._start_mtc + duration\n                        offset_to_go = in_time_adjusted.frame_number - self._start_mtc.frame_number\n                        ossia.send_message(key, offset_to_go)\n                        Logger.info(\n                            key + \" \" + str(ossia._oscquery_registered_nodes[key][0].value),\n                            extra = {\"caller\": self.__class__.__name__}\n                        )\n                    except KeyError:\n                        Logger.debug(\n                            f'Key error 1 (offset) in go_callback {key}',\n                            extra = {\"caller\": self.__class__.__name__}\n                        )\n\n                loop_counter += 1\n\n            if self._local:\n                try:\n                    key = f'{self._osc_route}/jadeo/cmd'\n                    ossia.send_message(key, 'midi disconnect')\n                    Logger.info(\n                        key + \" \" + str(ossia._oscquery_registered_nodes[key][0].value),\n                        extra = {\"caller\": self.__class__.__name__}\n                    )\n                except KeyError:\n                    Logger.debug(\n                        f'Key error 1 (disconnect) in arm_callback {key}',\n                        extra = {\"caller\": self.__class__.__name__}\n                    )\n\n        except AttributeError:\n            pass\n\n    def stop(self):\n        \"\"\"Stop the video playback.\n\n        This method sets the stop request flag to halt video playback.\n        \"\"\"\n        self._stop_requested = True\n\n    def check_mappings(self, settings):\n        \"\"\"Check if the video output mappings are valid.\n\n        Args:\n            settings: The settings containing project node mappings.\n\n        Returns:\n            bool: True if the mappings are valid, False otherwise.\n        \"\"\"\n        return super().check_mappings()\n\n        if not settings.project_node_mappings:\n            return True\n\n        found = True\n        map_list = ['default']\n\n        # DEV: List first index is an artifact of the way the mappings are parsed\n        Logger.debug(f'VideoCue check_mappings: {settings.project_node_mappings}')\n        if settings.project_node_mappings['video'][0]['outputs']:\n            for elem in settings.project_node_mappings['video'][0]['outputs']:\n                elem = elem['output']\n                Logger.debug(f'VideoCue elem: {elem}')\n                for map in elem['mappings']:\n                    Logger.debug(f'VideoCue map: {map}')\n                    map_list.append(map['mapped_to'])\n\n        for output in self.outputs:\n            if output['output_name'][:36] == settings.node_conf['uuid']:\n                self._local = True\n                if output['output_name'][37:] not in map_list:\n                    found = False\n                    break\n            else:\n                self._local = False\n                found = True\n\n        return found\n</code></pre>"},{"location":"cues/#cuemsutils.cues.VideoCue.VideoCue.__init__","title":"<code>__init__(init_dict=None)</code>","text":"<p>Initialize a VideoCue.</p> <p>Parameters:</p> Name Type Description Default <code>init_dict</code> <code>dict</code> <p>Dictionary containing initialization values. If provided, will be used to set initial properties.</p> <code>None</code> Source code in <code>src/cuemsutils/cues/VideoCue.py</code> <pre><code>def __init__(self, init_dict = None):\n    \"\"\"Initialize a VideoCue.\n\n    Args:\n        init_dict (dict, optional): Dictionary containing initialization values.\n            If provided, will be used to set initial properties.\n    \"\"\"\n    if not init_dict:\n        super().__init__()\n    else:\n        super().__init__(init_dict)\n\n    self._player = None\n    self._osc_route = None\n    self._go_thread = None\n\n    # TODO: Adjust framerates for universal use, by now 25 fps for video\n    self._start_mtc = CTimecode(framerate=25)\n    self._end_mtc = CTimecode(framerate=25)\n</code></pre>"},{"location":"cues/#cuemsutils.cues.VideoCue.VideoCue.check_mappings","title":"<code>check_mappings(settings)</code>","text":"<p>Check if the video output mappings are valid.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <p>The settings containing project node mappings.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if the mappings are valid, False otherwise.</p> Source code in <code>src/cuemsutils/cues/VideoCue.py</code> <pre><code>def check_mappings(self, settings):\n    \"\"\"Check if the video output mappings are valid.\n\n    Args:\n        settings: The settings containing project node mappings.\n\n    Returns:\n        bool: True if the mappings are valid, False otherwise.\n    \"\"\"\n    return super().check_mappings()\n\n    if not settings.project_node_mappings:\n        return True\n\n    found = True\n    map_list = ['default']\n\n    # DEV: List first index is an artifact of the way the mappings are parsed\n    Logger.debug(f'VideoCue check_mappings: {settings.project_node_mappings}')\n    if settings.project_node_mappings['video'][0]['outputs']:\n        for elem in settings.project_node_mappings['video'][0]['outputs']:\n            elem = elem['output']\n            Logger.debug(f'VideoCue elem: {elem}')\n            for map in elem['mappings']:\n                Logger.debug(f'VideoCue map: {map}')\n                map_list.append(map['mapped_to'])\n\n    for output in self.outputs:\n        if output['output_name'][:36] == settings.node_conf['uuid']:\n            self._local = True\n            if output['output_name'][37:] not in map_list:\n                found = False\n                break\n        else:\n            self._local = False\n            found = True\n\n    return found\n</code></pre>"},{"location":"cues/#cuemsutils.cues.VideoCue.VideoCue.items","title":"<code>items()</code>","text":"<p>Get all items in the cue as a dictionary.</p> <p>Returns:</p> Name Type Description <code>dict_items</code> <p>A view of the cue's items.</p> Source code in <code>src/cuemsutils/cues/VideoCue.py</code> <pre><code>def items(self):\n    \"\"\"Get all items in the cue as a dictionary.\n\n    Returns:\n        dict_items: A view of the cue's items.\n    \"\"\"\n    x = dict(super().items())\n    return x.items()\n</code></pre>"},{"location":"cues/#cuemsutils.cues.VideoCue.VideoCue.osc_route","title":"<code>osc_route(osc_route)</code>","text":"<p>Set the OSC route for video control.</p> <p>Parameters:</p> Name Type Description Default <code>osc_route</code> <code>str</code> <p>The OSC route to use for video control.</p> required Source code in <code>src/cuemsutils/cues/VideoCue.py</code> <pre><code>def osc_route(self, osc_route):\n    \"\"\"Set the OSC route for video control.\n\n    Args:\n        osc_route (str): The OSC route to use for video control.\n    \"\"\"\n    self._osc_route = osc_route\n</code></pre>"},{"location":"cues/#cuemsutils.cues.VideoCue.VideoCue.player","title":"<code>player(player)</code>","text":"<p>Set the video player instance.</p> <p>Parameters:</p> Name Type Description Default <code>player</code> <p>The video player instance to use.</p> required Source code in <code>src/cuemsutils/cues/VideoCue.py</code> <pre><code>def player(self, player):\n    \"\"\"Set the video player instance.\n\n    Args:\n        player: The video player instance to use.\n    \"\"\"\n    self._player = player\n</code></pre>"},{"location":"cues/#cuemsutils.cues.VideoCue.VideoCue.stop","title":"<code>stop()</code>","text":"<p>Stop the video playback.</p> <p>This method sets the stop request flag to halt video playback.</p> Source code in <code>src/cuemsutils/cues/VideoCue.py</code> <pre><code>def stop(self):\n    \"\"\"Stop the video playback.\n\n    This method sets the stop request flag to halt video playback.\n    \"\"\"\n    self._stop_requested = True\n</code></pre>"},{"location":"cues/#cuemsutils.cues.VideoCue.VideoCue.video_media_loop","title":"<code>video_media_loop(ossia, mtc)</code>","text":"<p>Handle the video media playback loop.</p> <p>This method manages the playback loop for video media, including handling looping behavior, frame rate conversion, and OSC communication for timing control.</p> <p>Parameters:</p> Name Type Description Default <code>ossia</code> <p>The OSC communication interface.</p> required <code>mtc</code> <p>The MIDI Time Code interface.</p> required Source code in <code>src/cuemsutils/cues/VideoCue.py</code> <pre><code>@logged\n@deprecated(\n    reason=\"Use loop_cue from CueHandler instead\",\n    version=\"0.0.9rc5\"\n)\ndef video_media_loop(self, ossia, mtc):\n    \"\"\"Handle the video media playback loop.\n\n    This method manages the playback loop for video media, including handling\n    looping behavior, frame rate conversion, and OSC communication for timing control.\n\n    Args:\n        ossia: The OSC communication interface.\n        mtc: The MIDI Time Code interface.\n    \"\"\"\n    try:\n        loop_counter = 0\n        duration = self.media.regions[0].out_time - self.media.regions[0].in_time\n        duration = duration.return_in_other_framerate(mtc.main_tc.framerate)\n        in_time_adjusted = self.media.regions[0].in_time.return_in_other_framerate(mtc.main_tc.framerate)\n\n        while not self.media.regions[0].loop or loop_counter &lt; self.media.regions[0].loop:\n            while mtc.main_tc.milliseconds &lt; self._end_mtc.milliseconds:\n                sleep(0.005)\n\n            if self._local:\n                try:\n                    key = f'{self._osc_route}/jadeo/offset'\n                    self._start_mtc = mtc.main_tc\n                    self._end_mtc = self._start_mtc + duration\n                    offset_to_go = in_time_adjusted.frame_number - self._start_mtc.frame_number\n                    ossia.send_message(key, offset_to_go)\n                    Logger.info(\n                        key + \" \" + str(ossia._oscquery_registered_nodes[key][0].value),\n                        extra = {\"caller\": self.__class__.__name__}\n                    )\n                except KeyError:\n                    Logger.debug(\n                        f'Key error 1 (offset) in go_callback {key}',\n                        extra = {\"caller\": self.__class__.__name__}\n                    )\n\n            loop_counter += 1\n\n        if self._local:\n            try:\n                key = f'{self._osc_route}/jadeo/cmd'\n                ossia.send_message(key, 'midi disconnect')\n                Logger.info(\n                    key + \" \" + str(ossia._oscquery_registered_nodes[key][0].value),\n                    extra = {\"caller\": self.__class__.__name__}\n                )\n            except KeyError:\n                Logger.debug(\n                    f'Key error 1 (disconnect) in arm_callback {key}',\n                    extra = {\"caller\": self.__class__.__name__}\n                )\n\n    except AttributeError:\n        pass\n</code></pre>"},{"location":"tools/","title":"API Documentation","text":""},{"location":"tools/#cuemsutils.tools.CommunicatorServices.Communicator","title":"<code>Communicator</code>","text":"<p>               Bases: <code>CommunicatorService</code></p> Source code in <code>src/cuemsutils/tools/CommunicatorServices.py</code> <pre><code>class Communicator(CommunicatorService):\n    def __init__(\n        self,\n        address:str,\n        communicator_service:CommunicatorService = NngRequestResponse,\n        requester_dials:bool = True\n    ):\n        \"\"\"\n        Initialize Communicator instance with address and communicator service.\n\n        Parameters:\n        - address (str): The address to connect or listen for connections.\n        - communicator_service (Callable[[str, bool], CommunicatorService]): The communicator service to use.\n        - requester_dials (bool): If True, the instance will dial the address. If False, it will listen for connections.\n        \"\"\"\n        try:\n            check_path(address)\n        except PermissionError as e:\n            Logger.error(e)\n            sys.exit(1)\n        except FileNotFoundError:\n            try:\n                check_path(address, dir_only = True)\n            except (NotADirectoryError, PermissionError) as e:\n                Logger.error(e)\n                sys.exit(1)\n\n        if address[0:6] != 'ipc://':\n            address = \"ipc://\" + address\n        self.address = address\n        self.requester_dials = requester_dials\n        self.communicator_service:CommunicatorService = communicator_service(self.address, requester_dials=self.requester_dials)\n\n    async def send_request(self, request):\n        response = await self.communicator_service.send_request(request)\n        return response\n\n    async def reply(self, request_processor):\n       await self.communicator_service.reply(request_processor)\n\n    async def responder_connect(self):\n        self._has_callable('responder_connect')\n        await self.communicator_service.responder_connect()\n\n    async def responder_get_request(self, callback):\n        self._has_callable('responder_get_request')\n        await self.communicator_service.responder_get_request(callback)\n\n    async def responder_post_reply(self, response, context): \n        self._has_callable('responder_post_reply')\n        await self.communicator_service.responder_post_reply(response, context)\n\n    def _has_callable(self, name):\n        \"\"\"Check if communicator_service has callable attribute of the given name\"\"\"\n        if not hasattr(self.communicator_service, name):\n            raise AttributeError(f\"{name} is not an attribute of {type(self.communicator_service)}\")\n        if not callable(getattr(self.communicator_service, name)):\n            raise AttributeError(f\"{name} is not a callable attribute of {type(self.communicator_service)}\")\n</code></pre>"},{"location":"tools/#cuemsutils.tools.CommunicatorServices.Communicator.__init__","title":"<code>__init__(address, communicator_service=NngRequestResponse, requester_dials=True)</code>","text":"<p>Initialize Communicator instance with address and communicator service.</p> <p>Parameters: - address (str): The address to connect or listen for connections. - communicator_service (Callable[[str, bool], CommunicatorService]): The communicator service to use. - requester_dials (bool): If True, the instance will dial the address. If False, it will listen for connections.</p> Source code in <code>src/cuemsutils/tools/CommunicatorServices.py</code> <pre><code>def __init__(\n    self,\n    address:str,\n    communicator_service:CommunicatorService = NngRequestResponse,\n    requester_dials:bool = True\n):\n    \"\"\"\n    Initialize Communicator instance with address and communicator service.\n\n    Parameters:\n    - address (str): The address to connect or listen for connections.\n    - communicator_service (Callable[[str, bool], CommunicatorService]): The communicator service to use.\n    - requester_dials (bool): If True, the instance will dial the address. If False, it will listen for connections.\n    \"\"\"\n    try:\n        check_path(address)\n    except PermissionError as e:\n        Logger.error(e)\n        sys.exit(1)\n    except FileNotFoundError:\n        try:\n            check_path(address, dir_only = True)\n        except (NotADirectoryError, PermissionError) as e:\n            Logger.error(e)\n            sys.exit(1)\n\n    if address[0:6] != 'ipc://':\n        address = \"ipc://\" + address\n    self.address = address\n    self.requester_dials = requester_dials\n    self.communicator_service:CommunicatorService = communicator_service(self.address, requester_dials=self.requester_dials)\n</code></pre>"},{"location":"tools/#cuemsutils.tools.CommunicatorServices.CommunicatorService","title":"<code>CommunicatorService</code>","text":"<p>               Bases: <code>ABC</code></p> Source code in <code>src/cuemsutils/tools/CommunicatorServices.py</code> <pre><code>class CommunicatorService(ABC):\n    @abstractmethod\n    def __init__(self, address:str):\n        self.address = address\n\n    @abstractmethod\n    def send_request(self, request:dict) -&gt; dict:\n        \"\"\" Send request dic and return response dict  \"\"\"\n\n    @abstractmethod\n    def reply(self, request_processor:Callable[[dict], dict]) -&gt; dict:\n        \"\"\" Get request, give it to request processor, and return the response from it  \"\"\"\n</code></pre>"},{"location":"tools/#cuemsutils.tools.CommunicatorServices.CommunicatorService.reply","title":"<code>reply(request_processor)</code>  <code>abstractmethod</code>","text":"<p>Get request, give it to request processor, and return the response from it</p> Source code in <code>src/cuemsutils/tools/CommunicatorServices.py</code> <pre><code>@abstractmethod\ndef reply(self, request_processor:Callable[[dict], dict]) -&gt; dict:\n    \"\"\" Get request, give it to request processor, and return the response from it  \"\"\"\n</code></pre>"},{"location":"tools/#cuemsutils.tools.CommunicatorServices.CommunicatorService.send_request","title":"<code>send_request(request)</code>  <code>abstractmethod</code>","text":"<p>Send request dic and return response dict</p> Source code in <code>src/cuemsutils/tools/CommunicatorServices.py</code> <pre><code>@abstractmethod\ndef send_request(self, request:dict) -&gt; dict:\n    \"\"\" Send request dic and return response dict  \"\"\"\n</code></pre>"},{"location":"tools/#cuemsutils.tools.CommunicatorServices.IpcAddress","title":"<code>IpcAddress</code>","text":"<p>               Bases: <code>Enum</code></p> <p>IPC addresses for the different services</p> Source code in <code>src/cuemsutils/tools/CommunicatorServices.py</code> <pre><code>class IpcAddress(Enum):\n    \"\"\" IPC addresses for the different services \"\"\"\n    HWDISCOVERY = '/tmp/hwdiscovery.ipc'\n    NODECONF = '/tmp/nodeconf.ipc'\n    EDITOR = '/tmp/editor.ipc'\n</code></pre>"},{"location":"tools/#cuemsutils.tools.CommunicatorServices.NngRequestResponse","title":"<code>NngRequestResponse</code>","text":"<p>               Bases: <code>CommunicatorService</code></p> <p>Communicates over NNG (nanomsg) using a Request-Response protocol</p> Source code in <code>src/cuemsutils/tools/CommunicatorServices.py</code> <pre><code>class NngRequestResponse(CommunicatorService):\n    \"\"\" Communicates over NNG (nanomsg) using a Request-Response protocol\"\"\"\n    def __init__(self, address, requester_dials=True):\n        \"\"\"\n        Initialize NngRequestResponse instance with address and dialing/listening mode.\n\n        Parameters:\n        - address (str): The address to connect or listen for connections.\n        - requester_dials (bool, optional): If True, the instance requester will dial the address and replier will listen. If False, it will be the opposite way, requester listens and replier dials. Default is True.\n\n        The instance will set up the parameters for request and reply sockets based on the requester_dials value.\n        \"\"\"\n        self.address = address\n        if requester_dials:\n            self.params_request = {'dial': self.address}\n            self.params_reply = {'listen': self.address}\n        else: \n            self.params_request = {'listen': self.address}\n            self.params_reply = {'dial': self.address}\n\n    async def send_request(self, request):\n        \"\"\"\n        Send a request to the specified address and return the response.\n\n        Parameters:\n        - request (dict): The request to be sent. It should be a dictionary.\n\n        Returns:\n        - dict: The response received from the address. It will be a dictionary.\n        \"\"\"\n        try:\n            with Req0(**self.params_request) as socket:\n                while await asyncio.sleep(0, result=True):\n                    Logger.debug(f\"Sending: {request}\")\n                    encoded_request = json.dumps(request).encode()\n                    await socket.asend(encoded_request)\n                    response = await self._get_response(socket)\n                    decoded_response = json.loads(response.decode())\n                    Logger.debug(f\"receiving: {decoded_response}\")\n                    return decoded_response\n        except Exception as e:\n            Logger.error(f\"Error occurred while sending request: {e}\")\n            return None\n\n    async def _get_response(self, socket: Req0):\n        \"\"\"\n        Get the response from the socket.\n\n        Parameters:\n        - socket (Req0): The socket to get the response from.\n\n        Returns:\n        - bytes: The response from the socket.\n        \"\"\"\n        response = await socket.arecv()\n        return response\n\n    async def reply(self, request_processor):\n        \"\"\"\n        Asynchronously handle incoming requests and respond using the provided request processor.\n\n        This function sets up a Rep0 socket with parameters based on the instance's configuration.\n        It then enters a loop where it listens for incoming requests, processes them using the provided\n        request processor, and sends the response back to the requester.\n        Parameters:\n        - request_processor (Callable[[dict], dict]): A function that takes a request dictionary as input and returns a response dictionary.\n\n        Returns:\n        - None: This function is designed to run indefinitely, handling incoming requests and responses.\n        \"\"\"\n        try:\n            with Rep0(**self.params_reply) as socket:\n                while await asyncio.sleep(0, result=True):\n                    request = await socket.arecv()\n                    decoded_request = json.loads(request.decode())  # Parse the JSON request\n                    Logger.debug(f\"Received: {decoded_request}\")\n                    if asyncio.iscoroutinefunction(request_processor):\n                        response = await request_processor(decoded_request)\n                    else:\n                        loop = asyncio.get_event_loop()\n                        response = await loop.run_in_executor(None, partial(request_processor, decoded_request))\n                    await self._respond(socket, response)\n        except Exception as e:\n            Logger.error(f\"Error occurred while handling request: {e}\")\n\n    async def _respond(self, socket, response):\n        try:\n            encoded_response = json.dumps(response).encode()\n            Logger.debug(f\"Sending: {encoded_response}\")\n            await socket.asend(encoded_response)\n        except Exception as e:\n            Logger.error(f\"Error occurred while sending response: {e}\")\n\n    async def responder_connect(self):\n        self.responder = Rep0(**self.params_reply)\n\n    async def responder_get_request(self, callback):\n        try:\n            context = self.responder.new_context()\n            request = await context.arecv()\n            decoded_request = json.loads(request.decode())  # Parse the JSON request\n            Logger.debug(f\"Received: {decoded_request}\")\n            if asyncio.iscoroutinefunction(callback):\n                Logger.debug(f\"Calling callback function async\")\n                await callback(decoded_request, context)\n            else:\n                loop = asyncio.get_event_loop()\n                Logger.debug(f\"Calling sync callback function in executor\")\n                await loop.run_in_executor(None, partial(callback, decoded_request, context))\n        except Exception as e:\n            Logger.error(f\"Error occurred while handling request: {e}\")\n\n    async def responder_post_reply(self, response, context):\n        try:\n            await self._respond(context, response)\n        except Exception as e:\n            Logger.error(f\"Error occurred while sending response: {e}\")\n        finally:\n            context.close()\n</code></pre>"},{"location":"tools/#cuemsutils.tools.CommunicatorServices.NngRequestResponse.__init__","title":"<code>__init__(address, requester_dials=True)</code>","text":"<p>Initialize NngRequestResponse instance with address and dialing/listening mode.</p> <p>Parameters: - address (str): The address to connect or listen for connections. - requester_dials (bool, optional): If True, the instance requester will dial the address and replier will listen. If False, it will be the opposite way, requester listens and replier dials. Default is True.</p> <p>The instance will set up the parameters for request and reply sockets based on the requester_dials value.</p> Source code in <code>src/cuemsutils/tools/CommunicatorServices.py</code> <pre><code>def __init__(self, address, requester_dials=True):\n    \"\"\"\n    Initialize NngRequestResponse instance with address and dialing/listening mode.\n\n    Parameters:\n    - address (str): The address to connect or listen for connections.\n    - requester_dials (bool, optional): If True, the instance requester will dial the address and replier will listen. If False, it will be the opposite way, requester listens and replier dials. Default is True.\n\n    The instance will set up the parameters for request and reply sockets based on the requester_dials value.\n    \"\"\"\n    self.address = address\n    if requester_dials:\n        self.params_request = {'dial': self.address}\n        self.params_reply = {'listen': self.address}\n    else: \n        self.params_request = {'listen': self.address}\n        self.params_reply = {'dial': self.address}\n</code></pre>"},{"location":"tools/#cuemsutils.tools.CommunicatorServices.NngRequestResponse.reply","title":"<code>reply(request_processor)</code>  <code>async</code>","text":"<p>Asynchronously handle incoming requests and respond using the provided request processor.</p> <p>This function sets up a Rep0 socket with parameters based on the instance's configuration. It then enters a loop where it listens for incoming requests, processes them using the provided request processor, and sends the response back to the requester. Parameters: - request_processor (Callable[[dict], dict]): A function that takes a request dictionary as input and returns a response dictionary.</p> <p>Returns: - None: This function is designed to run indefinitely, handling incoming requests and responses.</p> Source code in <code>src/cuemsutils/tools/CommunicatorServices.py</code> <pre><code>async def reply(self, request_processor):\n    \"\"\"\n    Asynchronously handle incoming requests and respond using the provided request processor.\n\n    This function sets up a Rep0 socket with parameters based on the instance's configuration.\n    It then enters a loop where it listens for incoming requests, processes them using the provided\n    request processor, and sends the response back to the requester.\n    Parameters:\n    - request_processor (Callable[[dict], dict]): A function that takes a request dictionary as input and returns a response dictionary.\n\n    Returns:\n    - None: This function is designed to run indefinitely, handling incoming requests and responses.\n    \"\"\"\n    try:\n        with Rep0(**self.params_reply) as socket:\n            while await asyncio.sleep(0, result=True):\n                request = await socket.arecv()\n                decoded_request = json.loads(request.decode())  # Parse the JSON request\n                Logger.debug(f\"Received: {decoded_request}\")\n                if asyncio.iscoroutinefunction(request_processor):\n                    response = await request_processor(decoded_request)\n                else:\n                    loop = asyncio.get_event_loop()\n                    response = await loop.run_in_executor(None, partial(request_processor, decoded_request))\n                await self._respond(socket, response)\n    except Exception as e:\n        Logger.error(f\"Error occurred while handling request: {e}\")\n</code></pre>"},{"location":"tools/#cuemsutils.tools.CommunicatorServices.NngRequestResponse.send_request","title":"<code>send_request(request)</code>  <code>async</code>","text":"<p>Send a request to the specified address and return the response.</p> <p>Parameters: - request (dict): The request to be sent. It should be a dictionary.</p> <p>Returns: - dict: The response received from the address. It will be a dictionary.</p> Source code in <code>src/cuemsutils/tools/CommunicatorServices.py</code> <pre><code>async def send_request(self, request):\n    \"\"\"\n    Send a request to the specified address and return the response.\n\n    Parameters:\n    - request (dict): The request to be sent. It should be a dictionary.\n\n    Returns:\n    - dict: The response received from the address. It will be a dictionary.\n    \"\"\"\n    try:\n        with Req0(**self.params_request) as socket:\n            while await asyncio.sleep(0, result=True):\n                Logger.debug(f\"Sending: {request}\")\n                encoded_request = json.dumps(request).encode()\n                await socket.asend(encoded_request)\n                response = await self._get_response(socket)\n                decoded_response = json.loads(response.decode())\n                Logger.debug(f\"receiving: {decoded_response}\")\n                return decoded_response\n    except Exception as e:\n        Logger.error(f\"Error occurred while sending request: {e}\")\n        return None\n</code></pre>"},{"location":"tools/#cuemsutils.tools.ConfigBase.ConfigBase","title":"<code>ConfigBase</code>","text":"Source code in <code>src/cuemsutils/tools/ConfigBase.py</code> <pre><code>class ConfigBase():\n    def __init__(self, config_dir: str):\n        self.load_base_settings(config_dir)\n\n    @logged\n    def load_base_settings(self, base_dir: str):\n        try:\n            dir = environ['CUEMS_CONF_PATH']\n        except KeyError:\n            dir = base_dir\n        self.config_dir = dir\n\n        try:\n            settings = Settings(self.conf_path('settings.xml'))\n            self.settings = settings.get_dict()\n        except Exception as e:\n            Logger.exception(f'Exception catched while loading settings: {e}')\n            raise e\n\n    # HELPER FUNCTIONS #\n    def conf_path(self, file_name: str) -&gt; str:\n        \"\"\"\n        Returns the path to the configuration file.\n\n        Args:\n            file_name (str): The name of the file to be checked.\n\n        Returns:\n            str: The path to the configuration file.\n\n        Raises:\n            FileNotFoundError: If the configuration file does not exist.\n        \"\"\"\n        conf_path = path.join(self.config_dir, file_name)\n        if not path.exists(conf_path):\n            raise FileNotFoundError(f'Configuration file {conf_path} not found')\n        return conf_path\n\n    def set_dir_hierarchy(self) -&gt; None:\n        \"\"\"\n        Sets the directory hierarchy for the library path.\n        \"\"\"      \n        dirs = [\n            'projects',\n            'media',\n            path.join('media', 'waveforms'),\n            path.join('media', 'thumbnails')\n        ]\n        trash = [path.join('trash', i) for i in dirs]\n        dirs.extend(trash)\n\n        paths_to_check = [path.join(self.library_path, i) for i in dirs]\n        paths_to_check.append(self.tmp_path)\n\n        try:\n            for each_path in paths_to_check:\n                mkdir_recursive(each_path)\n        except Exception as e:\n            Logger.error(\"error: {} {}\".format(type(e), e))\n\n    # CLASS PROPERTIES #\n    @property\n    def config_dir(self):\n        return self._config_dir\n\n    @config_dir.setter\n    def config_dir(self, value: str):\n        if not path.exists(value):\n            raise FileNotFoundError(f'Configuration directory {value} not found')\n        self._config_dir = value\n\n    @property\n    def library_path(self):\n        return self.settings['library_path']\n\n    @property\n    def tmp_path(self):\n        return self.settings['tmp_path']\n\n    @property\n    def database_name(self):\n        return self.settings['database_name']\n\n    @property\n    def show_lock_file(self):\n        return self.settings['show_lock_file']\n\n    @property\n    def editor_url(self):\n        return self.settings['editor_url']\n\n    @property\n    def controller_url(self):\n        return self.settings['controller_url']\n\n    @property\n    def templates_path(self):\n        return self.settings['templates_path']\n\n    @property\n    def controller_interfaces_template(self):\n        return self.settings['controller_interfaces_template']\n\n    @property\n    def node_interfaces_template(self):\n        return self.settings['node_interfaces_template']\n\n    @property\n    def controller_lock_file(self):\n        return self.settings['controller_lock_file']\n\n    @property\n    def node_conf(self):\n        return self.settings['node']\n\n    @property\n    def node_uuid(self):\n        return self.node_conf['uuid']\n\n    @property\n    def host_name(self):\n        return f\"{self.node_uuid.split('-')[-1]}.local\"\n\n    @property\n    def node_url(self):\n        return f'http://{self.host_name}'\n\n    @property\n    def osc_initial_port(self):\n        return self.node_conf['osc_in_port_base']\n</code></pre>"},{"location":"tools/#cuemsutils.tools.ConfigBase.ConfigBase.conf_path","title":"<code>conf_path(file_name)</code>","text":"<p>Returns the path to the configuration file.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>The name of the file to be checked.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The path to the configuration file.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the configuration file does not exist.</p> Source code in <code>src/cuemsutils/tools/ConfigBase.py</code> <pre><code>def conf_path(self, file_name: str) -&gt; str:\n    \"\"\"\n    Returns the path to the configuration file.\n\n    Args:\n        file_name (str): The name of the file to be checked.\n\n    Returns:\n        str: The path to the configuration file.\n\n    Raises:\n        FileNotFoundError: If the configuration file does not exist.\n    \"\"\"\n    conf_path = path.join(self.config_dir, file_name)\n    if not path.exists(conf_path):\n        raise FileNotFoundError(f'Configuration file {conf_path} not found')\n    return conf_path\n</code></pre>"},{"location":"tools/#cuemsutils.tools.ConfigBase.ConfigBase.set_dir_hierarchy","title":"<code>set_dir_hierarchy()</code>","text":"<p>Sets the directory hierarchy for the library path.</p> Source code in <code>src/cuemsutils/tools/ConfigBase.py</code> <pre><code>def set_dir_hierarchy(self) -&gt; None:\n    \"\"\"\n    Sets the directory hierarchy for the library path.\n    \"\"\"      \n    dirs = [\n        'projects',\n        'media',\n        path.join('media', 'waveforms'),\n        path.join('media', 'thumbnails')\n    ]\n    trash = [path.join('trash', i) for i in dirs]\n    dirs.extend(trash)\n\n    paths_to_check = [path.join(self.library_path, i) for i in dirs]\n    paths_to_check.append(self.tmp_path)\n\n    try:\n        for each_path in paths_to_check:\n            mkdir_recursive(each_path)\n    except Exception as e:\n        Logger.error(\"error: {} {}\".format(type(e), e))\n</code></pre>"},{"location":"tools/#cuemsutils.tools.ConfigManager.ConfigManager","title":"<code>ConfigManager</code>","text":"<p>               Bases: <code>ConfigBase</code></p> Source code in <code>src/cuemsutils/tools/ConfigManager.py</code> <pre><code>class ConfigManager(ConfigBase):\n    def __init__(self, config_dir: str = CUEMS_CONF_PATH, load_all: bool = True):\n        \"\"\"\n        ConfigManager constructor.\n        This class is responsible for loading the configuration files and providing\n        the configuration data to the rest of the application.\n\n        It also provides methods to check the project files and to load them on demand.\n\n        If load_all is True, the configuration files will be loaded and the configuration\n        will be available for the rest of the application on object initialization.\n        If load_all is False, the configuration will be loaded on demand.\n\n        Base configuration directory is set to /etc/cuems/ by default.\n        If the environment variable CUEMS_CONF_PATH is set, it will be used instead.\n        If config_dir parameter is set, it will override the default value.\n\n        Specifically, base configuration directory precedence is:\n        - Environment variable CUEMS_CONF_PATH\n        - config_dir parameter\n        - /etc/cuems/ (i.e. CUEMS_CONF_PATH constant value) (default value)\n\n        Args:\n            config_dir (str): The directory containing the configuration files.\n            load_all (bool): Whether to load all the configuration files.\n\n        Raises:\n            Exception: If the configuration files are not found.\n        \"\"\"\n        # Initialize with default values\n        self.project_name = ''\n        self.using_default_mappings = False\n        self.network_map = {}\n        self.network_mappings = {}\n        self.node_mappings = {}\n        self.node_hw_outputs = {\n            'audio_inputs':[],\n            'audio_outputs':[],\n            'video_inputs':[],\n            'video_outputs':[],\n            'dmx_inputs':[],\n            'dmx_outputs':[]\n        }\n        super().__init__(config_dir)\n\n        if load_all:\n            self.load_config()\n\n    @property\n    def network_map(self):\n        return self._network_map\n\n    @network_map.setter\n    def network_map(self, value: dict[str, Any]):\n        self._network_map = value\n\n    @property\n    def node_network_map(self):\n        return self._node_network_map\n\n    @node_network_map.setter\n    def node_network_map(self, value: NetworkMap | dict):\n        if isinstance(value, NetworkMap):\n            self._node_network_map = value.get_node(self.node_uuid)\n        else:\n            self._node_network_map = value\n\n    @property\n    def mappings(self):\n        return self._mappings\n\n    @mappings.setter\n    def mappings(self, value: dict[str, Any]):\n        self._mappings = value\n\n    @property\n    def node_mappings(self):\n        return self._node_mappings\n\n    @node_mappings.setter\n    def node_mappings(self, value: ProjectMappings | dict[str, Any]):\n        if isinstance(value, ProjectMappings):\n            self._node_mappings = value.get_node(self.node_uuid)\n        else:\n            self._node_mappings = value\n\n    @logged\n    def load_config(self) -&gt; None:\n        \"\"\"\n        Loads the system configuration.\n        \"\"\"\n        # Initialize with empty values\n        self.network_map = {}\n        self.network_mappings = {}\n        self.node_mappings = {}\n        self.node_hw_outputs = {\n            'audio_inputs':[],\n            'audio_outputs':[],\n            'video_inputs':[],\n            'video_outputs':[],\n            'dmx_inputs':[],\n            'dmx_outputs':[]\n        }\n\n        self.set_dir_hierarchy()\n        self.load_network_map()\n        self.load_net_and_node_mappings()\n\n    def load_network_map(self):\n        \"\"\"\n        Loads the network map from the base configuration file.\n        \"\"\"\n        try:\n            netmap = NetworkMap(self.conf_path('network_map.xml'))\n            self.network_map = netmap.get_dict()\n            self.node_network_map = netmap\n        except Exception as e:\n            Logger.exception(f'Exception catched while loading network map: {e}')\n            raise e\n\n    def load_net_and_node_mappings(self):\n        \"\"\"\n        Loads the network and node mappings.\n        \"\"\"\n        try:\n            mappings_file = self.project_path(self.project_name, 'mappings.xml')\n        except FileNotFoundError as e:\n            mappings_file = self.conf_path('default_mappings.xml')\n\n        try:\n            project_mappings = ProjectMappings(mappings_file)\n            self.mappings = project_mappings.processed # type: ignore[attr-defined]\n        except Exception as e:\n            Logger.exception(f'Exception catched while loading mappings file: {e}')\n            raise e\n\n        self.node_mappings = project_mappings.get_node(self.node_conf['uuid'])\n        Logger.debug(f\"Node uuid is: {self.node_conf['uuid']}\")\n        # Select just output names for node_hw_outputs var\n        # e.g: node_hw_outputs[\"audio_outputs\"] = [\"system:playback_1\", \"system:playback_2\"]\n        for section, content in self.node_mappings.items():\n            if isinstance(content, list):\n                for port_type_dict in content:\n                    for port_types, port_type_list in port_type_dict.items():\n                        for port in port_type_list:\n                            for port_type, port_type_content in port.items():\n                                name = port_type_content['name']\n                                self.node_hw_outputs[section+'_'+port_types].append(name)\n\n        Logger.debug(f\"Node hardware outputs are: {self.node_hw_outputs}\")\n\n    @logged\n    def load_project_config(self, project_uname: str) -&gt; None:\n        \"\"\"\n        Loads the project configuration.\n\n        Args:\n            project_uname (str): The name of the project.\n        \"\"\"\n        ## Initialize with empty values\n        self.project_conf = {}\n        self.project_mappings = {}\n        self.project_node_mappings = {}\n        self.project_default_outputs = {}\n\n        self.project_name = project_uname\n\n        self.load_project_settings(project_uname)\n        self.load_project_mappings(project_uname)\n\n    def load_project_settings(self, project_uname: str):\n        \"\"\"\n        Loads the project settings from the project file.\n        \"\"\"\n        try:\n            settings_path = self.project_path(project_uname, 'settings.xml')\n            conf = ProjectSettings(\n                schema='project_settings',\n                xmlfile=settings_path\n            )\n        except FileNotFoundError as e:\n            Logger.info(\n                f'Project {project_uname} settings not found. Keeping default settings.'\n            )\n            return\n        except Exception as e:\n            Logger.exception(f'Exception in load_project_settings: {e}')\n            raise e\n\n        self.project_conf = conf.get_dict()\n        for key, value in self.project_conf.items():\n            corrected_dict = {}\n            if value:\n                for item in value:\n                    corrected_dict.update(item)\n                self.project_conf[key] = corrected_dict\n\n        Logger.info(f'Project {project_uname} settings loaded')\n\n    def load_project_mappings(self, project_uname: str):\n        \"\"\"\n        Loads the project mappings from the project file.\n        \"\"\"\n        try:\n            mappings_path = self.project_path(project_uname, 'mappings.xml')\n            project_mappings = ProjectMappings(mappings_path)\n            self.project_mappings = project_mappings.processed\n            try:\n                self.project_node_mappings = project_mappings.get_node(self.node_uuid)\n            except ValueError:\n                Logger.warning(\n                    f'No mappings assigned for this node in project {project_uname}'\n                )\n        except FileNotFoundError as e:\n            Logger.info(f'Project mappings not found. Adopting default mappings.')\n            self.project_mappings = self.mappings\n            self.project_node_mappings = self.node_mappings\n        except Exception as e:\n            Logger.exception(f'Exception in load_project_mappings: {e}')\n            raise e\n\n        self.number_of_nodes = int(self.mappings['number_of_nodes']) # type: ignore[index]\n        Logger.info(f'Project {project_uname} mappings loaded')\n\n    def get_video_output_id(self, mapping_name: str):\n        \"\"\"\n        Returns the video output id for the given mapping name.\n        \"\"\"\n        if mapping_name == 'default':\n            return self.node_conf['default_video_output']\n        else:\n            if 'outputs' in self.project_node_mappings['video'].keys():\n                for each_out in self.project_node_mappings['video']['outputs']:\n                    for each_map in each_out['mappings']:\n                        if mapping_name == each_map['mapped_to']:\n                            return each_out['name']\n\n        raise Exception(f'Video output wrongly mapped')\n\n    def get_audio_output_id(self, mapping_name: str):\n        \"\"\"\n        Returns the audio output id for the given mapping name.\n        \"\"\"\n        if mapping_name == 'default':\n            return self.node_conf['default_audio_output']\n        else:\n            for each_out in self.project_mappings['audio']['outputs']: # type: ignore[index]\n                for each_map in each_out[0]['mappings']:\n                    if mapping_name == each_map['mapped_to']:\n                        return each_out[0]['name']\n\n        raise Exception(f'Audio output wrongly mapped')\n\n    def check_project_mappings(self) -&gt; bool:\n        \"\"\"\n        Checks if the project mappings are correct.\n        \"\"\"\n        if self.using_default_mappings:\n            return True\n\n        nodes_to_check = [self.project_node_mappings]\n        for node in nodes_to_check:\n            for area, contents in node.items():\n                if isinstance(contents, dict):\n                    for section, elements in contents.items():\n                        for element in elements:\n                            if element['name'] not in self.node_hw_outputs[f'{area}_{section}']:\n                                err_str = f'Project {area} {section} mapping incorrect: {element[\"name\"]} not present in node: {self.node_conf[\"uuid\"]}'\n                                Logger.error(err_str)\n                                raise Exception(err_str)\n        return True\n\n    ## helper functions\n    def project_path(self, project_uname: str, file_name: str) -&gt; str:\n        \"\"\"\n        Returns the path to the project file if it exists.\n\n        Args:\n            project_uname (str): The name of the project.\n            file_name (str): The name of the file to be checked.\n\n        Returns:\n            str: The path to the project file.\n\n        Raises:\n            FileNotFoundError: If the project file does not exist.\n        \"\"\"\n        project_path = path.join(self.library_path, 'projects', project_uname, file_name)\n        if not path.exists(project_path):\n            raise FileNotFoundError(f'Project file {project_path} not found')\n        return project_path\n</code></pre>"},{"location":"tools/#cuemsutils.tools.ConfigManager.ConfigManager.__init__","title":"<code>__init__(config_dir=CUEMS_CONF_PATH, load_all=True)</code>","text":"<p>ConfigManager constructor. This class is responsible for loading the configuration files and providing the configuration data to the rest of the application.</p> <p>It also provides methods to check the project files and to load them on demand.</p> <p>If load_all is True, the configuration files will be loaded and the configuration will be available for the rest of the application on object initialization. If load_all is False, the configuration will be loaded on demand.</p> <p>Base configuration directory is set to /etc/cuems/ by default. If the environment variable CUEMS_CONF_PATH is set, it will be used instead. If config_dir parameter is set, it will override the default value.</p> <p>Specifically, base configuration directory precedence is: - Environment variable CUEMS_CONF_PATH - config_dir parameter - /etc/cuems/ (i.e. CUEMS_CONF_PATH constant value) (default value)</p> <p>Parameters:</p> Name Type Description Default <code>config_dir</code> <code>str</code> <p>The directory containing the configuration files.</p> <code>CUEMS_CONF_PATH</code> <code>load_all</code> <code>bool</code> <p>Whether to load all the configuration files.</p> <code>True</code> <p>Raises:</p> Type Description <code>Exception</code> <p>If the configuration files are not found.</p> Source code in <code>src/cuemsutils/tools/ConfigManager.py</code> <pre><code>def __init__(self, config_dir: str = CUEMS_CONF_PATH, load_all: bool = True):\n    \"\"\"\n    ConfigManager constructor.\n    This class is responsible for loading the configuration files and providing\n    the configuration data to the rest of the application.\n\n    It also provides methods to check the project files and to load them on demand.\n\n    If load_all is True, the configuration files will be loaded and the configuration\n    will be available for the rest of the application on object initialization.\n    If load_all is False, the configuration will be loaded on demand.\n\n    Base configuration directory is set to /etc/cuems/ by default.\n    If the environment variable CUEMS_CONF_PATH is set, it will be used instead.\n    If config_dir parameter is set, it will override the default value.\n\n    Specifically, base configuration directory precedence is:\n    - Environment variable CUEMS_CONF_PATH\n    - config_dir parameter\n    - /etc/cuems/ (i.e. CUEMS_CONF_PATH constant value) (default value)\n\n    Args:\n        config_dir (str): The directory containing the configuration files.\n        load_all (bool): Whether to load all the configuration files.\n\n    Raises:\n        Exception: If the configuration files are not found.\n    \"\"\"\n    # Initialize with default values\n    self.project_name = ''\n    self.using_default_mappings = False\n    self.network_map = {}\n    self.network_mappings = {}\n    self.node_mappings = {}\n    self.node_hw_outputs = {\n        'audio_inputs':[],\n        'audio_outputs':[],\n        'video_inputs':[],\n        'video_outputs':[],\n        'dmx_inputs':[],\n        'dmx_outputs':[]\n    }\n    super().__init__(config_dir)\n\n    if load_all:\n        self.load_config()\n</code></pre>"},{"location":"tools/#cuemsutils.tools.ConfigManager.ConfigManager.check_project_mappings","title":"<code>check_project_mappings()</code>","text":"<p>Checks if the project mappings are correct.</p> Source code in <code>src/cuemsutils/tools/ConfigManager.py</code> <pre><code>def check_project_mappings(self) -&gt; bool:\n    \"\"\"\n    Checks if the project mappings are correct.\n    \"\"\"\n    if self.using_default_mappings:\n        return True\n\n    nodes_to_check = [self.project_node_mappings]\n    for node in nodes_to_check:\n        for area, contents in node.items():\n            if isinstance(contents, dict):\n                for section, elements in contents.items():\n                    for element in elements:\n                        if element['name'] not in self.node_hw_outputs[f'{area}_{section}']:\n                            err_str = f'Project {area} {section} mapping incorrect: {element[\"name\"]} not present in node: {self.node_conf[\"uuid\"]}'\n                            Logger.error(err_str)\n                            raise Exception(err_str)\n    return True\n</code></pre>"},{"location":"tools/#cuemsutils.tools.ConfigManager.ConfigManager.get_audio_output_id","title":"<code>get_audio_output_id(mapping_name)</code>","text":"<p>Returns the audio output id for the given mapping name.</p> Source code in <code>src/cuemsutils/tools/ConfigManager.py</code> <pre><code>def get_audio_output_id(self, mapping_name: str):\n    \"\"\"\n    Returns the audio output id for the given mapping name.\n    \"\"\"\n    if mapping_name == 'default':\n        return self.node_conf['default_audio_output']\n    else:\n        for each_out in self.project_mappings['audio']['outputs']: # type: ignore[index]\n            for each_map in each_out[0]['mappings']:\n                if mapping_name == each_map['mapped_to']:\n                    return each_out[0]['name']\n\n    raise Exception(f'Audio output wrongly mapped')\n</code></pre>"},{"location":"tools/#cuemsutils.tools.ConfigManager.ConfigManager.get_video_output_id","title":"<code>get_video_output_id(mapping_name)</code>","text":"<p>Returns the video output id for the given mapping name.</p> Source code in <code>src/cuemsutils/tools/ConfigManager.py</code> <pre><code>def get_video_output_id(self, mapping_name: str):\n    \"\"\"\n    Returns the video output id for the given mapping name.\n    \"\"\"\n    if mapping_name == 'default':\n        return self.node_conf['default_video_output']\n    else:\n        if 'outputs' in self.project_node_mappings['video'].keys():\n            for each_out in self.project_node_mappings['video']['outputs']:\n                for each_map in each_out['mappings']:\n                    if mapping_name == each_map['mapped_to']:\n                        return each_out['name']\n\n    raise Exception(f'Video output wrongly mapped')\n</code></pre>"},{"location":"tools/#cuemsutils.tools.ConfigManager.ConfigManager.load_config","title":"<code>load_config()</code>","text":"<p>Loads the system configuration.</p> Source code in <code>src/cuemsutils/tools/ConfigManager.py</code> <pre><code>@logged\ndef load_config(self) -&gt; None:\n    \"\"\"\n    Loads the system configuration.\n    \"\"\"\n    # Initialize with empty values\n    self.network_map = {}\n    self.network_mappings = {}\n    self.node_mappings = {}\n    self.node_hw_outputs = {\n        'audio_inputs':[],\n        'audio_outputs':[],\n        'video_inputs':[],\n        'video_outputs':[],\n        'dmx_inputs':[],\n        'dmx_outputs':[]\n    }\n\n    self.set_dir_hierarchy()\n    self.load_network_map()\n    self.load_net_and_node_mappings()\n</code></pre>"},{"location":"tools/#cuemsutils.tools.ConfigManager.ConfigManager.load_net_and_node_mappings","title":"<code>load_net_and_node_mappings()</code>","text":"<p>Loads the network and node mappings.</p> Source code in <code>src/cuemsutils/tools/ConfigManager.py</code> <pre><code>def load_net_and_node_mappings(self):\n    \"\"\"\n    Loads the network and node mappings.\n    \"\"\"\n    try:\n        mappings_file = self.project_path(self.project_name, 'mappings.xml')\n    except FileNotFoundError as e:\n        mappings_file = self.conf_path('default_mappings.xml')\n\n    try:\n        project_mappings = ProjectMappings(mappings_file)\n        self.mappings = project_mappings.processed # type: ignore[attr-defined]\n    except Exception as e:\n        Logger.exception(f'Exception catched while loading mappings file: {e}')\n        raise e\n\n    self.node_mappings = project_mappings.get_node(self.node_conf['uuid'])\n    Logger.debug(f\"Node uuid is: {self.node_conf['uuid']}\")\n    # Select just output names for node_hw_outputs var\n    # e.g: node_hw_outputs[\"audio_outputs\"] = [\"system:playback_1\", \"system:playback_2\"]\n    for section, content in self.node_mappings.items():\n        if isinstance(content, list):\n            for port_type_dict in content:\n                for port_types, port_type_list in port_type_dict.items():\n                    for port in port_type_list:\n                        for port_type, port_type_content in port.items():\n                            name = port_type_content['name']\n                            self.node_hw_outputs[section+'_'+port_types].append(name)\n\n    Logger.debug(f\"Node hardware outputs are: {self.node_hw_outputs}\")\n</code></pre>"},{"location":"tools/#cuemsutils.tools.ConfigManager.ConfigManager.load_network_map","title":"<code>load_network_map()</code>","text":"<p>Loads the network map from the base configuration file.</p> Source code in <code>src/cuemsutils/tools/ConfigManager.py</code> <pre><code>def load_network_map(self):\n    \"\"\"\n    Loads the network map from the base configuration file.\n    \"\"\"\n    try:\n        netmap = NetworkMap(self.conf_path('network_map.xml'))\n        self.network_map = netmap.get_dict()\n        self.node_network_map = netmap\n    except Exception as e:\n        Logger.exception(f'Exception catched while loading network map: {e}')\n        raise e\n</code></pre>"},{"location":"tools/#cuemsutils.tools.ConfigManager.ConfigManager.load_project_config","title":"<code>load_project_config(project_uname)</code>","text":"<p>Loads the project configuration.</p> <p>Parameters:</p> Name Type Description Default <code>project_uname</code> <code>str</code> <p>The name of the project.</p> required Source code in <code>src/cuemsutils/tools/ConfigManager.py</code> <pre><code>@logged\ndef load_project_config(self, project_uname: str) -&gt; None:\n    \"\"\"\n    Loads the project configuration.\n\n    Args:\n        project_uname (str): The name of the project.\n    \"\"\"\n    ## Initialize with empty values\n    self.project_conf = {}\n    self.project_mappings = {}\n    self.project_node_mappings = {}\n    self.project_default_outputs = {}\n\n    self.project_name = project_uname\n\n    self.load_project_settings(project_uname)\n    self.load_project_mappings(project_uname)\n</code></pre>"},{"location":"tools/#cuemsutils.tools.ConfigManager.ConfigManager.load_project_mappings","title":"<code>load_project_mappings(project_uname)</code>","text":"<p>Loads the project mappings from the project file.</p> Source code in <code>src/cuemsutils/tools/ConfigManager.py</code> <pre><code>def load_project_mappings(self, project_uname: str):\n    \"\"\"\n    Loads the project mappings from the project file.\n    \"\"\"\n    try:\n        mappings_path = self.project_path(project_uname, 'mappings.xml')\n        project_mappings = ProjectMappings(mappings_path)\n        self.project_mappings = project_mappings.processed\n        try:\n            self.project_node_mappings = project_mappings.get_node(self.node_uuid)\n        except ValueError:\n            Logger.warning(\n                f'No mappings assigned for this node in project {project_uname}'\n            )\n    except FileNotFoundError as e:\n        Logger.info(f'Project mappings not found. Adopting default mappings.')\n        self.project_mappings = self.mappings\n        self.project_node_mappings = self.node_mappings\n    except Exception as e:\n        Logger.exception(f'Exception in load_project_mappings: {e}')\n        raise e\n\n    self.number_of_nodes = int(self.mappings['number_of_nodes']) # type: ignore[index]\n    Logger.info(f'Project {project_uname} mappings loaded')\n</code></pre>"},{"location":"tools/#cuemsutils.tools.ConfigManager.ConfigManager.load_project_settings","title":"<code>load_project_settings(project_uname)</code>","text":"<p>Loads the project settings from the project file.</p> Source code in <code>src/cuemsutils/tools/ConfigManager.py</code> <pre><code>def load_project_settings(self, project_uname: str):\n    \"\"\"\n    Loads the project settings from the project file.\n    \"\"\"\n    try:\n        settings_path = self.project_path(project_uname, 'settings.xml')\n        conf = ProjectSettings(\n            schema='project_settings',\n            xmlfile=settings_path\n        )\n    except FileNotFoundError as e:\n        Logger.info(\n            f'Project {project_uname} settings not found. Keeping default settings.'\n        )\n        return\n    except Exception as e:\n        Logger.exception(f'Exception in load_project_settings: {e}')\n        raise e\n\n    self.project_conf = conf.get_dict()\n    for key, value in self.project_conf.items():\n        corrected_dict = {}\n        if value:\n            for item in value:\n                corrected_dict.update(item)\n            self.project_conf[key] = corrected_dict\n\n    Logger.info(f'Project {project_uname} settings loaded')\n</code></pre>"},{"location":"tools/#cuemsutils.tools.ConfigManager.ConfigManager.project_path","title":"<code>project_path(project_uname, file_name)</code>","text":"<p>Returns the path to the project file if it exists.</p> <p>Parameters:</p> Name Type Description Default <code>project_uname</code> <code>str</code> <p>The name of the project.</p> required <code>file_name</code> <code>str</code> <p>The name of the file to be checked.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The path to the project file.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the project file does not exist.</p> Source code in <code>src/cuemsutils/tools/ConfigManager.py</code> <pre><code>def project_path(self, project_uname: str, file_name: str) -&gt; str:\n    \"\"\"\n    Returns the path to the project file if it exists.\n\n    Args:\n        project_uname (str): The name of the project.\n        file_name (str): The name of the file to be checked.\n\n    Returns:\n        str: The path to the project file.\n\n    Raises:\n        FileNotFoundError: If the project file does not exist.\n    \"\"\"\n    project_path = path.join(self.library_path, 'projects', project_uname, file_name)\n    if not path.exists(project_path):\n        raise FileNotFoundError(f'Project file {project_path} not found')\n    return project_path\n</code></pre>"},{"location":"tools/#cuemsutils.tools.CTimecode.CTimecode","title":"<code>CTimecode</code>","text":"<p>               Bases: <code>Timecode</code></p> Source code in <code>src/cuemsutils/tools/CTimecode.py</code> <pre><code>class CTimecode(Timecode):\n    def __init__(self, init_dict = None, start_timecode=None, start_seconds=None, frames=None, framerate: str | int = 'ms'):\n        if init_dict is not None:\n            super().__init__(framerate, init_dict, start_seconds, frames)\n        else:\n            if start_seconds == 0:\n                start_seconds = None\n                frames = None\n            super().__init__(framerate, start_timecode, start_seconds, frames)\n\n    @classmethod\n    def from_dict(cls, init_dict):\n        return cls(init_dict =  init_dict)\n\n    @property\n    def milliseconds(self):\n        \"\"\"returns time as milliseconds\n        \"\"\"\n        #TODO: float math for other framerates                               \n        millis_per_frame = 1000 / float(self.framerate)\n        return int(millis_per_frame * self.frame_number)\n\n    def return_in_other_framerate(self, framerate):\n        \"\"\"returns a copy of the object with a different framerate.\n        \"\"\"\n        new = CTimecode(framerate=framerate, start_seconds=float(self.milliseconds / 1000))\n        return new\n\n    def __hash__(self):\n        return hash((self.milliseconds, self.milliseconds))\n\n    def __eq__(self, other):\n        \"\"\"Compares seconds of tc\"\"\" #TODO: decide if we cheek framerate and frame equality or time equiality \n        if isinstance(other, CTimecode):\n            return self.milliseconds == other.milliseconds\n        return NotImplemented\n\n    def __ne__(self, other):\n        \"\"\"Compares seconds of tc\"\"\" #TODO: decide if we cheek framerate and frame equality or time equiality \n        if isinstance(other, CTimecode):\n            return self.milliseconds != other.milliseconds\n        return NotImplemented\n\n    def __lt__(self, other):\n        \"\"\"Compares seconds of tc\"\"\" #TODO: decide if we cheek framerate and frame equality or time equiality \n        if isinstance(other, CTimecode):\n            return self.milliseconds &lt; other.milliseconds\n        elif isinstance(other, int):\n            return self.milliseconds &lt; other\n        elif isinstance(other, type(None)):\n            return other\n\n        return NotImplemented\n\n    def __le__(self, other):\n        \"\"\"Compares seconds of tc\"\"\" #TODO: decide if we cheek framerate and frame equality or time equiality \n        if isinstance(other, CTimecode):\n            return self.milliseconds &lt;= other.milliseconds\n        elif isinstance(other, type(None)):\n            return other\n        return NotImplemented\n\n    def __gt__(self, other):\n        \"\"\"Compares seconds of tc\"\"\" #TODO: decide if we cheek framerate and frame equality or time equiality \n        if isinstance(other, CTimecode):\n            return self.milliseconds &gt; other.milliseconds\n        elif isinstance(other, int):\n            return self.milliseconds &gt; other\n        elif isinstance(other, type(None)):\n            return self \n        return NotImplemented\n\n    def __ge__(self, other):\n        \"\"\"Compares seconds of tc\"\"\" #TODO: decide if we cheek framerate and frame equality or time equiality \n        if isinstance(other, CTimecode):\n            return self.milliseconds &gt;= other.milliseconds\n        elif isinstance(other, type(None)):\n            return self\n        return NotImplemented\n\n    def __add__(self, other):\n        \"\"\"returns new CTimecode instance with the given timecode or frames\n        added to this one\n        \"\"\"\n        # duplicate current one\n        tc = CTimecode(framerate=self.framerate, frames=self.frames)\n\n        if isinstance(other, CTimecode):\n            tc.add_frames(other.frames)\n        elif isinstance(other, int):\n            tc.add_frames(other)\n        else:\n            raise CTimecodeError(\n                'Type %s not supported for arithmetic.' %\n                other.__class__.__name__\n            )\n\n        return tc\n\n    def __sub__(self, other):\n        \"\"\"returns new CTimecode instance with subtracted value\"\"\"\n        if isinstance(other, CTimecode):\n            subtracted_frames = self.frames - other.frames\n        elif isinstance(other, int):\n            subtracted_frames = self.frames - other\n        else:\n            raise CTimecodeError(\n                'Type %s not supported for arithmetic.' %\n                other.__class__.__name__\n            )\n\n        return CTimecode(framerate=self.framerate, frames=subtracted_frames)\n\n    def __mul__(self, other):\n        \"\"\"returns new CTimecode instance with multiplied value\"\"\"\n        if isinstance(other, CTimecode):\n            multiplied_frames = self.frames * other.frames\n        elif isinstance(other, int):\n            multiplied_frames = self.frames * other\n        else:\n            raise CTimecodeError(\n                'Type %s not supported for arithmetic.' %\n                other.__class__.__name__\n            )\n\n        return CTimecode(framerate=self.framerate, frames=multiplied_frames)\n\n    def __truediv__(self, other):\n        \"\"\"returns new CTimecode instance with divided value\"\"\"\n        if isinstance(other, CTimecode):\n            div_frames = self.frames / other.frames\n        elif isinstance(other, int):\n            div_frames = self.frames / other\n        else:\n            raise CTimecodeError(\n                'Type %s not supported for arithmetic.' %\n                other.__class__.__name__\n            )\n\n        return CTimecode(framerate=self.framerate, frames=div_frames)\n\n    def __json__(self):\n        return {'CTimecode': self.__str__()}\n\n    def __str__(self):\n        return self.tc_to_string(*self.frames_to_tc(self.frames))\n\n    def __iter__(self):\n        yield ('timecode', self.__str__())\n        yield ('framerate', self.framerate)\n\n    def items(self):\n        return ('CTimecode', self.__str__())\n</code></pre>"},{"location":"tools/#cuemsutils.tools.CTimecode.CTimecode.milliseconds","title":"<code>milliseconds</code>  <code>property</code>","text":"<p>returns time as milliseconds</p>"},{"location":"tools/#cuemsutils.tools.CTimecode.CTimecode.__add__","title":"<code>__add__(other)</code>","text":"<p>returns new CTimecode instance with the given timecode or frames added to this one</p> Source code in <code>src/cuemsutils/tools/CTimecode.py</code> <pre><code>def __add__(self, other):\n    \"\"\"returns new CTimecode instance with the given timecode or frames\n    added to this one\n    \"\"\"\n    # duplicate current one\n    tc = CTimecode(framerate=self.framerate, frames=self.frames)\n\n    if isinstance(other, CTimecode):\n        tc.add_frames(other.frames)\n    elif isinstance(other, int):\n        tc.add_frames(other)\n    else:\n        raise CTimecodeError(\n            'Type %s not supported for arithmetic.' %\n            other.__class__.__name__\n        )\n\n    return tc\n</code></pre>"},{"location":"tools/#cuemsutils.tools.CTimecode.CTimecode.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Compares seconds of tc</p> Source code in <code>src/cuemsutils/tools/CTimecode.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"Compares seconds of tc\"\"\" #TODO: decide if we cheek framerate and frame equality or time equiality \n    if isinstance(other, CTimecode):\n        return self.milliseconds == other.milliseconds\n    return NotImplemented\n</code></pre>"},{"location":"tools/#cuemsutils.tools.CTimecode.CTimecode.__ge__","title":"<code>__ge__(other)</code>","text":"<p>Compares seconds of tc</p> Source code in <code>src/cuemsutils/tools/CTimecode.py</code> <pre><code>def __ge__(self, other):\n    \"\"\"Compares seconds of tc\"\"\" #TODO: decide if we cheek framerate and frame equality or time equiality \n    if isinstance(other, CTimecode):\n        return self.milliseconds &gt;= other.milliseconds\n    elif isinstance(other, type(None)):\n        return self\n    return NotImplemented\n</code></pre>"},{"location":"tools/#cuemsutils.tools.CTimecode.CTimecode.__gt__","title":"<code>__gt__(other)</code>","text":"<p>Compares seconds of tc</p> Source code in <code>src/cuemsutils/tools/CTimecode.py</code> <pre><code>def __gt__(self, other):\n    \"\"\"Compares seconds of tc\"\"\" #TODO: decide if we cheek framerate and frame equality or time equiality \n    if isinstance(other, CTimecode):\n        return self.milliseconds &gt; other.milliseconds\n    elif isinstance(other, int):\n        return self.milliseconds &gt; other\n    elif isinstance(other, type(None)):\n        return self \n    return NotImplemented\n</code></pre>"},{"location":"tools/#cuemsutils.tools.CTimecode.CTimecode.__le__","title":"<code>__le__(other)</code>","text":"<p>Compares seconds of tc</p> Source code in <code>src/cuemsutils/tools/CTimecode.py</code> <pre><code>def __le__(self, other):\n    \"\"\"Compares seconds of tc\"\"\" #TODO: decide if we cheek framerate and frame equality or time equiality \n    if isinstance(other, CTimecode):\n        return self.milliseconds &lt;= other.milliseconds\n    elif isinstance(other, type(None)):\n        return other\n    return NotImplemented\n</code></pre>"},{"location":"tools/#cuemsutils.tools.CTimecode.CTimecode.__lt__","title":"<code>__lt__(other)</code>","text":"<p>Compares seconds of tc</p> Source code in <code>src/cuemsutils/tools/CTimecode.py</code> <pre><code>def __lt__(self, other):\n    \"\"\"Compares seconds of tc\"\"\" #TODO: decide if we cheek framerate and frame equality or time equiality \n    if isinstance(other, CTimecode):\n        return self.milliseconds &lt; other.milliseconds\n    elif isinstance(other, int):\n        return self.milliseconds &lt; other\n    elif isinstance(other, type(None)):\n        return other\n\n    return NotImplemented\n</code></pre>"},{"location":"tools/#cuemsutils.tools.CTimecode.CTimecode.__mul__","title":"<code>__mul__(other)</code>","text":"<p>returns new CTimecode instance with multiplied value</p> Source code in <code>src/cuemsutils/tools/CTimecode.py</code> <pre><code>def __mul__(self, other):\n    \"\"\"returns new CTimecode instance with multiplied value\"\"\"\n    if isinstance(other, CTimecode):\n        multiplied_frames = self.frames * other.frames\n    elif isinstance(other, int):\n        multiplied_frames = self.frames * other\n    else:\n        raise CTimecodeError(\n            'Type %s not supported for arithmetic.' %\n            other.__class__.__name__\n        )\n\n    return CTimecode(framerate=self.framerate, frames=multiplied_frames)\n</code></pre>"},{"location":"tools/#cuemsutils.tools.CTimecode.CTimecode.__ne__","title":"<code>__ne__(other)</code>","text":"<p>Compares seconds of tc</p> Source code in <code>src/cuemsutils/tools/CTimecode.py</code> <pre><code>def __ne__(self, other):\n    \"\"\"Compares seconds of tc\"\"\" #TODO: decide if we cheek framerate and frame equality or time equiality \n    if isinstance(other, CTimecode):\n        return self.milliseconds != other.milliseconds\n    return NotImplemented\n</code></pre>"},{"location":"tools/#cuemsutils.tools.CTimecode.CTimecode.__sub__","title":"<code>__sub__(other)</code>","text":"<p>returns new CTimecode instance with subtracted value</p> Source code in <code>src/cuemsutils/tools/CTimecode.py</code> <pre><code>def __sub__(self, other):\n    \"\"\"returns new CTimecode instance with subtracted value\"\"\"\n    if isinstance(other, CTimecode):\n        subtracted_frames = self.frames - other.frames\n    elif isinstance(other, int):\n        subtracted_frames = self.frames - other\n    else:\n        raise CTimecodeError(\n            'Type %s not supported for arithmetic.' %\n            other.__class__.__name__\n        )\n\n    return CTimecode(framerate=self.framerate, frames=subtracted_frames)\n</code></pre>"},{"location":"tools/#cuemsutils.tools.CTimecode.CTimecode.__truediv__","title":"<code>__truediv__(other)</code>","text":"<p>returns new CTimecode instance with divided value</p> Source code in <code>src/cuemsutils/tools/CTimecode.py</code> <pre><code>def __truediv__(self, other):\n    \"\"\"returns new CTimecode instance with divided value\"\"\"\n    if isinstance(other, CTimecode):\n        div_frames = self.frames / other.frames\n    elif isinstance(other, int):\n        div_frames = self.frames / other\n    else:\n        raise CTimecodeError(\n            'Type %s not supported for arithmetic.' %\n            other.__class__.__name__\n        )\n\n    return CTimecode(framerate=self.framerate, frames=div_frames)\n</code></pre>"},{"location":"tools/#cuemsutils.tools.CTimecode.CTimecode.return_in_other_framerate","title":"<code>return_in_other_framerate(framerate)</code>","text":"<p>returns a copy of the object with a different framerate.</p> Source code in <code>src/cuemsutils/tools/CTimecode.py</code> <pre><code>def return_in_other_framerate(self, framerate):\n    \"\"\"returns a copy of the object with a different framerate.\n    \"\"\"\n    new = CTimecode(framerate=framerate, start_seconds=float(self.milliseconds / 1000))\n    return new\n</code></pre>"},{"location":"tools/#cuemsutils.tools.CTimecode.CTimecodeError","title":"<code>CTimecodeError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when an error occurred in timecode calculation</p> Source code in <code>src/cuemsutils/tools/CTimecode.py</code> <pre><code>class CTimecodeError(Exception):\n    \"\"\"Raised when an error occurred in timecode calculation\n    \"\"\"\n    pass\n</code></pre>"},{"location":"tools/#cuemsutils.tools.HubServices.ConnectionInfo","title":"<code>ConnectionInfo</code>  <code>dataclass</code>","text":"<p>Information about an active bus connection.</p> Source code in <code>src/cuemsutils/tools/HubServices.py</code> <pre><code>@dataclass\nclass ConnectionInfo:\n    \"\"\"Information about an active bus connection.\"\"\"\n    pipe_id: int\n    sender: str\n    connected_at: datetime\n</code></pre>"},{"location":"tools/#cuemsutils.tools.HubServices.HubService","title":"<code>HubService</code>","text":"<p>               Bases: <code>ABC</code></p> Source code in <code>src/cuemsutils/tools/HubServices.py</code> <pre><code>class HubService(ABC):\n    @abstractmethod\n    def __init__(self, address:str):\n        self.address = address\n\n    @abstractmethod\n    def send_message(self, message: dict | Message) -&gt; None:\n        \"\"\" Add message (dict or Message) to the queue to be sent to hub \"\"\"\n\n    @abstractmethod\n    def get_message(self) -&gt; Message:\n        \"\"\" Get message from the queue. Message.data is already JSON-decoded as dict \"\"\"\n</code></pre>"},{"location":"tools/#cuemsutils.tools.HubServices.HubService.get_message","title":"<code>get_message()</code>  <code>abstractmethod</code>","text":"<p>Get message from the queue. Message.data is already JSON-decoded as dict</p> Source code in <code>src/cuemsutils/tools/HubServices.py</code> <pre><code>@abstractmethod\ndef get_message(self) -&gt; Message:\n    \"\"\" Get message from the queue. Message.data is already JSON-decoded as dict \"\"\"\n</code></pre>"},{"location":"tools/#cuemsutils.tools.HubServices.HubService.send_message","title":"<code>send_message(message)</code>  <code>abstractmethod</code>","text":"<p>Add message (dict or Message) to the queue to be sent to hub</p> Source code in <code>src/cuemsutils/tools/HubServices.py</code> <pre><code>@abstractmethod\ndef send_message(self, message: dict | Message) -&gt; None:\n    \"\"\" Add message (dict or Message) to the queue to be sent to hub \"\"\"\n</code></pre>"},{"location":"tools/#cuemsutils.tools.HubServices.NngBusHub","title":"<code>NngBusHub</code>","text":"<p>               Bases: <code>HubService</code></p> <p>Communicates over NNG (nanomsg) using Bus topology for many-to-one, one-to-many messaging</p> Source code in <code>src/cuemsutils/tools/HubServices.py</code> <pre><code>class NngBusHub(HubService):\n    \"\"\" Communicates over NNG (nanomsg) using Bus topology for many-to-one, one-to-many messaging \"\"\"\n\n    class Mode(Enum):\n        LISTENER = \"listen\"\n        DIALER = \"dial\"\n\n    def __init__(self, hub_address:str, mode:Mode):\n        \"\"\"\n        Initialize Nng_bus_hub instance with address and operational mode.\n\n        Parameters:\n        - hub_address (str): The address to connect or listen for bus connections.\n        - mode (Mode): The operational mode - LISTENER (listens) or DIALER (dials)\n\n        The instance will set up incoming and outgoing message queues for asynchronous message handling.\n        \"\"\"\n        self.active_connections: dict[int, ConnectionInfo] = {}  # pipe_id -&gt; ConnectionInfo\n        self.address = hub_address\n        self.mode = mode\n        self.incoming = asyncio.Queue()\n        self.outgoing = asyncio.Queue()\n\n        # Connection health tracking\n        self._last_message_received: Optional[datetime] = None\n        self._last_message_sent: Optional[datetime] = None\n        self._messages_received_count: int = 0\n        self._messages_sent_count: int = 0\n\n        # Ping/pong configuration\n        self._auto_ping_enabled: bool = False\n        self._auto_ping_interval: float = 10.0\n        self._auto_ping_task: Optional[asyncio.Task] = None\n        self._auto_pong_enabled: bool = True  # Nodes auto-respond by default\n        self._ping_count: int = 0\n        self._pong_count: int = 0\n\n    async def start(self):\n        \"\"\"\n        Start the bus communication by initializing the connection and launching message handlers.\n\n        This method starts the bus connection based on the mode (LISTENER or DIALER),\n        then launches infinite receiver and sender loops. It monitors both tasks and\n        exits when the first exception occurs or connection is broken, properly cleaning\n        up all running tasks.\n\n        Raises:\n        - ValueError: If an unknown mode is set.\n        - Exception: Re-raises any exception that occurs during task execution after cleanup.\n        \"\"\"\n        match self.mode:\n            case self.Mode.LISTENER:\n                await self.start_listener()\n            case self.Mode.DIALER:\n                await self.start_dialer()\n            case _:\n                raise ValueError(f\"Unknown mode: {self.mode}\")\n\n        try:\n            sender_task = asyncio.create_task(self._send_handler(), name=\"sender\")\n            receiver_task = asyncio.create_task(self._receiver_handler(), name=\"receiver\")\n            ping_task = asyncio.create_task(self._auto_ping_handler(), name=\"ping\")\n\n            tasks = [sender_task, receiver_task, ping_task]\n            task_names = {sender_task: \"sender\", receiver_task: \"receiver\", ping_task: \"ping\"}\n\n            Logger.info(f\"NNG {self.mode.value} tasks started: sender, receiver, ping\")\n\n            done_tasks, pending_tasks = await asyncio.wait(tasks, return_when=asyncio.FIRST_EXCEPTION)\n\n            # Check if completed task had an exception\n            for task in done_tasks:\n                task_name = task_names.get(task, \"unknown\")\n                if task.exception() is not None:\n                    Logger.error(f\"NNG {self.mode.value} {task_name} handler failed: {task.exception()}\")\n                    Logger.error(f\"Exception type: {type(task.exception()).__name__}\")\n                else:\n                    Logger.warning(f\"NNG {self.mode.value} {task_name} handler exited unexpectedly (no exception)\")\n\n            # Log pending task cancellation\n            pending_names = [task_names.get(t, \"unknown\") for t in pending_tasks]\n            if pending_names:\n                Logger.info(f\"Cancelling pending tasks: {pending_names}\")\n\n            # Cancel and await pending tasks\n            for task in pending_tasks:\n                task.cancel()\n                try:\n                    await task\n                except asyncio.CancelledError:\n                    pass\n\n            Logger.warning(f\"NNG {self.mode.value} start() exiting - all tasks terminated\")\n\n        except Exception as e:\n            Logger.error(f\"Error occurred while starting tasks: {e} type: {type(e)}\")\n            # Cancel any running tasks\n            for task in [sender_task, receiver_task, ping_task]:\n                if not task.done():\n                    task.cancel()\n                    try:\n                        await task\n                    except asyncio.CancelledError:\n                        pass\n            raise\n\n    async def start_listener(self):\n        \"\"\"\n        Initialize the bus connection in LISTENER mode (listening for connections).\n\n        Creates a Bus0 socket that listens on the configured address with a 100ms receive timeout.\n        TCP keepalive is enabled BEFORE listening to ensure it applies to all connections.\n        Callbacks are registered BEFORE listening to ensure no connection events are missed.\n        \"\"\"\n        # Create socket first, set options and callbacks, then listen\n        self.connection = Bus0(recv_timeout=RECV_TIMEOUT)\n        self.connection.tcp_keepalive = True\n        self._add_callbacks()  # Register callbacks BEFORE listen to catch all events\n        self.connection.listen(self.address)\n        Logger.debug(f\"LISTENER started on {self.address}, tcp_keepalive={self.connection.tcp_keepalive}\")\n\n    async def start_dialer(self):\n        \"\"\"\n        Initialize the bus connection in DIALER mode (dialing to controller).\n\n        Creates a Bus0 socket that dials to the configured address with a 100ms receive timeout.\n        TCP keepalive is enabled BEFORE dialing to ensure it applies to the connection.\n        Non-blocking dial is used to allow reconnection if controller is not yet available.\n        Callbacks are registered BEFORE dialing to ensure no connection events are missed.\n        \"\"\"\n        # Create socket first, set options and callbacks, then dial (non-blocking for reconnection support)\n        self.connection = Bus0(recv_timeout=RECV_TIMEOUT)\n        self.connection.tcp_keepalive = True\n        # Set explicit reconnection parameters\n        self.connection.reconnect_time_min = 1000  # 1 second minimum\n        self.connection.reconnect_time_max = 30000  # 30 seconds maximum\n        self._add_callbacks()  # Register callbacks BEFORE dial to catch all events\n        Logger.debug(f\"DIALER options set: tcp_keepalive={self.connection.tcp_keepalive}, \" +\n                     f\"reconnect_time_min={self.connection.reconnect_time_min}ms, \" +\n                     f\"reconnect_time_max={self.connection.reconnect_time_max}ms\")\n        self.connection.dial(self.address, block=False)\n        Logger.debug(f\"DIALER dialing {self.address} (non-blocking)\")\n\n    async def send_message(self, message: dict | Message):\n        \"\"\"\n        Queue a message to be sent to the bus.\n\n        Parameters:\n        - message (dict | Message): The message to be sent. Must be a dict or Message object with dict data.\n\n        Raises:\n        - TypeError: If message is not a dict or Message object, or if Message.data is not a dict.\n\n        The message is JSON-encoded and placed in the outgoing queue to be sent by the sender handler.\n        \"\"\"\n        # Extract data from Message object or use raw data\n        if isinstance(message, Message):\n            data = message.data\n            if not isinstance(data, dict):\n                raise TypeError(f\"Message.data must be a dict, got {type(data).__name__}\")\n        elif isinstance(message, dict):\n            data = message\n        else:\n            raise TypeError(f\"send_message requires dict or Message, got {type(message).__name__}\")\n\n        # JSON-encode the dict\n        json_data = json.dumps(data)\n\n        await self.outgoing.put(json_data)\n\n    async def get_message(self) -&gt; Message:\n        \"\"\"\n        Retrieve a message from the incoming queue.\n\n        Returns:\n        - Message: The next message received from the bus. The `data` field is already JSON-decoded as a dict.\n                   This method blocks until a message is available.\n        \"\"\"\n        return await self.incoming.get()\n\n    def get_active_connections(self) -&gt; List[ConnectionInfo]:\n        \"\"\"\n        Get a list of all active connections.\n\n        Returns:\n        - List[ConnectionInfo]: List of all active connection information.\n        \"\"\"\n        return list(self.active_connections.values())\n\n    def get_connection_count(self) -&gt; int:\n        \"\"\"\n        Get the number of active connections.\n\n        Returns:\n        - int: Number of currently active connections.\n        \"\"\"\n        return len(self.active_connections)\n\n    def get_connection_health_info(self, activity_timeout: float = 30.0) -&gt; Dict:\n        \"\"\"\n        Get connection health information based on message activity.\n\n        This is particularly useful for DIALERs to check if they're still \n        connected to the controller, since nodes don't track the controller\n        connection in active_connections.\n\n        Parameters:\n        - activity_timeout: Seconds of inactivity before considering unhealthy (default: 30.0)\n\n        Returns:\n        - dict: Health information containing:\n            - is_healthy: bool - True if recent activity detected\n            - last_received: datetime or None - Last message received time\n            - last_sent: datetime or None - Last message sent time\n            - seconds_since_activity: float or None - Seconds since last activity\n            - messages_received: int - Total messages received\n            - messages_sent: int - Total messages sent\n        \"\"\"\n        now = datetime.now()\n        last_activity = None\n\n        # Determine most recent activity\n        if self._last_message_received and self._last_message_sent:\n            last_activity = max(self._last_message_received, self._last_message_sent)\n        elif self._last_message_received:\n            last_activity = self._last_message_received\n        elif self._last_message_sent:\n            last_activity = self._last_message_sent\n\n        # Calculate seconds since last activity\n        seconds_since_activity = None\n        if last_activity:\n            seconds_since_activity = (now - last_activity).total_seconds()\n\n        # Determine health status\n        is_healthy = False\n        if seconds_since_activity is not None:\n            is_healthy = seconds_since_activity &lt;= activity_timeout\n\n        return {\n            'is_healthy': is_healthy,\n            'last_received': self._last_message_received,\n            'last_sent': self._last_message_sent,\n            'seconds_since_activity': seconds_since_activity,\n            'messages_received': self._messages_received_count,\n            'messages_sent': self._messages_sent_count\n        }\n\n    def is_connection_healthy(self, activity_timeout: float = 30.0) -&gt; bool:\n        \"\"\"\n        Check if the connection is healthy based on recent activity.\n\n        Parameters:\n        - activity_timeout: Seconds of inactivity before considering unhealthy (default: 30.0)\n\n        Returns:\n        - bool: True if connection appears healthy\n        \"\"\"\n        return self.get_connection_health_info(activity_timeout)['is_healthy']\n\n    def enable_auto_ping(self, interval: float = 10.0, inactivity_threshold: float = 5.0):\n        \"\"\"\n        Enable automatic ping mechanism for the controller.\n\n        The controller will automatically send ping messages to all nodes if there's\n        been no activity for the specified threshold period. Nodes will automatically\n        respond with pong messages.\n\n        Parameters:\n        - interval: How often to check for inactive connections (default: 10.0 seconds)\n        - inactivity_threshold: Send ping if no activity for this many seconds (default: 5.0)\n\n        Note: This is primarily useful for LISTENER mode to verify node connections.\n        \"\"\"\n        self._auto_ping_enabled = True\n        self._auto_ping_interval = interval\n        self._inactivity_threshold = inactivity_threshold\n        Logger.info(f\"Auto-ping enabled: check every {interval}s, ping after {inactivity_threshold}s inactivity\")\n\n    def disable_auto_ping(self):\n        \"\"\"Disable automatic ping mechanism.\"\"\"\n        self._auto_ping_enabled = False\n        Logger.info(\"Auto-ping disabled\")\n\n    def enable_auto_pong(self):\n        \"\"\"Enable automatic pong responses (enabled by default).\"\"\"\n        self._auto_pong_enabled = True\n        Logger.debug(\"Auto-pong enabled\")\n\n    def disable_auto_pong(self):\n        \"\"\"Disable automatic pong responses.\"\"\"\n        self._auto_pong_enabled = False\n        Logger.debug(\"Auto-pong disabled\")\n\n    async def send_ping(self):\n        \"\"\"\n        Manually send a ping message to all connected nodes.\n\n        Returns:\n        - int: Number of pings sent\n        \"\"\"\n        ping_message = {\"__type__\": \"ping\", \"timestamp\": datetime.now().isoformat()}\n        await self.send_message(ping_message)\n        self._ping_count += 1\n        Logger.debug(f\"Ping sent (total: {self._ping_count})\")\n        return 1\n\n    async def _auto_ping_handler(self):\n        \"\"\"\n        Internal handler for automatic ping mechanism.\n\n        Periodically checks for inactive connections and sends pings if needed.\n        Only runs in LISTENER mode when auto_ping is enabled.\n        \"\"\"\n        if not hasattr(self, '_inactivity_threshold'):\n            self._inactivity_threshold = 5.0\n\n        while await asyncio.sleep(0, result=True):\n            try:\n                await asyncio.sleep(self._auto_ping_interval)\n\n                if not self._auto_ping_enabled:\n                    continue\n\n                # Check if we need to send a ping\n                now = datetime.now()\n                should_ping = False\n\n                if self._last_message_sent:\n                    seconds_since_last_sent = (now - self._last_message_sent).total_seconds()\n                    if seconds_since_last_sent &gt;= self._inactivity_threshold:\n                        should_ping = True\n                else:\n                    should_ping = True  # Never sent anything yet\n\n                if should_ping:\n                    Logger.debug(f\"Sending ping due to inactivity\")\n                    await self.send_ping()\n\n            except asyncio.CancelledError:\n                break\n            except Exception as e:\n                Logger.error(f\"Error in auto-ping handler: {e}\")\n\n    async def _receiver_handler(self):\n        \"\"\"\n        Internal handler that continuously receives messages from the bus.\n\n        This infinite loop listens for incoming messages on the bus connection and\n        places them in the incoming queue. Timeout exceptions are silently ignored\n        to allow continuous polling. Other exceptions are logged.\n\n        The loop runs until cancelled or an unhandled exception occurs.\n        \"\"\"\n        while await asyncio.sleep(0, result=True):\n            try:\n                pynng_message = await self.connection.arecv_msg()\n\n                # Extract sender information from the message pipe\n                sender = self._extract_sender_info(pynng_message.pipe)\n\n                # Decode bytes to string, then parse JSON to dict\n                decoded_string = pynng_message.bytes.decode()\n                try:\n                    data_dict = json.loads(decoded_string)\n                except json.JSONDecodeError:\n                    Logger.warning(f\"Received non-JSON message from {sender}: {decoded_string}\")\n                    data_dict = {\"raw_data\": decoded_string}\n\n                message = Message(data=data_dict, sender=sender)\n\n                # Track message receipt for connection health\n                self._last_message_received = datetime.now()\n                self._messages_received_count += 1\n\n                # DEBUG: Log every received message with count\n                msg_type = data_dict.get(\"__type__\", data_dict.get(\"type\", \"unknown\"))\n                Logger.debug(f\"[MSG #{self._messages_received_count}] {self.mode.value} received from {sender}: type={msg_type}\")\n\n                # Handle ping/pong messages\n                handled = await self._handle_ping_pong(message, sender)\n\n                if not handled:\n                    # Normal message - put in queue for user\n                    Logger.debug(f\"Received message from {sender}: {message.data}\")\n                    await self.incoming.put(message)\n\n            except pynng_exceptions.Timeout:\n                pass  # Timeout is expected during polling\n            except Exception as e:\n                Logger.error(f\"Error in receiver handler: {e}, type: {type(e)}\")\n\n    async def _handle_ping_pong(self, message: Message, sender) -&gt; bool:\n        \"\"\"\n        Handle ping/pong messages internally.\n\n        Parameters:\n        - message: The received message\n        - sender: The sender information\n\n        Returns:\n        - bool: True if message was handled (ping/pong), False if it's a normal message\n        \"\"\"\n        try:\n            # Data is already parsed as dict\n            data = message.data\n            message_type = data.get(\"__type__\")\n\n            if message_type == \"ping\":\n                # Received ping - send pong if auto-pong enabled\n                if self._auto_pong_enabled:\n                    pong_message = {\n                        \"__type__\": \"pong\",\n                        \"timestamp\": datetime.now().isoformat(),\n                        \"ping_timestamp\": data.get(\"timestamp\")\n                    }\n                    await self.send_message(pong_message)\n                    self._pong_count += 1\n                    Logger.debug(f\"Received ping from {sender}, sent pong (total pongs: {self._pong_count})\")\n                else:\n                    Logger.debug(f\"Received ping from {sender} (auto-pong disabled)\")\n                return True\n\n            elif message_type == \"pong\":\n                # Received pong response\n                Logger.debug(f\"Received pong from {sender}\")\n                return True\n\n        except (AttributeError, TypeError, KeyError):\n            # Doesn't have __type__ or invalid structure - treat as normal message\n            pass\n\n        return False\n\n    async def _send_handler(self):\n        \"\"\"\n        Internal handler that continuously sends messages to the bus.\n\n        This infinite loop retrieves messages from the outgoing queue and sends\n        them to the bus connection. Any exceptions during sending are logged.\n\n        The loop runs until cancelled or an unhandled exception occurs.\n\n        Note: In LISTENER mode, waits for at least one connection before sending\n        to avoid losing messages due to BUS protocol's best-effort delivery.\n        \"\"\"\n        # Wait for at least one connection in LISTENER mode before sending\n        if self.mode == self.Mode.LISTENER:\n            Logger.info(\"LISTENER mode: waiting for node connections before sending...\")\n            while len(self.active_connections) == 0:\n                await asyncio.sleep(0.1)\n            Logger.info(f\"Node connected, sender ready ({len(self.active_connections)} connections)\")\n\n        while await asyncio.sleep(0, result=True):\n            try:\n                message = await self.outgoing.get()\n\n                # Track message send for connection health\n                self._last_message_sent = datetime.now()\n                self._messages_sent_count += 1\n\n                # DEBUG: Log message type before sending\n                try:\n                    data = json.loads(message)\n                    msg_type = data.get(\"__type__\", data.get(\"type\", \"unknown\"))\n                except:\n                    msg_type = \"non-json\"\n                Logger.debug(f\"[SEND #{self._messages_sent_count}] {self.mode.value} sending: type={msg_type}\")\n\n                await self.connection.asend(message.encode())\n            except Exception as e:\n                Logger.error(f\"Error in send handler: {e}, type: {type(e)}\")\n\n    def _add_callbacks(self):\n        self.connection.add_post_pipe_connect_cb(self._post_connect_callback)\n        self.connection.add_post_pipe_remove_cb(self._post_remove_callback)\n        Logger.debug(f\"Pipe callbacks registered for connection on {self.address}\")\n\n    def _post_connect_callback(self, pipe):\n        \"\"\"Internal callback when a new pipe connects.\"\"\"\n        # IMMEDIATE logging to verify callback is being called\n        print(f\"[CALLBACK] _post_connect_callback ENTERED for pipe {pipe}\", flush=True)\n        Logger.warning(f\"[CALLBACK] _post_connect_callback ENTERED for pipe {pipe}\")\n        try:\n            sender = self._extract_sender_info(pipe)\n            conn_info = ConnectionInfo(\n                pipe_id=pipe.id,\n                sender=sender,\n                connected_at=datetime.now()\n            )\n            self.active_connections[pipe.id] = conn_info\n            # Enhanced logging with pipe details\n            Logger.info(f\"Connection established - Pipe ID: {pipe.id}, Sender: {sender}, \"\n                       f\"Local: {pipe.local_address}, Remote: {pipe.remote_address}\")\n            Logger.debug(f\"Active connections after connect: {len(self.active_connections)} - \"\n                        f\"IDs: {list(self.active_connections.keys())}\")\n        except Exception as e:\n            import traceback\n            Logger.error(f\"Error in connect callback: {e}\")\n            Logger.error(f\"Traceback: {traceback.format_exc()}\")\n\n    def _post_remove_callback(self, pipe):\n        \"\"\"Internal callback when a pipe disconnects.\"\"\"\n        # IMMEDIATE logging to verify callback is being called\n        import traceback\n        stack = traceback.format_stack()\n        print(f\"[CALLBACK] _post_remove_callback ENTERED for pipe {pipe}\", flush=True)\n        Logger.warning(f\"[CALLBACK] _post_remove_callback ENTERED for pipe {pipe}\")\n        Logger.warning(f\"[CALLBACK] Call stack:\\n{''.join(stack[-5:])}\")  # Last 5 frames\n        try:\n            conn_info = self.active_connections.pop(pipe.id, None)\n            if conn_info:\n                duration = datetime.now() - conn_info.connected_at\n                # Include message stats for debugging connection issues\n                Logger.warning(f\"CONNECTION CLOSED - Pipe ID: {pipe.id}, Sender: {conn_info.sender}, \"\n                              f\"Duration: {duration.total_seconds():.2f}s, \"\n                              f\"Messages sent: {self._messages_sent_count}, \"\n                              f\"Messages received: {self._messages_received_count}\")\n            else:\n                Logger.warning(f\"Pipe {pipe.id} disconnected but not found in active connections\")\n\n            remaining = len(self.active_connections)\n            Logger.info(f\"Active connections after disconnect: {remaining} - \"\n                       f\"IDs: {list(self.active_connections.keys())}\")\n\n            # Warn if this was the last connection for a DIALER (node)\n            if remaining == 0 and self.mode == self.Mode.DIALER:\n                Logger.warning(f\"DIALER has no active connections - waiting for reconnection\")\n        except Exception as e:\n            Logger.error(f\"Error in disconnect callback: {e}\")\n\n    def _extract_sender_info(self, pipe):\n        \"\"\"\n        Extract sender information from the message pipe.\n\n        Handles both TCP and IPC addresses. For TCP, extracts the IP address.\n        For IPC, returns the pipe URL.\n\n        Parameters:\n        - pipe: The pynng pipe object containing remote address information.\n\n        Returns:\n        - str: The sender identifier (IP address for TCP, URL for IPC).\n        \"\"\"\n        try:\n            remote_addr = pipe.remote_address\n            # Check if it's a TCP address (has 'addr' attribute)\n            if hasattr(remote_addr, 'addr'):\n                as_bytes = struct.pack(\"I\", remote_addr.addr)\n                ip = socket.inet_ntop(socket.AF_INET, as_bytes)\n                port = socket.ntohs(remote_addr.port)\n                return (ip, port)\n            else:\n                # For IPC or other address types, use the pipe URL\n                return str(pipe.url) if hasattr(pipe, 'url') else \"unknown\"\n        except Exception as e:\n            Logger.debug(f\"Error extracting sender info: {e}\")\n            return \"unknown\"\n</code></pre>"},{"location":"tools/#cuemsutils.tools.HubServices.NngBusHub.__init__","title":"<code>__init__(hub_address, mode)</code>","text":"<p>Initialize Nng_bus_hub instance with address and operational mode.</p> <p>Parameters: - hub_address (str): The address to connect or listen for bus connections. - mode (Mode): The operational mode - LISTENER (listens) or DIALER (dials)</p> <p>The instance will set up incoming and outgoing message queues for asynchronous message handling.</p> Source code in <code>src/cuemsutils/tools/HubServices.py</code> <pre><code>def __init__(self, hub_address:str, mode:Mode):\n    \"\"\"\n    Initialize Nng_bus_hub instance with address and operational mode.\n\n    Parameters:\n    - hub_address (str): The address to connect or listen for bus connections.\n    - mode (Mode): The operational mode - LISTENER (listens) or DIALER (dials)\n\n    The instance will set up incoming and outgoing message queues for asynchronous message handling.\n    \"\"\"\n    self.active_connections: dict[int, ConnectionInfo] = {}  # pipe_id -&gt; ConnectionInfo\n    self.address = hub_address\n    self.mode = mode\n    self.incoming = asyncio.Queue()\n    self.outgoing = asyncio.Queue()\n\n    # Connection health tracking\n    self._last_message_received: Optional[datetime] = None\n    self._last_message_sent: Optional[datetime] = None\n    self._messages_received_count: int = 0\n    self._messages_sent_count: int = 0\n\n    # Ping/pong configuration\n    self._auto_ping_enabled: bool = False\n    self._auto_ping_interval: float = 10.0\n    self._auto_ping_task: Optional[asyncio.Task] = None\n    self._auto_pong_enabled: bool = True  # Nodes auto-respond by default\n    self._ping_count: int = 0\n    self._pong_count: int = 0\n</code></pre>"},{"location":"tools/#cuemsutils.tools.HubServices.NngBusHub.disable_auto_ping","title":"<code>disable_auto_ping()</code>","text":"<p>Disable automatic ping mechanism.</p> Source code in <code>src/cuemsutils/tools/HubServices.py</code> <pre><code>def disable_auto_ping(self):\n    \"\"\"Disable automatic ping mechanism.\"\"\"\n    self._auto_ping_enabled = False\n    Logger.info(\"Auto-ping disabled\")\n</code></pre>"},{"location":"tools/#cuemsutils.tools.HubServices.NngBusHub.disable_auto_pong","title":"<code>disable_auto_pong()</code>","text":"<p>Disable automatic pong responses.</p> Source code in <code>src/cuemsutils/tools/HubServices.py</code> <pre><code>def disable_auto_pong(self):\n    \"\"\"Disable automatic pong responses.\"\"\"\n    self._auto_pong_enabled = False\n    Logger.debug(\"Auto-pong disabled\")\n</code></pre>"},{"location":"tools/#cuemsutils.tools.HubServices.NngBusHub.enable_auto_ping","title":"<code>enable_auto_ping(interval=10.0, inactivity_threshold=5.0)</code>","text":"<p>Enable automatic ping mechanism for the controller.</p> <p>The controller will automatically send ping messages to all nodes if there's been no activity for the specified threshold period. Nodes will automatically respond with pong messages.</p> <p>Parameters: - interval: How often to check for inactive connections (default: 10.0 seconds) - inactivity_threshold: Send ping if no activity for this many seconds (default: 5.0)</p> <p>Note: This is primarily useful for LISTENER mode to verify node connections.</p> Source code in <code>src/cuemsutils/tools/HubServices.py</code> <pre><code>def enable_auto_ping(self, interval: float = 10.0, inactivity_threshold: float = 5.0):\n    \"\"\"\n    Enable automatic ping mechanism for the controller.\n\n    The controller will automatically send ping messages to all nodes if there's\n    been no activity for the specified threshold period. Nodes will automatically\n    respond with pong messages.\n\n    Parameters:\n    - interval: How often to check for inactive connections (default: 10.0 seconds)\n    - inactivity_threshold: Send ping if no activity for this many seconds (default: 5.0)\n\n    Note: This is primarily useful for LISTENER mode to verify node connections.\n    \"\"\"\n    self._auto_ping_enabled = True\n    self._auto_ping_interval = interval\n    self._inactivity_threshold = inactivity_threshold\n    Logger.info(f\"Auto-ping enabled: check every {interval}s, ping after {inactivity_threshold}s inactivity\")\n</code></pre>"},{"location":"tools/#cuemsutils.tools.HubServices.NngBusHub.enable_auto_pong","title":"<code>enable_auto_pong()</code>","text":"<p>Enable automatic pong responses (enabled by default).</p> Source code in <code>src/cuemsutils/tools/HubServices.py</code> <pre><code>def enable_auto_pong(self):\n    \"\"\"Enable automatic pong responses (enabled by default).\"\"\"\n    self._auto_pong_enabled = True\n    Logger.debug(\"Auto-pong enabled\")\n</code></pre>"},{"location":"tools/#cuemsutils.tools.HubServices.NngBusHub.get_active_connections","title":"<code>get_active_connections()</code>","text":"<p>Get a list of all active connections.</p> <p>Returns: - List[ConnectionInfo]: List of all active connection information.</p> Source code in <code>src/cuemsutils/tools/HubServices.py</code> <pre><code>def get_active_connections(self) -&gt; List[ConnectionInfo]:\n    \"\"\"\n    Get a list of all active connections.\n\n    Returns:\n    - List[ConnectionInfo]: List of all active connection information.\n    \"\"\"\n    return list(self.active_connections.values())\n</code></pre>"},{"location":"tools/#cuemsutils.tools.HubServices.NngBusHub.get_connection_count","title":"<code>get_connection_count()</code>","text":"<p>Get the number of active connections.</p> <p>Returns: - int: Number of currently active connections.</p> Source code in <code>src/cuemsutils/tools/HubServices.py</code> <pre><code>def get_connection_count(self) -&gt; int:\n    \"\"\"\n    Get the number of active connections.\n\n    Returns:\n    - int: Number of currently active connections.\n    \"\"\"\n    return len(self.active_connections)\n</code></pre>"},{"location":"tools/#cuemsutils.tools.HubServices.NngBusHub.get_connection_health_info","title":"<code>get_connection_health_info(activity_timeout=30.0)</code>","text":"<p>Get connection health information based on message activity.</p> <p>This is particularly useful for DIALERs to check if they're still  connected to the controller, since nodes don't track the controller connection in active_connections.</p> <p>Parameters: - activity_timeout: Seconds of inactivity before considering unhealthy (default: 30.0)</p> <ul> <li>dict: Health information containing:<ul> <li>is_healthy: bool - True if recent activity detected</li> <li>last_received: datetime or None - Last message received time</li> <li>last_sent: datetime or None - Last message sent time</li> <li>seconds_since_activity: float or None - Seconds since last activity</li> <li>messages_received: int - Total messages received</li> <li>messages_sent: int - Total messages sent</li> </ul> </li> </ul> Source code in <code>src/cuemsutils/tools/HubServices.py</code> <pre><code>def get_connection_health_info(self, activity_timeout: float = 30.0) -&gt; Dict:\n    \"\"\"\n    Get connection health information based on message activity.\n\n    This is particularly useful for DIALERs to check if they're still \n    connected to the controller, since nodes don't track the controller\n    connection in active_connections.\n\n    Parameters:\n    - activity_timeout: Seconds of inactivity before considering unhealthy (default: 30.0)\n\n    Returns:\n    - dict: Health information containing:\n        - is_healthy: bool - True if recent activity detected\n        - last_received: datetime or None - Last message received time\n        - last_sent: datetime or None - Last message sent time\n        - seconds_since_activity: float or None - Seconds since last activity\n        - messages_received: int - Total messages received\n        - messages_sent: int - Total messages sent\n    \"\"\"\n    now = datetime.now()\n    last_activity = None\n\n    # Determine most recent activity\n    if self._last_message_received and self._last_message_sent:\n        last_activity = max(self._last_message_received, self._last_message_sent)\n    elif self._last_message_received:\n        last_activity = self._last_message_received\n    elif self._last_message_sent:\n        last_activity = self._last_message_sent\n\n    # Calculate seconds since last activity\n    seconds_since_activity = None\n    if last_activity:\n        seconds_since_activity = (now - last_activity).total_seconds()\n\n    # Determine health status\n    is_healthy = False\n    if seconds_since_activity is not None:\n        is_healthy = seconds_since_activity &lt;= activity_timeout\n\n    return {\n        'is_healthy': is_healthy,\n        'last_received': self._last_message_received,\n        'last_sent': self._last_message_sent,\n        'seconds_since_activity': seconds_since_activity,\n        'messages_received': self._messages_received_count,\n        'messages_sent': self._messages_sent_count\n    }\n</code></pre>"},{"location":"tools/#cuemsutils.tools.HubServices.NngBusHub.get_message","title":"<code>get_message()</code>  <code>async</code>","text":"<p>Retrieve a message from the incoming queue.</p> <ul> <li>Message: The next message received from the bus. The <code>data</code> field is already JSON-decoded as a dict.            This method blocks until a message is available.</li> </ul> Source code in <code>src/cuemsutils/tools/HubServices.py</code> <pre><code>async def get_message(self) -&gt; Message:\n    \"\"\"\n    Retrieve a message from the incoming queue.\n\n    Returns:\n    - Message: The next message received from the bus. The `data` field is already JSON-decoded as a dict.\n               This method blocks until a message is available.\n    \"\"\"\n    return await self.incoming.get()\n</code></pre>"},{"location":"tools/#cuemsutils.tools.HubServices.NngBusHub.is_connection_healthy","title":"<code>is_connection_healthy(activity_timeout=30.0)</code>","text":"<p>Check if the connection is healthy based on recent activity.</p> <p>Parameters: - activity_timeout: Seconds of inactivity before considering unhealthy (default: 30.0)</p> <p>Returns: - bool: True if connection appears healthy</p> Source code in <code>src/cuemsutils/tools/HubServices.py</code> <pre><code>def is_connection_healthy(self, activity_timeout: float = 30.0) -&gt; bool:\n    \"\"\"\n    Check if the connection is healthy based on recent activity.\n\n    Parameters:\n    - activity_timeout: Seconds of inactivity before considering unhealthy (default: 30.0)\n\n    Returns:\n    - bool: True if connection appears healthy\n    \"\"\"\n    return self.get_connection_health_info(activity_timeout)['is_healthy']\n</code></pre>"},{"location":"tools/#cuemsutils.tools.HubServices.NngBusHub.send_message","title":"<code>send_message(message)</code>  <code>async</code>","text":"<p>Queue a message to be sent to the bus.</p> <p>Parameters: - message (dict | Message): The message to be sent. Must be a dict or Message object with dict data.</p> <p>Raises: - TypeError: If message is not a dict or Message object, or if Message.data is not a dict.</p> <p>The message is JSON-encoded and placed in the outgoing queue to be sent by the sender handler.</p> Source code in <code>src/cuemsutils/tools/HubServices.py</code> <pre><code>async def send_message(self, message: dict | Message):\n    \"\"\"\n    Queue a message to be sent to the bus.\n\n    Parameters:\n    - message (dict | Message): The message to be sent. Must be a dict or Message object with dict data.\n\n    Raises:\n    - TypeError: If message is not a dict or Message object, or if Message.data is not a dict.\n\n    The message is JSON-encoded and placed in the outgoing queue to be sent by the sender handler.\n    \"\"\"\n    # Extract data from Message object or use raw data\n    if isinstance(message, Message):\n        data = message.data\n        if not isinstance(data, dict):\n            raise TypeError(f\"Message.data must be a dict, got {type(data).__name__}\")\n    elif isinstance(message, dict):\n        data = message\n    else:\n        raise TypeError(f\"send_message requires dict or Message, got {type(message).__name__}\")\n\n    # JSON-encode the dict\n    json_data = json.dumps(data)\n\n    await self.outgoing.put(json_data)\n</code></pre>"},{"location":"tools/#cuemsutils.tools.HubServices.NngBusHub.send_ping","title":"<code>send_ping()</code>  <code>async</code>","text":"<p>Manually send a ping message to all connected nodes.</p> <p>Returns: - int: Number of pings sent</p> Source code in <code>src/cuemsutils/tools/HubServices.py</code> <pre><code>async def send_ping(self):\n    \"\"\"\n    Manually send a ping message to all connected nodes.\n\n    Returns:\n    - int: Number of pings sent\n    \"\"\"\n    ping_message = {\"__type__\": \"ping\", \"timestamp\": datetime.now().isoformat()}\n    await self.send_message(ping_message)\n    self._ping_count += 1\n    Logger.debug(f\"Ping sent (total: {self._ping_count})\")\n    return 1\n</code></pre>"},{"location":"tools/#cuemsutils.tools.HubServices.NngBusHub.start","title":"<code>start()</code>  <code>async</code>","text":"<p>Start the bus communication by initializing the connection and launching message handlers.</p> <p>This method starts the bus connection based on the mode (LISTENER or DIALER), then launches infinite receiver and sender loops. It monitors both tasks and exits when the first exception occurs or connection is broken, properly cleaning up all running tasks.</p> <p>Raises: - ValueError: If an unknown mode is set. - Exception: Re-raises any exception that occurs during task execution after cleanup.</p> Source code in <code>src/cuemsutils/tools/HubServices.py</code> <pre><code>async def start(self):\n    \"\"\"\n    Start the bus communication by initializing the connection and launching message handlers.\n\n    This method starts the bus connection based on the mode (LISTENER or DIALER),\n    then launches infinite receiver and sender loops. It monitors both tasks and\n    exits when the first exception occurs or connection is broken, properly cleaning\n    up all running tasks.\n\n    Raises:\n    - ValueError: If an unknown mode is set.\n    - Exception: Re-raises any exception that occurs during task execution after cleanup.\n    \"\"\"\n    match self.mode:\n        case self.Mode.LISTENER:\n            await self.start_listener()\n        case self.Mode.DIALER:\n            await self.start_dialer()\n        case _:\n            raise ValueError(f\"Unknown mode: {self.mode}\")\n\n    try:\n        sender_task = asyncio.create_task(self._send_handler(), name=\"sender\")\n        receiver_task = asyncio.create_task(self._receiver_handler(), name=\"receiver\")\n        ping_task = asyncio.create_task(self._auto_ping_handler(), name=\"ping\")\n\n        tasks = [sender_task, receiver_task, ping_task]\n        task_names = {sender_task: \"sender\", receiver_task: \"receiver\", ping_task: \"ping\"}\n\n        Logger.info(f\"NNG {self.mode.value} tasks started: sender, receiver, ping\")\n\n        done_tasks, pending_tasks = await asyncio.wait(tasks, return_when=asyncio.FIRST_EXCEPTION)\n\n        # Check if completed task had an exception\n        for task in done_tasks:\n            task_name = task_names.get(task, \"unknown\")\n            if task.exception() is not None:\n                Logger.error(f\"NNG {self.mode.value} {task_name} handler failed: {task.exception()}\")\n                Logger.error(f\"Exception type: {type(task.exception()).__name__}\")\n            else:\n                Logger.warning(f\"NNG {self.mode.value} {task_name} handler exited unexpectedly (no exception)\")\n\n        # Log pending task cancellation\n        pending_names = [task_names.get(t, \"unknown\") for t in pending_tasks]\n        if pending_names:\n            Logger.info(f\"Cancelling pending tasks: {pending_names}\")\n\n        # Cancel and await pending tasks\n        for task in pending_tasks:\n            task.cancel()\n            try:\n                await task\n            except asyncio.CancelledError:\n                pass\n\n        Logger.warning(f\"NNG {self.mode.value} start() exiting - all tasks terminated\")\n\n    except Exception as e:\n        Logger.error(f\"Error occurred while starting tasks: {e} type: {type(e)}\")\n        # Cancel any running tasks\n        for task in [sender_task, receiver_task, ping_task]:\n            if not task.done():\n                task.cancel()\n                try:\n                    await task\n                except asyncio.CancelledError:\n                    pass\n        raise\n</code></pre>"},{"location":"tools/#cuemsutils.tools.HubServices.NngBusHub.start_dialer","title":"<code>start_dialer()</code>  <code>async</code>","text":"<p>Initialize the bus connection in DIALER mode (dialing to controller).</p> <p>Creates a Bus0 socket that dials to the configured address with a 100ms receive timeout. TCP keepalive is enabled BEFORE dialing to ensure it applies to the connection. Non-blocking dial is used to allow reconnection if controller is not yet available. Callbacks are registered BEFORE dialing to ensure no connection events are missed.</p> Source code in <code>src/cuemsutils/tools/HubServices.py</code> <pre><code>async def start_dialer(self):\n    \"\"\"\n    Initialize the bus connection in DIALER mode (dialing to controller).\n\n    Creates a Bus0 socket that dials to the configured address with a 100ms receive timeout.\n    TCP keepalive is enabled BEFORE dialing to ensure it applies to the connection.\n    Non-blocking dial is used to allow reconnection if controller is not yet available.\n    Callbacks are registered BEFORE dialing to ensure no connection events are missed.\n    \"\"\"\n    # Create socket first, set options and callbacks, then dial (non-blocking for reconnection support)\n    self.connection = Bus0(recv_timeout=RECV_TIMEOUT)\n    self.connection.tcp_keepalive = True\n    # Set explicit reconnection parameters\n    self.connection.reconnect_time_min = 1000  # 1 second minimum\n    self.connection.reconnect_time_max = 30000  # 30 seconds maximum\n    self._add_callbacks()  # Register callbacks BEFORE dial to catch all events\n    Logger.debug(f\"DIALER options set: tcp_keepalive={self.connection.tcp_keepalive}, \" +\n                 f\"reconnect_time_min={self.connection.reconnect_time_min}ms, \" +\n                 f\"reconnect_time_max={self.connection.reconnect_time_max}ms\")\n    self.connection.dial(self.address, block=False)\n    Logger.debug(f\"DIALER dialing {self.address} (non-blocking)\")\n</code></pre>"},{"location":"tools/#cuemsutils.tools.HubServices.NngBusHub.start_listener","title":"<code>start_listener()</code>  <code>async</code>","text":"<p>Initialize the bus connection in LISTENER mode (listening for connections).</p> <p>Creates a Bus0 socket that listens on the configured address with a 100ms receive timeout. TCP keepalive is enabled BEFORE listening to ensure it applies to all connections. Callbacks are registered BEFORE listening to ensure no connection events are missed.</p> Source code in <code>src/cuemsutils/tools/HubServices.py</code> <pre><code>async def start_listener(self):\n    \"\"\"\n    Initialize the bus connection in LISTENER mode (listening for connections).\n\n    Creates a Bus0 socket that listens on the configured address with a 100ms receive timeout.\n    TCP keepalive is enabled BEFORE listening to ensure it applies to all connections.\n    Callbacks are registered BEFORE listening to ensure no connection events are missed.\n    \"\"\"\n    # Create socket first, set options and callbacks, then listen\n    self.connection = Bus0(recv_timeout=RECV_TIMEOUT)\n    self.connection.tcp_keepalive = True\n    self._add_callbacks()  # Register callbacks BEFORE listen to catch all events\n    self.connection.listen(self.address)\n    Logger.debug(f\"LISTENER started on {self.address}, tcp_keepalive={self.connection.tcp_keepalive}\")\n</code></pre>"},{"location":"tools/#cuemsutils.tools.SignalEngine.SignalEngine","title":"<code>SignalEngine</code>","text":"<p>A class that handles system signals and status tracking.</p> Source code in <code>src/cuemsutils/tools/SignalEngine.py</code> <pre><code>class SignalEngine:\n    \"\"\"\n    A class that handles system signals and status tracking.\n    \"\"\"\n    def __init__(self, with_signals: bool = True):\n        self.pid = getpid()\n        Logger.info(f\"Starting {self.__class__.__name__} with PID {self.pid}\")\n        self.running = False\n\n        if with_signals:\n            self.register_signals()\n\n    ### RUNNING LOGIC ###\n    @logged\n    def start(self) -&gt; None:\n        self.running = True\n        Logger.info(f\"{self.__class__.__name__} started\")\n        self.run()\n\n    def restart(self) -&gt; None:\n        pass\n\n    def reload(self) -&gt; None:\n        pass\n\n    @logged\n    def run(self, tick: float = 3, max_tick: float | None = None) -&gt; None:\n        while self.running:\n            sleep(tick)\n            if max_tick is not None:\n                if tick &lt; max_tick:\n                    tick += 0.01\n                else:\n                    self.stop()\n\n    @logged\n    def stop(self) -&gt; None:\n        self.stop_requested = True\n        try:\n            if hasattr(self, 'stop_all'):\n                self.stop_all()  # type: ignore[attr-defined]\n        except:\n            Logger.warning('Exception when calling stop_all')\n        self.running = False\n\n    ### COMMUNICATE WITH SYSTEMD ###\n    def notify_systemd(self, status: str = 'READY'):\n        Logger.debug('Startup complete, notifying systemd')\n        notify_systemd_daemon(f'{status.upper()}=1')\n\n    ### SIGNALS HANDLERS ###\n    def register_signals(self) -&gt; None:\n        signal.signal(signal.SIGINT, self.handle_interrupt)\n        signal.signal(signal.SIGTERM, self.handle_terminate)\n        signal.signal(signal.SIGUSR1, self.handle_print_running)\n        signal.signal(signal.SIGUSR2, self.handle_print_all)\n        signal.signal(signal.SIGCHLD, self.handle_child_signal)\n\n    def handle_interrupt(self, sigNum, frame) -&gt; None:\n        string = f'SIGINT received! Exiting with result code: {sigNum}'\n        print('\\n\\n' + string + '\\n\\n')\n        Logger.info(string)\n\n        self.stop()\n        sleep(0.1)\n        exit()\n\n    def handle_terminate(self, sigNum, frame) -&gt; None:\n        string = f'SIGTERM received! Exiting with result code: {sigNum}'\n        print('\\n\\n' + string + '\\n\\n')\n        Logger.info(string)\n\n        self.stop()\n        sleep(0.1)\n        exit()\n\n    def handle_print_all(self, sigNum, frame) -&gt; None:\n        Logger.info(f\"STATUS REQUEST BY SIGUSR2 SIGNAL {sigNum}\")\n        if hasattr(self, 'print_all_status'):\n            self.print_all_status()  # type: ignore[attr-defined]\n\n    def handle_print_running(self, sigNum, frame) -&gt; None:\n        run_str = \"\" if self.running else \" NOT\"\n        string = f\"SIGNAL {sigNum} recieved: {self.__class__.__name__} is{run_str} running\"\n        Logger.info(string)\n        print(string)\n\n    def handle_child_signal(self, sigNum, frame):\n        pass\n</code></pre>"},{"location":"tools/#cuemsutils.tools.StringSanitizer.StringSanitizer","title":"<code>StringSanitizer</code>","text":"<p>Ensure that the string is sanitized and safe for use in the system</p> Source code in <code>src/cuemsutils/tools/StringSanitizer.py</code> <pre><code>class StringSanitizer():\n    \"\"\"Ensure that the string is sanitized and safe for use in the system\"\"\"\n    @staticmethod\n    def sanitize_text_size(_string):\n\n        if _string and (len(_string) &gt; 65535):\n            _string = _string[0:65534] # return frist 255 characters\n        return _string\n\n    @staticmethod\n    def sanitize_name(_string): #TODO: scape characters?\n        if len(_string) &gt; 255 :\n            _string = _string[0:254] # return frist 255 characters\n        return _string\n\n    @staticmethod\n    def sanitize_file_name(_string):\n        if len(_string) &gt;= 240 :\n            _string = _string[0:236] + _string[-4:] # return frist 236 characters + last 4 chars = total 240 of max 255. Leave room for versioning and .tmp\n\n        _string = _string.replace(' ', '_')\n        _string = _string.replace('-', '_')\n        keepcharacters = ('.','_')\n        return \"\".join(c for c in _string if c.isalnum() or c in keepcharacters).rstrip().lower()\n\n    @staticmethod\n    def sanitize_dir_name(_string):\n        if len(_string) &gt;= 240 :\n            _string = _string[0:236] + _string[-4:] # return frist 236 characters + last 4 chars = total 240 of max 255. Leave room for versioning and .tmp\n\n        _string = _string.replace(' ', '_')\n        _string = _string.replace('-', '_')\n        keepcharacters = ('_')\n        return \"\".join(c for c in _string if c.isalnum() or c in keepcharacters).rstrip().lower()\n\n    @staticmethod\n    def sanitize_dir_permit_increment(_string):\n        if len(_string) &gt;= 240 :\n            _string = _string[0:236] + _string[-4:] # return frist 236 characters + last 4 chars = total 240 of max 255. Leave room for versioning and .tmp\n\n        _string = _string.replace(' ', '_')\n        keepcharacters = ('_', '-')\n        return \"\".join(c for c in _string if c.isalnum() or c in keepcharacters).rstrip().lower()\n</code></pre>"},{"location":"tools/#cuemsutils.tools.Uuid.Uuid","title":"<code>Uuid</code>","text":"<p>A class to interact with unique identifiers.</p> <p>Comparisions should be made based on memory allocation.</p> <p>Calling or printing the instance will return the uuid4 string.</p> Source code in <code>src/cuemsutils/tools/Uuid.py</code> <pre><code>class Uuid():\n    \"\"\"A class to interact with unique identifiers.\n\n        Comparisions should be made based on memory allocation.\n\n        Calling or printing the instance will return the uuid4 string.\n    \"\"\"\n    def __init__(self, uuid: str | None = None):\n        if not uuid:\n            self.uuid = str(uuid4())\n        else:\n            self.uuid = str(uuid)\n        if not self.check():\n            raise ValueError(f'uuid {uuid} is not valid')\n\n    def __str__(self):\n        return self.uuid\n\n    def __repr__(self):\n        return self.uuid\n\n    def __call__(self):\n        return self.uuid\n\n    def __hash__(self):\n        return hash(self.uuid)\n\n    def __eq__(self, other):\n        if isinstance(other, Uuid):\n            return self.uuid == other.uuid\n        elif isinstance(other, str):\n            return self.uuid == other\n        else:\n            return False\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __json__(self):\n        return self.uuid\n\n    def items(self):\n        return [(\"uuid\", self.uuid)]\n\n    def check(self):\n        m = match(UUID4_REGEX, self.uuid)\n        if m:\n            return m.span() == (0, 36)\n        return False\n</code></pre>"},{"location":"xml/","title":"Xml","text":"<p>For the moment it works with pip3 install xmlschema==1.1.2</p> <p>For the moment it works with pip3 install xmlschema==1.2.2</p>"},{"location":"xml/#cuemsutils.xml.CMLCuemsConverter.CMLCuemsConverter","title":"<code>CMLCuemsConverter</code>","text":"<p>               Bases: <code>XMLSchemaConverter</code></p> Source code in <code>src/cuemsutils/xml/CMLCuemsConverter.py</code> <pre><code>class CMLCuemsConverter(XMLSchemaConverter):\n\n    def __init__(self, namespaces=None, dict_class=None, list_class=None,\n                 etree_element_class=None, text_key='&amp;', attr_prefix='',\n                 cdata_prefix=None, indent=4, strip_namespaces=True,\n                 preserve_root=False, force_dict=False, force_list=False, **kwargs):\n\n        if etree_element_class is None or etree_element_class is Element:\n            register_namespace = etree_register_namespace\n        elif etree_element_class is lxml_etree_element:\n            register_namespace = lxml_etree_register_namespace\n        else:\n            raise XMLSchemaTypeError(\"unsupported element class {!r}\".format(etree_element_class))\n\n        super().__init__(namespaces=None, register_namespace=register_namespace, strip_namespaces=strip_namespaces)\n\n        self.dict = dict_class or dict\n        self.list = list_class or list\n        self.etree_element_class = etree_element_class or Element\n        self.text_key = text_key\n        self.attr_prefix = attr_prefix\n        self.cdata_prefix = cdata_prefix\n        self.indent = indent\n        self.preserve_root = preserve_root\n        self.force_dict = force_dict\n        self.force_list = force_list\n\n\n    def element_decode(self, data, xsd_element, xsd_type=None, level=0):\n        \"\"\"\n        Converts a decoded element data to a data structure.\n        :param data: ElementData instance decoded from an Element node.\n        :param xsd_element: the `XsdElement` associated to decoded the data.\n        :param xsd_type: optional `XsdType` for supporting dynamic type through \\\n        xsi:type or xs:alternative.\n        :param level: the level related to the decoding process (0 means the root).\n        :return: a data structure containing the decoded data.\n        \"\"\"\n        xsd_type = xsd_type or xsd_element.type\n        result_dict = self.dict()\n        if level == 0 and xsd_element.is_global() and not self.strip_namespaces and self:\n            schema_namespaces = set(xsd_element.namespaces.values())\n            result_dict.update(\n                ('%s:%s' % (self.ns_prefix, k) if k else self.ns_prefix, v)\n                for k, v in self._namespaces.items()\n                if v in schema_namespaces\n            )\n\n        if xsd_type.is_simple() or xsd_type.has_simple_content():\n            if data.attributes or self.force_dict and not xsd_type.is_simple():\n                result_dict.update(t for t in self.map_attributes(data.attributes))\n                if data.text is not None and data.text != '':\n                    result_dict[self.text_key] = data.text\n                return result_dict\n            else:\n                return data.text if data.text != '' else None\n        else:\n#            has_single_group = xsd_type.content_type.is_single()\n            list_types = list if self.list is list else (self.list, list)\n            dict_types = dict if self.dict is dict else (self.dict, dict)\n            if data.content:\n                for name, value, xsd_child in self.map_content(data.content):\n                    if isinstance(xsd_child, Xsd11AnyElement):\n                        result_dict.update({name:value})\n                        continue\n                    try:\n                        if isinstance(result_dict, list_types):\n                            result = result_dict\n                        else:\n                            result = result_dict[name]\n                    except KeyError:\n                        if xsd_child is not None and not xsd_child.is_single():\n                            result_dict = [{name:value}]\n                        else:\n                            result_dict[name] = self.list([value]) if self.force_list else value\n                    else:\n                        if isinstance(result, dict_types):\n                            result_dict[name] = self.list([result, value])\n                        elif isinstance(result, list_types) or not result:\n                            result_dict.append({name:value})\n                        else:\n                            result.append(value)\n\n            elif data.content is None and data.text is not None and data.text != '':\n                result_dict = data.text\n\n            elif data.text is not None and data.text != '':\n                result_dict[self.text_key] = data.text\n\n            if data.attributes:\n                result_dict.update(t for t in self.map_attributes(data.attributes))\n\n            if level == 0 and self.preserve_root:\n                return self.dict(\n                    [(self.map_qname(data.tag), result_dict if result_dict else None)]\n                )\n            return result_dict if result_dict else None\n\n    def element_encode(self, obj, xsd_element, level=0):\n        \"\"\"\n        Extracts XML decoded data from a data structure for encoding into an ElementTree.\n        :param obj: the decoded object.\n        :param xsd_element: the `XsdElement` associated to the decoded data structure.\n        :param level: the level related to the encoding process (0 means the root).\n        :return: an ElementData instance.\n        \"\"\"\n        if level != 0:\n            tag = xsd_element.name\n        elif not self.preserve_root:\n            tag = xsd_element.qualified_name\n        else:\n            tag = xsd_element.qualified_name\n            try:\n                obj = obj.get(tag, xsd_element.local_name)\n            except (KeyError, AttributeError, TypeError):\n                pass\n\n        if not isinstance(obj, (self.dict, dict)):\n            if xsd_element.type.is_simple() or xsd_element.type.has_simple_content():\n                return ElementData(tag, obj, None, {})\n            elif xsd_element.type.mixed and not isinstance(obj, list):\n                return ElementData(tag, obj, None, {})\n            else:\n                return ElementData(tag, None, obj, {})\n\n        text = None\n        content = []\n        attributes = {}\n\n        for name, value in obj.items():\n            if name == self.text_key and self.text_key:\n                text = obj[self.text_key]\n            elif (self.cdata_prefix and name.startswith(self.cdata_prefix)) or \\\n                    name[0].isdigit() and self.cdata_prefix == '':\n                index = int(name[len(self.cdata_prefix):])\n                content.append((index, value))\n            elif name == self.ns_prefix:\n                self[''] = value\n            elif name.startswith('%s:' % self.ns_prefix):\n                if not self.strip_namespaces:\n                    self[name[len(self.ns_prefix) + 1:]] = value\n            elif self.attr_prefix and name.startswith(self.attr_prefix):\n                attr_name = name[len(self.attr_prefix):]\n                ns_name = self.unmap_qname(attr_name, xsd_element.attributes)\n                attributes[ns_name] = value\n            elif not isinstance(value, (self.list, list)) or not value:\n                content.append((self.unmap_qname(name), value))\n            elif isinstance(value[0], (self.dict, dict, self.list, list)):\n                ns_name = self.unmap_qname(name)\n                content.extend((ns_name, item) for item in value)\n            else:\n                ns_name = self.unmap_qname(name)\n                for xsd_child in xsd_element.type.content_type.iter_elements():\n                    matched_element = xsd_child.match(ns_name, resolve=True)\n                    if matched_element is not None:\n                        if matched_element.type.is_list():\n                            content.append((ns_name, value))\n                        else:\n                            content.extend((ns_name, item) for item in value)\n                        break\n                else:\n                    if self.attr_prefix == '' and ns_name not in attributes:\n                        for key, xsd_attribute in xsd_element.attributes.items():\n                            if xsd_attribute.is_matching(ns_name):\n                                attributes[key] = value\n                                break\n                        else:\n                            content.append((ns_name, value))\n                    else:\n                        content.append((ns_name, value))\n\n        return ElementData(tag, text, content, attributes)\n</code></pre>"},{"location":"xml/#cuemsutils.xml.CMLCuemsConverter.CMLCuemsConverter.element_decode","title":"<code>element_decode(data, xsd_element, xsd_type=None, level=0)</code>","text":"<p>Converts a decoded element data to a data structure. :param data: ElementData instance decoded from an Element node. :param xsd_element: the <code>XsdElement</code> associated to decoded the data. :param xsd_type: optional <code>XsdType</code> for supporting dynamic type through         xsi:type or xs:alternative. :param level: the level related to the decoding process (0 means the root). :return: a data structure containing the decoded data.</p> Source code in <code>src/cuemsutils/xml/CMLCuemsConverter.py</code> <pre><code>    def element_decode(self, data, xsd_element, xsd_type=None, level=0):\n        \"\"\"\n        Converts a decoded element data to a data structure.\n        :param data: ElementData instance decoded from an Element node.\n        :param xsd_element: the `XsdElement` associated to decoded the data.\n        :param xsd_type: optional `XsdType` for supporting dynamic type through \\\n        xsi:type or xs:alternative.\n        :param level: the level related to the decoding process (0 means the root).\n        :return: a data structure containing the decoded data.\n        \"\"\"\n        xsd_type = xsd_type or xsd_element.type\n        result_dict = self.dict()\n        if level == 0 and xsd_element.is_global() and not self.strip_namespaces and self:\n            schema_namespaces = set(xsd_element.namespaces.values())\n            result_dict.update(\n                ('%s:%s' % (self.ns_prefix, k) if k else self.ns_prefix, v)\n                for k, v in self._namespaces.items()\n                if v in schema_namespaces\n            )\n\n        if xsd_type.is_simple() or xsd_type.has_simple_content():\n            if data.attributes or self.force_dict and not xsd_type.is_simple():\n                result_dict.update(t for t in self.map_attributes(data.attributes))\n                if data.text is not None and data.text != '':\n                    result_dict[self.text_key] = data.text\n                return result_dict\n            else:\n                return data.text if data.text != '' else None\n        else:\n#            has_single_group = xsd_type.content_type.is_single()\n            list_types = list if self.list is list else (self.list, list)\n            dict_types = dict if self.dict is dict else (self.dict, dict)\n            if data.content:\n                for name, value, xsd_child in self.map_content(data.content):\n                    if isinstance(xsd_child, Xsd11AnyElement):\n                        result_dict.update({name:value})\n                        continue\n                    try:\n                        if isinstance(result_dict, list_types):\n                            result = result_dict\n                        else:\n                            result = result_dict[name]\n                    except KeyError:\n                        if xsd_child is not None and not xsd_child.is_single():\n                            result_dict = [{name:value}]\n                        else:\n                            result_dict[name] = self.list([value]) if self.force_list else value\n                    else:\n                        if isinstance(result, dict_types):\n                            result_dict[name] = self.list([result, value])\n                        elif isinstance(result, list_types) or not result:\n                            result_dict.append({name:value})\n                        else:\n                            result.append(value)\n\n            elif data.content is None and data.text is not None and data.text != '':\n                result_dict = data.text\n\n            elif data.text is not None and data.text != '':\n                result_dict[self.text_key] = data.text\n\n            if data.attributes:\n                result_dict.update(t for t in self.map_attributes(data.attributes))\n\n            if level == 0 and self.preserve_root:\n                return self.dict(\n                    [(self.map_qname(data.tag), result_dict if result_dict else None)]\n                )\n            return result_dict if result_dict else None\n</code></pre>"},{"location":"xml/#cuemsutils.xml.CMLCuemsConverter.CMLCuemsConverter.element_encode","title":"<code>element_encode(obj, xsd_element, level=0)</code>","text":"<p>Extracts XML decoded data from a data structure for encoding into an ElementTree. :param obj: the decoded object. :param xsd_element: the <code>XsdElement</code> associated to the decoded data structure. :param level: the level related to the encoding process (0 means the root). :return: an ElementData instance.</p> Source code in <code>src/cuemsutils/xml/CMLCuemsConverter.py</code> <pre><code>def element_encode(self, obj, xsd_element, level=0):\n    \"\"\"\n    Extracts XML decoded data from a data structure for encoding into an ElementTree.\n    :param obj: the decoded object.\n    :param xsd_element: the `XsdElement` associated to the decoded data structure.\n    :param level: the level related to the encoding process (0 means the root).\n    :return: an ElementData instance.\n    \"\"\"\n    if level != 0:\n        tag = xsd_element.name\n    elif not self.preserve_root:\n        tag = xsd_element.qualified_name\n    else:\n        tag = xsd_element.qualified_name\n        try:\n            obj = obj.get(tag, xsd_element.local_name)\n        except (KeyError, AttributeError, TypeError):\n            pass\n\n    if not isinstance(obj, (self.dict, dict)):\n        if xsd_element.type.is_simple() or xsd_element.type.has_simple_content():\n            return ElementData(tag, obj, None, {})\n        elif xsd_element.type.mixed and not isinstance(obj, list):\n            return ElementData(tag, obj, None, {})\n        else:\n            return ElementData(tag, None, obj, {})\n\n    text = None\n    content = []\n    attributes = {}\n\n    for name, value in obj.items():\n        if name == self.text_key and self.text_key:\n            text = obj[self.text_key]\n        elif (self.cdata_prefix and name.startswith(self.cdata_prefix)) or \\\n                name[0].isdigit() and self.cdata_prefix == '':\n            index = int(name[len(self.cdata_prefix):])\n            content.append((index, value))\n        elif name == self.ns_prefix:\n            self[''] = value\n        elif name.startswith('%s:' % self.ns_prefix):\n            if not self.strip_namespaces:\n                self[name[len(self.ns_prefix) + 1:]] = value\n        elif self.attr_prefix and name.startswith(self.attr_prefix):\n            attr_name = name[len(self.attr_prefix):]\n            ns_name = self.unmap_qname(attr_name, xsd_element.attributes)\n            attributes[ns_name] = value\n        elif not isinstance(value, (self.list, list)) or not value:\n            content.append((self.unmap_qname(name), value))\n        elif isinstance(value[0], (self.dict, dict, self.list, list)):\n            ns_name = self.unmap_qname(name)\n            content.extend((ns_name, item) for item in value)\n        else:\n            ns_name = self.unmap_qname(name)\n            for xsd_child in xsd_element.type.content_type.iter_elements():\n                matched_element = xsd_child.match(ns_name, resolve=True)\n                if matched_element is not None:\n                    if matched_element.type.is_list():\n                        content.append((ns_name, value))\n                    else:\n                        content.extend((ns_name, item) for item in value)\n                    break\n            else:\n                if self.attr_prefix == '' and ns_name not in attributes:\n                    for key, xsd_attribute in xsd_element.attributes.items():\n                        if xsd_attribute.is_matching(ns_name):\n                            attributes[key] = value\n                            break\n                    else:\n                        content.append((ns_name, value))\n                else:\n                    content.append((ns_name, value))\n\n    return ElementData(tag, text, content, attributes)\n</code></pre>"},{"location":"xml/#cuemsutils.xml.Settings.NetworkMap","title":"<code>NetworkMap</code>","text":"<p>               Bases: <code>Settings</code></p> <p>NetworkMap class that extends Settings to handle network map operations.</p> Source code in <code>src/cuemsutils/xml/Settings.py</code> <pre><code>class NetworkMap(Settings):\n    \"\"\"\n    NetworkMap class that extends Settings to handle network map operations.\n    \"\"\"\n    def __init__(self, xmlfile, schema_name = 'network_map', **kwargs):\n        if not hasattr(self, 'main_key'):\n            self.main_key = ''\n        super().__init__(\n            xmlfile,\n            schema_name,\n            xml_root_tag='CuemsNetworkMap',\n            **kwargs\n        )\n\n    def get_node(self, uuid):\n        out = None\n        network_dict = self.get_dict()\n        nodes_list = network_dict.get('node_list')\n        for node_item in nodes_list:\n            node = node_item.get('node')\n            if node.get('uuid') == uuid:\n                out = node\n                break\n        if not out:\n            raise ValueError(f'Node with uuid {uuid} not found')\n        return out\n\n    @staticmethod\n    def get_nodes_by_adoption(network_map_dict: dict[str, Any]) -&gt; tuple[list[dict[str, Any]], list[dict[str, Any]]]:\n        nodes = []\n        new_nodes = []\n\n        if not network_map_dict:\n            raise ValueError('No network map dictionary found')\n        node_list = network_map_dict.get('node_list', [])\n        if not node_list:\n            raise ValueError('No node list found in network map dictionary')\n        for node_item in node_list:\n            if 'node' in node_item:\n                # Convert boolean strings directly in the node_item structure\n                node_item['node']['online'] = strtobool(node_item['node'].get('online', 'False'))\n                node_item['node']['adopted'] = strtobool(node_item['node'].get('adopted', 'False'))\n\n                # Append the node_item directly (it already has the wrapper structure)\n                if node_item['node']['adopted']:\n                    nodes.append(node_item)\n                else:\n                    new_nodes.append(node_item)\n\n        return nodes, new_nodes\n</code></pre>"},{"location":"xml/#cuemsutils.xml.Settings.ProjectMappings","title":"<code>ProjectMappings</code>","text":"<p>               Bases: <code>Settings</code></p> <p>Mappings class that extends Settings to handle hardware mappings operations.</p> Source code in <code>src/cuemsutils/xml/Settings.py</code> <pre><code>class ProjectMappings(Settings):\n    \"\"\"\n    Mappings class that extends Settings to handle hardware mappings operations.\n    \"\"\"\n    def __init__(self, xmlfile, schema_name = 'project_mappings', **kwargs):\n        if not hasattr(self, 'main_key'):\n            self.main_key = ''\n        super().__init__(\n            xmlfile,\n            schema_name,\n            xml_root_tag='CuemsProjectMappings',\n            **kwargs\n        )\n\n    def get_node(self, uuid):\n        out = None\n        for node in self.processed['nodes']: # type: ignore[index]\n            node = node['node']\n            if node['uuid'] == uuid:\n                out = node\n                break\n        if not out:\n            raise ValueError(f'Node with uuid {uuid} not found')\n        return out\n\n    def process_xml_dict(self):\n        self.processed = self.get_dict()\n\n    def process_network_mappings(self, mappings):\n        '''Temporary process instead of reviewing xml read and convert to objects'''\n        # By now we need to correct the data structure from the xml\n        # the converter is not getting what we really intended but we'll\n        # correct it here by the moment\n        temp_nodes = []\n\n        Logger.info(f'Processing network mappings: {mappings}')\n\n        for node in mappings['nodes']:\n            temp_node = {}\n            for section, contents in node['node'].items():\n                if not isinstance(contents, list):\n                    temp_node[section] = contents\n                else:\n                    temp_node[section] = {}\n                    for item in contents:\n                        for key, values in item.items():\n                            temp_node[section][key] = []\n                            if values:\n                                for elem in values:\n                                    for subkey, subvalue in elem.items():\n                                        temp_node[section][key].append(subvalue)\n            temp_nodes.append(temp_node)\n\n        mappings['nodes'] = temp_nodes\n        return mappings\n</code></pre>"},{"location":"xml/#cuemsutils.xml.Settings.ProjectMappings.process_network_mappings","title":"<code>process_network_mappings(mappings)</code>","text":"<p>Temporary process instead of reviewing xml read and convert to objects</p> Source code in <code>src/cuemsutils/xml/Settings.py</code> <pre><code>def process_network_mappings(self, mappings):\n    '''Temporary process instead of reviewing xml read and convert to objects'''\n    # By now we need to correct the data structure from the xml\n    # the converter is not getting what we really intended but we'll\n    # correct it here by the moment\n    temp_nodes = []\n\n    Logger.info(f'Processing network mappings: {mappings}')\n\n    for node in mappings['nodes']:\n        temp_node = {}\n        for section, contents in node['node'].items():\n            if not isinstance(contents, list):\n                temp_node[section] = contents\n            else:\n                temp_node[section] = {}\n                for item in contents:\n                    for key, values in item.items():\n                        temp_node[section][key] = []\n                        if values:\n                            for elem in values:\n                                for subkey, subvalue in elem.items():\n                                    temp_node[section][key].append(subvalue)\n        temp_nodes.append(temp_node)\n\n    mappings['nodes'] = temp_nodes\n    return mappings\n</code></pre>"},{"location":"xml/#cuemsutils.xml.Settings.ProjectSettings","title":"<code>ProjectSettings</code>","text":"<p>               Bases: <code>Settings</code></p> <p>ProjectSettings class that extends Settings to handle project settings operations and override system-wide settings.</p> Source code in <code>src/cuemsutils/xml/Settings.py</code> <pre><code>class ProjectSettings(Settings):\n    \"\"\"\n    ProjectSettings class that extends Settings to handle project settings operations and override system-wide settings.\n    \"\"\"\n    def __init__(self, xmlfile, schema_name = 'project_settings', **kwargs):\n        if not hasattr(self, 'main_key'):\n            self.main_key = 'CuemsProjectSettings'\n        super().__init__(\n            xmlfile,\n            schema_name,\n            xml_root_tag='CuemsProjectSettings',\n            **kwargs\n        )\n</code></pre>"},{"location":"xml/#cuemsutils.xml.Settings.Settings","title":"<code>Settings</code>","text":"<p>               Bases: <code>XmlReaderWriter</code></p> <p>Settings class that extends XmlReaderWriter to handle configuration file operations.</p> Source code in <code>src/cuemsutils/xml/Settings.py</code> <pre><code>class Settings(XmlReaderWriter):\n    \"\"\"\n    Settings class that extends XmlReaderWriter to handle configuration file operations.\n    \"\"\"\n    def __init__(self, xmlfile, schema_name = 'settings', **kwargs):\n      if 'xml_root_tag' not in kwargs:\n        kwargs['xml_root_tag'] = \"CuemsSettings\"\n      super().__init__(\n          schema_name = schema_name,\n          xmlfile = xmlfile,\n          **kwargs\n      )\n      if not hasattr(self, 'main_key'):\n        self.main_key = 'Settings'\n      self.xml_dict = {}\n      self.processed = {}\n      self.loaded = False\n\n      if self.schema is not None and self.xmlfile is not None:\n          self.read()\n\n    def get_dict(self) -&gt; dict[str, Any]:\n        if self.main_key == '':\n            return self.xml_dict if isinstance(self.xml_dict, dict) else {}\n        value = self.xml_dict.get(self.main_key) # type: ignore[index]\n        if isinstance(value, dict):\n            return value\n        # If main_key value is not a dict (e.g., list), wrap it in a dict\n        return {self.main_key: value} if value is not None else {}\n\n    def backup(self):\n        if os.path.isfile(self.xmlfile):\n            Logger.info(\"File exist\")\n            try:\n                os.rename(self.xmlfile, \"{}.back\".format(self.xmlfile))\n            except OSError:\n                Logger.error(\"Cannot create settings backup\")\n        else:\n            Logger.error(\"Settings file not found\")\n\n    def read(self) -&gt; None:\n        self.xml_dict = self.schema_object.to_dict(\n            self.xmlfile,\n            validation = 'strict',\n            dict_class = dict,\n            list_class = list,\n            strip_namespaces = True,\n            attr_prefix = ''\n        )\n        if (hasattr(self, 'process_xml_dict')):\n            self.process_xml_dict() # type: ignore[attr-defined]\n        self.loaded = True\n\n    def data2xml(self, obj):\n        xml_tree = ET.Element(self.main_key)\n        self.xmldata = self.buildxml(xml_tree, obj)\n\n    def buildxml(self, xml_tree, d): #TODO: clean variable names, simplify\u00bf\n        if isinstance(d, dict):\n            for k, v in d.items():\n                if isinstance(k, str):\n                    s = ET.SubElement(xml_tree, k)\n\n                elif isinstance(k, (dict)):\n                    s = ET.SubElement(xml_tree, type(k).__name__)\n                    s.text = str(k)\n                elif isinstance(k, (int, float)):\n                    s = ET.SubElement(xml_tree, type(v).__name__, id=str(k))\n                    if not isinstance(v, dict):\n                        s.text =str(v)\n                else:\n                    s = ET.SubElement(xml_tree, type(k).__name__)\n\n                if isinstance(v, (type(None), CTimecode, dict, list, tuple, int, float, str)): #TODO: filter without using explicit classes (like CTimecode)\n                    self.buildxml(s, v)\n        elif isinstance(d, tuple) or isinstance(d, list):\n            for v in d:\n                s = ET.SubElement(xml_tree, type(v).__name__)\n                self.buildxml(s, v)\n        elif isinstance(d, str):\n            xml_tree.text = d\n        elif isinstance(d, (float, int)):\n      #  elif type(d) is int:\n            xml_tree.text = str(d)\n        else:\n            s = ET.SubElement(xml_tree, type(d).__name__)\n            self.buildxml(s, str(d))\n        return xml_tree\n</code></pre>"},{"location":"xml/#cuemsutils.xml.XmlReaderWriter.XmlReaderWriter","title":"<code>XmlReaderWriter</code>","text":"<p>               Bases: <code>CuemsXml</code></p> Source code in <code>src/cuemsutils/xml/XmlReaderWriter.py</code> <pre><code>class XmlReaderWriter(CuemsXml):\n    def write(self, xml_data: ElementTree):\n        self.schema_object.validate(xml_data)\n        xml_data.write(\n            self.xmlfile,\n            encoding = \"utf-8\",\n            xml_declaration = True\n        )\n\n    def write_from_dict(self, project_dict):\n        project_object = CuemsParser(project_dict).parse()\n        self.write_from_object(project_object)\n\n    def build_xml_from_object(self, project_object):\n        \"\"\"Build XML data from a project object\"\"\"\n        xml_data = XmlBuilder(\n            project_object,\n            namespace=self.namespace,\n            xsd_path=self.schema,\n            xml_root_tag=self.xml_root_tag\n        ).build()\n        return xml_data\n\n    def write_from_object(self, project_object):\n        \"\"\"Write a project object to an XML file\"\"\"\n        xml_data = self.build_xml_from_object(project_object)\n        self.write(xml_data)\n\n    def validate_object(self, project_object):\n        \"\"\"Validate a project object against the schema\"\"\"\n        xml_data = self.build_xml_from_object(project_object)\n        return self.schema_object.validate(xml_data)\n\n    def read(self, **kwargs):\n        return self.schema_object.to_dict(\n            self.xmlfile,\n            validation = 'strict',\n            strip_namespaces = False,\n            **kwargs\n        )\n\n    def read_to_objects(self):\n        xml_dict = self.read()\n        return CuemsParser(xml_dict).parse()\n</code></pre>"},{"location":"xml/#cuemsutils.xml.XmlReaderWriter.XmlReaderWriter.build_xml_from_object","title":"<code>build_xml_from_object(project_object)</code>","text":"<p>Build XML data from a project object</p> Source code in <code>src/cuemsutils/xml/XmlReaderWriter.py</code> <pre><code>def build_xml_from_object(self, project_object):\n    \"\"\"Build XML data from a project object\"\"\"\n    xml_data = XmlBuilder(\n        project_object,\n        namespace=self.namespace,\n        xsd_path=self.schema,\n        xml_root_tag=self.xml_root_tag\n    ).build()\n    return xml_data\n</code></pre>"},{"location":"xml/#cuemsutils.xml.XmlReaderWriter.XmlReaderWriter.validate_object","title":"<code>validate_object(project_object)</code>","text":"<p>Validate a project object against the schema</p> Source code in <code>src/cuemsutils/xml/XmlReaderWriter.py</code> <pre><code>def validate_object(self, project_object):\n    \"\"\"Validate a project object against the schema\"\"\"\n    xml_data = self.build_xml_from_object(project_object)\n    return self.schema_object.validate(xml_data)\n</code></pre>"},{"location":"xml/#cuemsutils.xml.XmlReaderWriter.XmlReaderWriter.write_from_object","title":"<code>write_from_object(project_object)</code>","text":"<p>Write a project object to an XML file</p> Source code in <code>src/cuemsutils/xml/XmlReaderWriter.py</code> <pre><code>def write_from_object(self, project_object):\n    \"\"\"Write a project object to an XML file\"\"\"\n    xml_data = self.build_xml_from_object(project_object)\n    self.write(xml_data)\n</code></pre>"},{"location":"xml/#cuemsutils.xml.XmlReaderWriter.get_pkg_schema","title":"<code>get_pkg_schema(schema_name)</code>","text":"<p>Get the schema file from package resources</p> Source code in <code>src/cuemsutils/xml/XmlReaderWriter.py</code> <pre><code>@logged\ndef get_pkg_schema(schema_name: str):\n    \"\"\"Get the schema file from package resources\"\"\"\n    schemas_dir = path.join(path.dirname(__file__), 'schemas')\n    if not schema_name[len(schema_name)-4:] == '.xsd':\n        schema_name = schema_name + '.xsd'\n    schema = path.join(schemas_dir, schema_name)\n    if not path.isfile(schema):\n        raise FileNotFoundError(f\"Schema file {schema_name} not found\")\n    return schema\n</code></pre>"}]}